tooling A function generates this Scrolldown grammar by combining all files in the grammars folder.
tooling
 Related work
 CSS is great for text selector ideas: https://www.w3schools.com/cssref/css_selectors.asp
 Roff has a lot of related markup ideas: https://www.systutorials.com/docs/linux/man/7-groff_man/
tagOrUrlCell
 description An HTML tag or a url.
 highlightScope constant.language
delimiterCell
 description String to use as a delimiter.
 highlightScope string
htmlAttributesCell
 highlightScope comment
classNameCell
 highlightScope constant
htmlIdCell
 extends idCell
dateCell
 highlightScope string
integerCell
 highlightScope constant.numeric
permalinkCell
 highlightScope string
codeCell
 highlightScope comment
commentCell
 highlightScope comment
bulletPointCell
 highlightScope keyword
anyCell
urlCell
 highlightScope constant.language
keywordCell
 highlightScope keyword
stringCell
 highlightScope string
idCell
 highlightScope constant.language
blankCell
aftertextTextNode
 catchAllCellType stringCell
 boolean isTextNode true
abstractScrollNode
 abstract
 cells keywordCell
aftertextNode
 description Text followed by markup commands.
 extends abstractScrollNode
 catchAllNodeType aftertextTextNode
 inScope abstractAftertextDirectiveNode abstractAftertextAttributeNode
 cruxFromId
 example
  aftertext
   Hello brave new world
   link home.com new
   bold brave new
   underline new world
   strikethrough wor
 javascript
  get markupInserts() {
   const { originalText } = this
   return this.filter(node => node.isMarkupNode)
    .map(node => node.getInserts(originalText))
    .filter(i => i)
    .flat()
  }
  get originalText() {
   return this.filter(node => node.isTextNode)
    .map(node => node.toString())
    .join("\n")
  }
  get text() {
   const { originalText, markupInserts } = this
   let adjustment = 0
   let newText = originalText
   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.
   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))
   markupInserts.forEach(insertion => {
    insertion.index += adjustment
    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0
    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0
    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)
    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters
   })
   return newText
  }
  compile() {
   return `<p ${this.divAttributes}class="scrollParagraphComponent">${this.text}</p>`
  }
  get divAttributes() {
   const attrs = this.filter(node => node.isAttributeNode)
   return attrs.length ? attrs.map(node => node.divAttributes).join(" ") + " " : ""
  }
loremIpsumNode
 extends aftertextNode
 description Generate dummy text.
 cruxFromId
 catchAllCellType integerCell
 javascript
  get originalText() {
   return `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`
  }
  compile() {
   return super.compile().repeat(this.getWord(1) ? parseInt(this.getWord(1)) : 1)
  }
abstractTopLevelSingleMetaNode
 abstract
 description Use these keywords once per file.
 extends abstractScrollNode
 cruxFromId
 cells keywordCell
 compiler
  stringTemplate 
permalinkNode
 description When compiling, Scroll will save this article to {permalink}.html
 extends abstractTopLevelSingleMetaNode
 cells keywordCell permalinkCell
skipIndexPageNode
 description Add this tag if you want to build a page but not include it in the index page.
 extends abstractTopLevelSingleMetaNode
titleNode
 catchAllCellType stringCell
 description Title of the article.
 extends abstractTopLevelSingleMetaNode
 javascript
  compile() {
   return `<h1 class="scrollTitleComponent"><a href="${this.getRootNode().permalink}.html">${this.getContent()}</a></h1>`
  }
htmlTitleNode
 catchAllCellType stringCell
 description Use this to override the automatic HTML <title> generation.
 extends abstractTopLevelSingleMetaNode
sourceLinkNode
 catchAllCellType urlCell
 description Use this to override the link to the source code for a scroll file.
 extends abstractTopLevelSingleMetaNode
dateNode
 catchAllCellType dateCell
 description Date the article was first published.
 extends abstractTopLevelSingleMetaNode
maxColumnsNode
 catchAllCellType integerCell
 description Set your own max column count for a single article's generated HTML.
 extends abstractTopLevelSingleMetaNode
columnWidthNode
 catchAllCellType integerCell
 description Set your own column width, in ch units, for the generated HTML.
 extends abstractTopLevelSingleMetaNode
endSnippetNode
 description Insert one of these where you want to cut the article for the snippets.html page.
 extends abstractTopLevelSingleMetaNode
chatNode
 description A dialogue between two people.
 catchAllNodeType chatLineNode
 cruxFromId
 extends abstractScrollNode
 javascript
  compile() {
   return this.map((line, index) => `<div class="scrollDialogueComponent ${index % 2 ? "scrollDialogueComponentRight" : "scrollDialogueComponentLeft"}"><span>${line.toString()}</span></div>`).join("")
  }
codeNode
 description A code block.
 catchAllNodeType lineOfCodeNode
 extends abstractScrollNode
 javascript
  compile() {
   return `<code class="scrollCodeBlockComponent">${this.childrenToString().replace(/\</g, "&lt;")}</code>`
  }
 cruxFromId
codeWithLanguageNode
 description Use this to specify the language of the code block, such as csvCode or rustCode.
 extends codeNode
 pattern ^[a-zA-Z0-9_]+Code$
belowAsCodeNode
 description Print the Scroll code of the next node.
 extends abstractScrollNode
 cruxFromId
 javascript
  get target() {
   return this.getNext()
  }
  compile() {
   return `<code class="scrollCodeBlockComponent">${this.target.toString().replace(/\</g, "&lt;")}</code>`
  }
aboveAsCodeNode
 description Print the Scroll code for the previous node.
 extends belowAsCodeNode
 javascript
  get target() {
   return this.getPrevious()
  }
commentNode
 description Will not appear in the compiled HTML.
 catchAllCellType commentCell
 extends abstractScrollNode
 cruxFromId
 javascript
  compile() {
   return ``
  }
 catchAllNodeType commentLineNode
cssNode
 extends abstractScrollNode
 description Prints CSS content wrapped in a style tag.
 cruxFromId
 extends abstractScrollNode
 catchAllNodeType cssLineNode
 javascript
  compile() {
   return `<style>${this.childrenToString()}</style>`
  }
abstractHeaderNode
 cruxFromId
 catchAllCellType stringCell
 extends abstractScrollNode
 catchAllNodeType multilineTitleNode
 javascript
  compile() {
   const children = this.childrenToString() ? " " + this.childrenToString() : ""
   return `<${this.tag} class="${this.className}">${this.getContent() + children}</${this.tag}>`
  }
sectionNode
 description Compiles to an h3 tag.
 extends abstractHeaderNode
 javascript
  tag = "h3"
  className = "scrollSectionComponent"
subsectionNode
 description Compiles to an h4 tag.
 extends abstractHeaderNode
 javascript
  tag = "h4"
  className = "scrollSubsectionComponent"
questionNode
 description Use for pages like FAQs.
 extends abstractHeaderNode
 javascript
  tag = "h4"
  className = "scrollQuestionComponent"
htmlNode
 description A catch all block to drop in any loose html.
 cruxFromId
 extends abstractScrollNode
 catchAllNodeType htmlLineNode
 javascript
  compile() {
   return `${this.childrenToString()}`
  }
imageNode
 description An img tag.
 cells keywordCell urlCell
 extends abstractScrollNode
 cruxFromId
 inScope imageCaptionNode
 javascript
  compile() {
   const dirPath = this.getParent().folder
   const src = this.getWord(1)
   let imgTag = ""
   try {
    const sizeOf = require("image-size")
    const dimensions = sizeOf(dirPath + "/" + src)
    const width = dimensions.width
    const height = dimensions.height
    imgTag = `<img src="${src}" width="${width}" height="${height}" loading="lazy"/>`
   } catch (err) {
    console.error(err)
    imgTag = `<img src="${src}">`
   }
   const caption = this.get("caption")
   const captionFig = caption ? `<figcaption>${caption}</figcaption>` : ""
   return `<figure class="scrollImageComponent"><a href="${src}" target="_blank">${imgTag}</a>${captionFig}</figure>`
  }
customHeaderNode
 extends abstractScrollNode
 description Define a header for a certain page. Setting to blank will also remove the header on a page.
 crux header
 catchAllNodeType stumpNode
 javascript
  compile() {
   return ""
  }
customFooterNode
 extends abstractScrollNode
 description Define a footer for a certain page. Setting to blank will also remove the footer on a page.
 crux footer
 catchAllNodeType stumpNode
 javascript
  compile() {
   return ""
  }
listNode
 description An unordered list.
 catchAllNodeType listItemNode
 cruxFromId
 extends abstractScrollNode
 compiler
  stringTemplate 
  openChildren <ul class="scrollUnorderedListComponent">
  closeChildren </ul>
orderedListNode
 description An ordered list.
 extends listNode
 cruxFromId
 compiler
  stringTemplate 
  openChildren <ol class="scrollOrderedListComponent">
  closeChildren </ol>
paragraphNode
 description Prose content.
 catchAllNodeType paragraphContentNode
 extends abstractScrollNode
 cruxFromId
 javascript
  get paragraphContent() {
   return this.childrenToString()
  }
  compile() {
   return `<p class="scrollParagraphComponent">${this.getRootNode().compileATags(this.paragraphContent)}</p>`
  }
quoteNode
 cruxFromId
 description A blockquote.
 catchAllNodeType quoteLineNode
 extends abstractScrollNode
 javascript
  compile() {
   return `<blockquote class="scrollQuoteComponent">${this.childrenToString()}</blockquote>`
  }
abstractTableNode
 cruxFromId
 catchAllNodeType rowNode
 extends abstractScrollNode
 javascript
  get tableHeader() {
   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\n`)
  }
  get columnNames() {
   const header = this.nodeAt(0)
   return header ? header.getLine().split(this.delimiter) : []
  }
  get columns() {
   const cols = this.columnNames
   return cols.map((name, index) => {
    const isLink = name.endsWith("Link")
    const linkIndex = cols.indexOf(name + "Link")
    return {
     name,
     isLink,
     linkIndex
    }
   })
  }
  get tableBody() {
   const { delimiter } = this
   return this.getTopDownArray()
    .slice(1)
    .map(node => `<tr>${node.toRow(this.columns, delimiter)}</tr>`)
    .join("\n")
  }
  compile() {
   return `<table class="scrollTableComponent"><thead><tr>${this.tableHeader.join("\n")}</tr></thead>\n<tbody>${this.tableBody}</tbody></table>`
  }
commaTableNode
 description Comma separated values table.
 extends abstractTableNode
 string delimiter ,
pipeTableNode
 description Pipe separated values table.
 extends abstractTableNode
 string delimiter |
spaceTableNode
 description Space separated values table. Last column is a catch all.
 extends abstractTableNode
 string delimiter  
tabTableNode
 description Tab separated values table.
 extends abstractTableNode
 string delimiter \t
treeTableNode
 description A table of data written in Tree Notation form. Useful when a column contains a text blob.
 extends abstractTableNode
 catchAllNodeType treeRowNode
 javascript
  get columnNames() {
   return this._getUnionNames()
  }
  get tableBody() {
   return this.map(node => `<tr>${node.toRow(this.columns)}</tr>`).join("\n")
  }
 example
  treeTable
   row
    name Javascript
    example
     console.log("Hello world")
   row
    name Python
    example
     print "Hello world"
abstractAftertextAttributeNode
 cells keywordCell
 boolean isAttributeNode true
 javascript
  get divAttributes() {
   return `${this.getWord(0)}="${this.getContent()}"`
  }
  compile() {
   return ""
  }
aftertextIdNode
 crux id
 description Provide an ID to be output in the generated HTML paragraph.
 extends abstractAftertextAttributeNode
 cells keywordCell htmlIdCell
 single
abstractAftertextDirectiveNode
 cells keywordCell
 catchAllCellType stringCell
 javascript
  isMarkupNode = true
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get shouldMatchAll() {
   return this.has("matchAll")
  }
  getMatches(text) {
   const { pattern } = this
   const escapedPattern = pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   return [...text.matchAll(new RegExp(escapedPattern, "g"))].map(match => {
    const { index } = match
    const endIndex = index + pattern.length
    return [
     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },
     { index: endIndex, endIndex, string: `</${this.closeTag}>` }
    ]
   })
  }
  getInserts(text) {
   const matches = this.getMatches(text)
   if (!matches.length) return false
   if (this.shouldMatchAll) return matches.flat()
   const indexNode = this.getNode("match")
   if (indexNode)
    return indexNode.indexes
     .map(index => matches[index])
     .filter(i => i)
     .flat()
   return matches[0]
  }
  get allAttributes() {
   const attr = this.attributes.join(" ")
   return attr ? " " + attr : ""
  }
  get attributes() {
   return []
  }
  get openTag() {
   return this.tag
  }
  get closeTag() {
   return this.tag
  }
abstractMarkupNode
 extends abstractAftertextDirectiveNode
 inScope abstractMarkupParameterNode
boldNode
 cruxFromId
 extends abstractMarkupNode
 javascript
  tag = "b"
italicsNode
 cruxFromId
 extends abstractMarkupNode
 javascript
  tag = "i"
underlineNode
 cruxFromId
 extends abstractMarkupNode
 javascript
  tag = "u"
aftertextCodeNode
 crux code
 extends abstractMarkupNode
 javascript
  tag = "code"
linkNode
 extends abstractMarkupNode
 cells keywordCell urlCell
 inScope linkNoteNode
 cruxFromId
 javascript
  tag = "a"
  get link() {
   return this.getWord(1)
  }
  get attributes() {
   const attrs = [`href="${this.link}"`]
   const title = this.getNode("note")
   if (title) attrs.push(`title="${title.childrenToString().replace(/\n/g, " ")}"`)
   return attrs
  }
  get pattern() {
   return this.getWordsFrom(2).join(" ")
  }
emailLinkNode
 description A mailto link
 crux email
 extends linkNode
 javascript
  get attributes() {
   return [`href="mailto:${this.link}"`]
  }
quickLinkNode
 pattern ^https\:
 extends linkNode
 cells urlCell
 javascript
  get link() {
   return this.getWord(0)
  }
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
classMarkupNode
 description Add a span with a class name around matching text.
 extends abstractMarkupNode
 cells keywordCell classNameCell
 crux class
 javascript
  tag = "span"
  get className() {
   return this.getWord(1)
  }
  get attributes() {
   return [`class="${this.className}"`]
  }
  get pattern() {
   return this.getWordsFrom(2).join(" ")
  }
caveatNode
 description Add a caveat viewable on hover on matching text. When you want to be sure you've thoroughly addressed obvious concerns but ones that don't warrant to distract from the main argument of the text.
 cruxFromId
 extends classMarkupNode
 cells keywordCell
 javascript
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get attributes() {
   return [`class="scrollCaveat"`, `title="${this.caveatText}"`]
  }
  get caveatText() {
   return this.childrenToString().replace(/\n/g, " ")
  }
strikethroughNode
 cruxFromId
 extends abstractMarkupNode
 javascript
  tag = "s"
wrapsOnNode
 cruxFromId
 description Enable `code`, *bold*, and _italics_ rules.
 extends abstractAftertextDirectiveNode
 javascript
  get shouldMatchAll() {
   return true
  }
  getMatches(text) {
   return [this.runPattern(text, "`", "code"), this.runPattern(text, "*", "strong"), this.runPattern(text, "_", "em")].filter(i => i).flat()
  }
  runPattern(text, delimiter, tag, attributes = "") {
   const escapedDelimiter = delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, "g")
   const delimiterLength = delimiter.length
   return [...text.matchAll(pattern)].map(match => {
    const { index } = match
    const endIndex = index + match[0].length
    return [
     { index, string: `<${tag + (attributes ? " " + attributes : "")}>`, endIndex, consumeStartCharacters: delimiterLength },
     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }
    ]
   })
  }
wrapNode
 cruxFromId
 cells keywordCell delimiterCell tagOrUrlCell
 catchAllCellType htmlAttributesCell
 extends wrapsOnNode
 description Define a custom wrap, for example "wrap _ em" would support: _italics_.
 javascript
  getMatches(text) {
   try {
    const delimiter = this.getWord(1)
    const tag = this.getWord(2)
    const attributes = this.getWordsFrom(3).join(" ")
    if (tag.startsWith("https:")) return this.runPattern(text, delimiter, "a", `href="${tag}"` + attributes)
    return this.runPattern(text, delimiter, tag, attributes)
   } catch (err) {
    console.error(err)
    return []
   }
   // Note: doubling up doesn't work because of the consumption characters.
  }
datelineNode
 cruxFromId
 description Gives your paragraph a dateline like "December 15, 2021 — The..."
 extends abstractAftertextDirectiveNode
 javascript
  getInserts() {
   let day =
    this.getContent() ||
    this.getParent()
     .getParent()
     .get("date")
   if (!day) return false
   try {
    const dayjs = require("dayjs")
    day = dayjs(day).format(`MMMM D, YYYY`)
   } catch (err) {
    console.error(err)
   }
   return [{ index: 0, string: `<span class="scrollArticleDateComponent">${day} — </span>` }]
  }
abstractMarkupParameterNode
 cells keywordCell
 cruxFromId
matchAllNode
 description Use this to match all occurrences of the text.
 extends abstractMarkupParameterNode
matchNode
 catchAllCellType integerCell
 description Use this to specify which index(es) to match.
 javascript
  get indexes() {
   return this.getWordsFrom(1).map(num => parseInt(num))
  }
 example
  aftertext
   hello ello ello
   bold ello
    match 0 2
 extends abstractMarkupParameterNode
linkNoteNode
 description When you want to include more information than just the link to your reference.
 crux note
 cells keywordCell
 example
  aftertext
   This report showed the treatment had a big impact.
  https://example.com/report This report.
   note
    The average growth in the treatment group was 14.2x higher than the control group.
 baseNodeType blobNode
 compiler
  stringTemplate 
catchAllParagraphNode
 description A catch all block. This may be removed in future versions.
 catchAllCellType stringCell
 baseNodeType errorNode
 compiler
  stringTemplate <p class="scrollParagraphComponent">{stringCell}</p>
chatLineNode
 catchAllCellType anyCell
 catchAllNodeType chatLineNode
lineOfCodeNode
 catchAllCellType codeCell
 catchAllNodeType lineOfCodeNode
commentLineNode
 catchAllCellType commentCell
cssLineNode
 catchAllCellType anyCell
 catchAllNodeType cssLineNode
multilineTitleNode
 catchAllCellType stringCell
htmlLineNode
 catchAllCellType anyCell
 catchAllNodeType htmlLineNode
imageCaptionNode
 description An optional caption to accompany the image.
 crux caption
 cells keywordCell
 catchAllCellType stringCell
stumpNode
 description Stump is a Tree Language that compiles to HTML.
 catchAllCellType anyCell
 catchAllNodeType stumpNode
listItemNode
 cells bulletPointCell
 catchAllCellType stringCell
 javascript
  compile() {
   return `<li>${this.getRootNode().compileATags(this.getContent() || "")}</li>`
  }
paragraphContentNode
 catchAllCellType stringCell
errorNode
 baseNodeType errorNode
blankLineNode
 description Blank lines compile to nothing in the HTML.
 cells blankCell
 compiler
  stringTemplate 
 pattern ^$
 tags doNotSynthesize
quoteLineNode
 catchAllCellType anyCell
 catchAllNodeType quoteLineNode
scrolldownNode
 extensions scroll
 description A simple language for structurable thought. An extensible alternative to Markdown. Compiles to HTML.
 root
 inScope abstractScrollNode blankLineNode
 catchAllNodeType catchAllParagraphNode
 compilesTo html
 javascript
  get permalink() {
   return this.get("permalink") || this._permalink || ""
  }
  setPermalink(permalink) {
   this._permalink = permalink
   return this
  }
  get folder() {
   return this._folder || ""
  }
  setFolder(folder) {
   this._folder = folder
   return this
  }
  compileATags(text) {
   // todo: a better place for these util functions? I stick them in here so the
   // grammar is all in one file for ease of use in TreeLanguageDesigner
   const linkReplacer = (match, p1, p2, p3, offset, str) => {
    let suffix = ""
    if (p3.endsWith(",")) suffix = "," + suffix
    if (p3.endsWith(".")) suffix = "." + suffix
    p3 = p3.replace(/(,|\.)$/, "")
    let prefix = "https://"
    const isRelativeLink = p3.startsWith("./")
    if (isRelativeLink) {
     prefix = ""
     p3 = p3.substr(2)
    }
    if (p3.startsWith("https://") || p3.startsWith("http://")) prefix = ""
    return `${p1}<a href="${prefix}${p3}">${p2}</a>${suffix}`
   }
   return text.replace(/(^|\s)(\S+)🔗(\S+)(?=(\s|$))/g, linkReplacer)
  }
 example
  title Hello world
  section This is Scrolldown
  
  paragraph
   It compiles to HTML. Blank lines get turned into brs.
  
  code
   // You can add code as well.
   print("Hello world")
rowNode
 catchAllCellType stringCell
 javascript
  toRow(columns, delimiter) {
   const words = this.getLine().split(delimiter)
   let str = ""
   let column = 0
   const columnCount = columns.length
   while (column < columnCount) {
    const col = columns[column]
    column++
    const content = columnCount === column ? words.slice(columnCount - 1).join(" ") : words[column - 1]
    if (col.isLink) continue
    let tagged = ""
    const link = words[col.linkIndex]
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    else tagged = this.getRootNode().compileATags(content ?? "")
    str += `<td>${tagged}</td>\n`
   }
   return str
  }
treeRowContentNode
 description Any blob content in a cell.
 cells stringCell
 catchAllCellType stringCell
treeRowColumnNode
 catchAllNodeType treeRowContentNode
 description A columnName value pair, or just a columnName if the value is a text blob.
 cells idCell
 catchAllCellType stringCell
treeRowNode
 cells idCell
 description The root node of a row.
 catchAllNodeType treeRowColumnNode
 javascript
  toRow(columns) {
   let str = ""
   columns.forEach(col => {
    const node = this.getNode(col.name)
    if (col.isLink) return
    if (!node) {
     str += "<td></td>\n"
     return
    }
    const content = node.length ? node.childrenToString() : node.getContent()
    let tagged = ""
    const link = this.get(col.name + "Link")
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    else if (node.length) tagged = `<pre>${content ?? ""}</pre>`
    else tagged = content ?? ""
    str += `<td>${tagged}</td>\n`
   })
   return str
  }