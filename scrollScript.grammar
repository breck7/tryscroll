tooling
 Related work
 CSS is great for text selector ideas: https://www.w3schools.com/cssref/css_selectors.asp
 Roff has a lot of related markup ideas: https://www.systutorials.com/docs/linux/man/7-groff_man/
anyCell
urlCell
 highlightScope constant.language
keywordCell
 highlightScope keyword
stringCell
 highlightScope string
idCell
 highlightScope constant.language
dateCell
 highlightScope string
integerCell
 highlightScope constant.numeric
permalinkCell
 highlightScope string
commentCell
 highlightScope comment
blankCell
personNameCell
 extends stringCell
codeCell
 highlightScope comment
bulletPointCell
 description Any token used as a bullet point such as "-" or "1." or ">"
 highlightScope keyword
emailAddressCell
 extends stringCell
tagOrUrlCell
 description An HTML tag or a url.
 highlightScope constant.language
delimiterCell
 description String to use as a delimiter.
 highlightScope string
htmlAttributesCell
 highlightScope comment
classNameCell
 highlightScope constant
htmlIdCell
 extends idCell
filePathCell
 extends stringCell
groupNameCell
 extends stringCell
htmlAnyCell
 extends anyCell
javascriptCell
 extends stringCell
abstractScrollNode
 cells keywordCell
 javascript
  compileSnippet() {
   return this.compile()
  }
abstractAftertextNode
 description Text followed by markup commands.
 extends abstractScrollNode
 inScope abstractAftertextDirectiveNode abstractAftertextAttributeNode
 example
  aftertext
   Hello brave new world
   link home.com new
   bold brave new
   underline new world
   strikethrough wor
 javascript
  get markupInserts() {
   const { originalTextPostLinkify } = this
   return this.filter(node => node.isMarkupNode)
    .map(node => node.getInserts(originalTextPostLinkify))
    .filter(i => i)
    .flat()
  }
  get originalText() {
    return this.getContent() ?? ""
  }
  get originalTextPostLinkify() {
   const {originalText} = this
   const shouldLinkify = originalText.includes("<a ") ? false : true
   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText
  }
  replaceNotes(originalText) {
   this.getRootNode().footnotes.forEach((note, index) => {
    const needle = note.getWord(0)
    if (originalText.includes(needle))
        originalText = originalText.replace(needle, `<a href="#${note.anchorId}" class="scrollNoteLink" id="${note.linkBack()}"><sup>${note.noteId}</sup></a>`)
   })
   return originalText
  }
  get text() {
   const { originalTextPostLinkify, markupInserts } = this
   let adjustment = 0
   let newText = originalTextPostLinkify
   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.
   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))
   markupInserts.forEach(insertion => {
    insertion.index += adjustment
    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0
    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0
    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)
    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters
   })
   return newText
  }
  tag = "p"
  className = "scrollParagraphComponent"
  compile() {
   return `<${this.tag} ${this.divAttributes}class="${this.className}">${this.text}</${this.tag}>`
  }
  get divAttributes() {
   const attrs = this.filter(node => node.isAttributeNode)
   return attrs.length ? attrs.map(node => node.divAttributes).join(" ") + " " : ""
  }
thoughtNode
 todo Perhaps rewrite this from scratch and move out of aftertext.
 extends abstractAftertextNode
 catchAllCellType stringCell
 example
  * I had a _new_ thought.
 description A thought.
 crux *
 javascript
  compile() {
   // Hacky, I know.
   const newLine = this.appendLine("wrapsOn")
   const compiled = super.compile()
   newLine.destroy()
   return compiled
  }
blinkNode
 description Useful when you have a client that always needs to find 1 thing they would like you to change.
 extends thoughtNode
 crux blink
 javascript
  compile() {
   return `<span class="scrollBlink">${super.compile()}</span>
    <script>
    setInterval(()=>{
        Array.from(document.getElementsByClassName("scrollBlink")).forEach(el => 
        el.style.color = el.style.color === "white" ? "black" : "white"
        )
    }, 2000)
    </script>`
  }
footnoteDefinitionNode
 description A footnote. Can also be used as section notes.
 extends thoughtNode
 boolean isFootnote true
 pattern ^\^.+$
 javascript
  get divAttributes() {
   return super.divAttributes + ` id="${this.anchorId}"`
  }
  get anchorId() {
    return `note${this.noteIndex}`
  }
  get noteId() {
    // In the future we could allow common practices like author name
    return this.noteIndex
  }
  linkBack() {
    return `noteUsage${this.noteIndex}`
  }
  get text() {
   return `<a class="scrollNoteIndex" href="#noteUsage${this.noteIndex}">${this.noteIndex}</a> ${super.text}`
  }
  get noteIndex() {
   return this.getParent().footnotes.indexOf(this) + 1
  }
captionAftertextNode
 description An optional caption to accompany the resource.
 crux caption
 extends thoughtNode
listAftertextNode
 extends thoughtNode
 example
  - I had a _new_ thought.
 description A list item.
 crux -
 javascript
  compile() {
   const index = this.getIndex()
   const parent = this.getParent()
   const isStartOfList =
    index === 0 ||
    !parent
     .nodeAt(index - 1)
     .getLine()
     .startsWith("- ")
   const isEndOfList =
    parent.length === index + 1 ||
    !parent
     .nodeAt(index + 1)
     .getLine()
     .startsWith("- ")
   const { listType } = this
   return (isStartOfList ? `<${listType}>` : "") + `${super.compile()}` + (isEndOfList ? `</${listType}>` : "")
  }
  tag = "li"
  get listType() {
   return "ul" // todo: in the future add support for ol
  }
sectionTitleNode
 description Compiles to an html h3 tag.
 extends thoughtNode
 crux #
 javascript
  compile() {
    this.getParent().stack.push("</div>")
    return `<div class="scrollSectionComponent">` + super.compile()
  }
  tag = "h3"
sectionSubTitleNode
 description Compiles to an html h4 tag.
 extends sectionTitleNode
 crux ##
 javascript
  tag = "h4"
questionAftertextNode
 description A question.
 extends sectionTitleNode
 crux ?
 javascript
  tag = "h4"
  className = "scrollQuestionComponent"
startColumnsNode
 extends abstractAftertextNode
 cruxFromId
 catchAllCellType integerCell
 description Start a multicolumn grid.
 javascript
  compileSnippet() {
   return ""
  }
  compile() {
   const columnWidth = 35
   const COLUMN_GAP = 20
   const maxColumns = parseInt(this.getWord(1) ?? 10)
   const maxTotalWidth = maxColumns * columnWidth + (maxColumns - 1) * COLUMN_GAP
   return `<div class="scrollColumnsComponent" style="column-width:${columnWidth}ch;column-count:${maxColumns};max-width:${maxTotalWidth}ch;">`
  }
endColumnsNode
 extends abstractAftertextNode
 cruxFromId
 description End a multicolumn grid.
 javascript
  compile() {
   return "</div>"
  }
  compileSnippet() {
   return ""
  }
scrollCssTagNode
 extends abstractAftertextNode
 cruxFromId
 description Prints the Scroll CSS in an <style> tag. To not print the style tag use `scrollCss`.
 javascript
  compile() {
   return `<style>${this.getParent().file.SCROLL_CSS}</style>`
  }
  compileSnippet() {
   return ""
  }
scrollCssNode
 extends scrollCssTagNode
 javascript
  compile() {
   return this.getParent().file.SCROLL_CSS
  }
scrollFooterNode
 extends abstractAftertextNode
 cruxFromId
 javascript
  compileSnippet() {
   return ""
  }
  compile() {
   const file = this.getParent().file
   const { SVGS, SCROLL_VERSION, viewSourceUrl } = file
   const closeContainerTag = "</div>"
   return (
    closeContainerTag +
    file.compileStumpCode(`p
   class scrollFileViewSourceUrlComponent doNotPrint
   a View source
    href ${viewSourceUrl}
  div
   class scrollFooterComponent doNotPrint
   a ${SVGS.email}
    href mailto:${file.email}
   a ${SVGS.git}
    href ${file.git}
   a Built with Scroll v${SCROLL_VERSION}
    href https://scroll.pub
    class scrollCommunityLinkComponent`)
   )
  }
scrollHeaderNode
 extends abstractAftertextNode
 cruxFromId
 description The simple default Scroll header.
 javascript
  compileSnippet() {
   return ""
  }
  compile() {
   const file = this.getParent().file
   const { SVGS, linkToPrevious, linkToNext } = file
   let previousButton = ""
   if (linkToPrevious)
    previousButton = `a <
    class scrollPrevPageLink
    href ${linkToPrevious}`
   let nextButton = ""
   if (linkToNext)
    nextButton = `a >
    class scrollNextPageLink
    href ${linkToNext}`
   return file.compileStumpCode(`div
   class scrollHeaderComponent doNotPrint
   ${previousButton}
   a ${SVGS.home}
    class scrollTopLeftBarComponent
    href index.html
   a ${SVGS.git}
    class scrollTopRightBarComponent
    href ${file.git}
   ${nextButton}`)
  }
loremIpsumNode
 extends abstractAftertextNode
 cruxFromId
 description Generate dummy text.
 catchAllCellType integerCell
 javascript
  compile() {
   const text = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`
   return text.repeat(this.getWord(1) ? parseInt(this.getWord(1)) : 1)
  }
snippetsNode
 extends abstractAftertextNode
 cruxFromId
 cells keywordCell groupNameCell
 description Prints the snippets of all files in a folder that are in the named group.
 example
  snippets index
 javascript
  methodForGettingHtml = "htmlCodeForSnippetsPage"
  makeSnippet(file) {
   const snippet = new TreeNode(`div
   class scrollSnippetContainerComponent`)
   const div = snippet.getNode("div")
   div.appendLineAndChildren("bern", file[this.methodForGettingHtml])
   return snippet.toString().replace(/\n/g, "\n ")
  }
  compile() {
   const groupName = this.getWord(1)
   const file = this.getParent().file
   const { folder } = file
   const files = folder.getGroup(groupName)
   const snippets = files.map(file => this.makeSnippet(file)).join("\n ")
   const code = `div
   class scrollColumnsComponent
   style column-width:35ch;
   ${snippets}`
   return file.compileStumpCode(code)
  }
fullSnippetsNode
 extends snippetsNode
 cruxFromId
 description Prints the full contents of files in a folder that are in the named group.
 javascript
  methodForGettingHtml = "compiledSnippet"
viewSourceNode
 extends abstractAftertextNode
 cruxFromId
 javascript
  compileSnippet() {
   return ""
  }
  compile() {
   const file = this.getParent().file
   const { viewSourceUrl } = file
   return file.compileStumpCode(`p
   class scrollFileViewSourceUrlComponent doNotPrint
   a View source
    href ${viewSourceUrl}`)
  }
authorNode
 description Prints an author byline with an optional link to a page for the author.
 extends abstractScrollNode
 cruxFromId
 cells keywordCell urlCell
 catchAllCellType personNameCell
 example
  comment With Link:
  author https://breckyunits.com Breck Yunits
  comment No link:
  author  Breck Yunits
 javascript
  compile() {
   const link = this.getWord(1)
   return `<div class="scrollAuthor">by <a ${link ? `href="${link}"` : ""}>${this.getWordsFrom(2).join(" ")}</a></div>`
  }
chatNode
 description A dialogue between two people.
 catchAllNodeType chatLineNode
 cruxFromId
 extends abstractScrollNode
 javascript
  compile() {
   return this.map((line, index) => `<div class="scrollDialogueComponent ${index % 2 ? "scrollDialogueComponentRight" : "scrollDialogueComponentLeft"}"><span>${line.toString()}</span></div>`).join("")
  }
codeNode
 description A code block.
 catchAllNodeType lineOfCodeNode
 extends abstractScrollNode
 javascript
  compile() {
   return `<code class="scrollCodeBlockComponent">${this.childrenToString().replace(/\</g, "&lt;")}</code>`
  }
 cruxFromId
codeWithLanguageNode
 description Use this to specify the language of the code block, such as csvCode or rustCode.
 extends codeNode
 pattern ^[a-zA-Z0-9_]+Code$
belowAsCodeNode
 description Print the Scroll code of the next node.
 extends abstractScrollNode
 cruxFromId
 javascript
  get target() {
   return this.getNext()
  }
  compile() {
   return `<code class="scrollCodeBlockComponent">${this.target.toString().replace(/\</g, "&lt;")}</code>`
  }
aboveAsCodeNode
 description Print the Scroll code for the previous node.
 extends belowAsCodeNode
 javascript
  get target() {
   return this.getPrevious()
  }
commentNode
 description Will not appear in the compiled HTML.
 catchAllCellType commentCell
 extends abstractScrollNode
 cruxFromId
 javascript
  compile() {
   return ``
  }
 catchAllNodeType commentLineNode
cssNode
 extends abstractScrollNode
 description Prints CSS content wrapped in a style tag.
 cruxFromId
 catchAllNodeType cssLineNode
 javascript
  compile() {
   return `<style>${this.childrenToString()}</style>`
  }
abstractTopLevelSingleMetaNode
 description Use these keywords once per file.
 extends abstractScrollNode
 cruxFromId
 cells keywordCell
 javascript
  compile() {
   return ""
  }
dateNode
 catchAllCellType dateCell
 description Date this file was first published.
 extends abstractTopLevelSingleMetaNode
groupsNode
 description Add this file to zero or more groups.
 cruxFromId
 example
  groups index.html
 extends abstractTopLevelSingleMetaNode
 cells keywordCell
 catchAllCellType permalinkCell
metaTagsNode
 cruxFromId
 extends abstractTopLevelSingleMetaNode
 description Adds meta tags like title, description, et cetera.
 javascript
  compileSnippet() {
   return ""
  }
  compile() {
   const { file } = this.getParent()
   const { title, description, openGraphImage, SCROLL_VERSION } = file
   const rssFeedUrl = file.get("rssFeedUrl")
   let rssTag = ""
   if (rssFeedUrl) {
    rssTag = `link
   rel alternate
   type application/rss+xml
   title ${title}
   href ${rssFeedUrl}`
   }
   return file.compileStumpCode(`meta
   charset utf-8
  titleTag ${title}
  script /* The HTML below was generated by 📜 Scroll v${SCROLL_VERSION}. http://scroll.pub */
  styleTag @media print {.doNotPrint {display: none !important;}}
  meta
   charset iso-8859-1
  meta
   name viewport
   content width=device-width,initial-scale=1
  meta
   name description
   content ${description}
  meta
   name generator
   content Scroll v${SCROLL_VERSION}
  meta
   property og:title
   content ${title}
  meta
   property og:description
   content ${description}
  meta
   property og:image
   content ${openGraphImage}
   ${rssTag}
  meta
   name twitter:card
   content summary_large_image`)
  }
descriptionNode
 catchAllCellType stringCell
 description Description for Open Graph. https://ogp.me/. If not defined, Scroll will try to generate it's own.
 extends abstractTopLevelSingleMetaNode
permalinkNode
 description When compiling, Scroll will save this file to {permalink}
 extends abstractTopLevelSingleMetaNode
 cells keywordCell permalinkCell
endSnippetNode
 description Insert one of these where you want to cut the file for a snippet.
 extends abstractTopLevelSingleMetaNode
titleNode
 catchAllCellType stringCell
 description Title of the page.
 extends abstractTopLevelSingleMetaNode
 inScope hiddenTitleNode
 javascript
  compile() {
   const { file } = this.getParent()
   return this.has("hidden") ? "" : `<h1 class="scrollTitleComponent"><a href="${file.permalink}">${this.getContent()}</a></h1>`
  }
viewSourceUrlNode
 catchAllCellType urlCell
 description Use this to override the link to the source code for a scroll file.
 extends abstractTopLevelSingleMetaNode
abstractFolderSettingNode
 extends abstractScrollNode
 cells keywordCell
 javascript
  compile() {
   return ""
  }
abstractUrlSettingNode
 extends abstractFolderSettingNode
 cells keywordCell urlCell
 cruxFromId
baseUrlNode
 description Root url of this published folder on the web. Must be provided for RSS Feeds and OpenGraph tags to work, but has no effect locally.
 extends abstractUrlSettingNode
viewSourceBaseUrlNode
 description The base link to be used to generate the "View source" link.
 extends abstractUrlSettingNode
gitNode
 description A link to the web Git UI for this folder.
 extends abstractUrlSettingNode
openGraphImageNode
 description URL for Open Graph Image. https://ogp.me/. If not defined, Scroll will try to generate it's own using the first image tag on your page.
 extends abstractUrlSettingNode
rssFeedUrlNode
 description URL for RSS feed, if any.
 extends abstractUrlSettingNode
abstractSiteStringSettingNode
 extends abstractFolderSettingNode
 catchAllCellType stringCell
 cruxFromId
emailNode
 description Email address for the folder owner.
 extends abstractFolderSettingNode
 cruxFromId
 cells keywordCell emailAddressCell
scrollNodeTypeDefinitionNode
 extends abstractScrollNode
 todo Figure out best pattern for integrating Scroll and Grammar?
 pattern ^[a-zA-Z0-9_]+Node$
 description Define your own nodeTypes in the Grammar language for using in your Scroll files.
 baseNodeType blobNode
 javascript
  compile() {
   return ""
  }
htmlNode
 description A catch all block to drop in any loose html. Use for HTML one liners and/or blocks of HTML.
 cruxFromId
 extends abstractScrollNode
 catchAllNodeType htmlLineNode
 catchAllCellType htmlAnyCell
 javascript
  compile() {
   return `${this.getContent() ?? ""}${this.childrenToString()}`
  }
stumpNode
 cruxFromId
 extends abstractScrollNode
 description Stump is a Tree Language that compiles to HTML.
 catchAllNodeType stumpContentNode
 javascript
  compile() {
   const file = this.getParent().file
   return file.compileStumpCode(this.childrenToString())
  }
stumpNoSnippetNode
 extends stumpNode
 description Useful for headers and footers when you have something you don't want included in snippets.
 cruxFromId
 javascript
  compileSnippet() {
   return ""
  }
abstractCaptionedNode
 extends abstractScrollNode
 cells keywordCell urlCell
 inScope captionAftertextNode
 cruxFromId
 javascript
  compile() {
    const caption = this.getNode("caption")
    const captionFig = caption ? `<figcaption>${caption.compile()}</figcaption>` : ""
    return `<figure class="scrollCaptionedComponent">${this.content}${captionFig}</figure>`
  }
imageNode
 description An img tag.
 extends abstractCaptionedNode
 javascript
  get content() {
   const file = this.getRootNode().file
   const folder = file.folder.folder
   const src = this.getWord(1)
   let dimensionAttributes = ""
   // If its a local image, get the dimensions and put them in the HTML
   // to avoid flicker
   if (!src.startsWith("http:") && !src.startsWith("https:")) {
    try {
     const sizeOf = require("image-size")
     const path = require("path")
     const dimensions = sizeOf(path.join(folder, src))
     const width = dimensions.width
     const height = dimensions.height
     dimensionAttributes = `width="${width}" height="${height}" `
    } catch (err) {
     console.error(err)
    }
   }
   return `<a href="${src}" target="_blank"><img src="${src}" ${dimensionAttributes}loading="lazy"></a>`
  }
youTubeNode
 extends abstractCaptionedNode
 description Embed a YouTube video. Include the YouTube embed URL such as https://www.youtube.com/embed/CYPYZnVQoLg
 javascript
  get content() {
   const url = this.getWord(1).replace("youtube.com/watch?v=", "youtube.com/embed/")
   return `<div class="youTubeHolder"><iframe class="youTubeEmbed" src="${url}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>`
  }
importNode
 description Import one file into another.
 cruxFromId
 extends abstractScrollNode
 catchAllCellType filePathCell
 javascript
  compile() {
   return ""
  }
 example
  import header.scroll
importOnlyNode
 description Mark a file as not one to build. This line will be not be imported into the importing file.
 cruxFromId
 extends abstractScrollNode
 javascript
  compile() {
   return ""
  }
keyboardNavNode
 description Makes left go to previous file and right go to next file.
 extends abstractScrollNode
 cruxFromId
 catchAllCellType urlCell
 javascript
  compileSnippet() {
   return ""
  }
  compile() {
   const file = this.getRootNode().file
   const linkToPrevious = this.getWord(1) ?? file.linkToPrevious
   const linkToNext = this.getWord(2) ?? file.linkToNext
   const script = `<script>document.addEventListener('keydown', function(event) {
    if (document.activeElement !== document.body) return
    const getLinks = () => document.getElementsByClassName("scrollKeyboardNav")[0].getElementsByTagName("a")
    if (event.key === "ArrowLeft")
      getLinks()[0].click()
    else if (event.key === "ArrowRight")
      getLinks()[1].click()
   });</script>`
   return `<div class="scrollKeyboardNav"><a href="${linkToPrevious}">${linkToPrevious}</a> · ${file.permalink} · <a href="${linkToNext}">${linkToNext}</a>${script}</div>`
  }
quoteNode
 cruxFromId
 description A blockquote.
 catchAllNodeType quoteLineNode
 extends abstractScrollNode
 javascript
  compile() {
   return `<blockquote class="scrollQuoteComponent">${this.childrenToString()}</blockquote>`
  }
readingListNode
 extends abstractScrollNode
 description Easily create a reading list with links, titles, and author names.
 cells keywordCell
 cruxFromId
 catchAllNodeType readingListItemNode
 example
  readingList
   https://example.com/similar by Author Name
 javascript
  compile() {
   return `<br><ul>${this.map(child => child.compile()).join("\n")}</ul>`
  }
redirectToNode
 description Prints an HTML redirect tag. In the future might also emit nginx config.
 extends abstractScrollNode
 cells keywordCell urlCell
 cruxFromId
 example
  redirectTo https://scroll.pub/releaseNotes.html
 javascript
  compile() {
   return `<meta http-equiv="Refresh" content="0; url='${this.getWord(1)}'" />`
  }
replaceNode
 description Define a variable token and replacement that will be applied to all lines before and after this one.
 extends abstractScrollNode
 cruxFromId
 catchAllCellType stringCell
 baseNodeType blobNode
 example
  replace YEAR 2022
 javascript
  compile() {
   return ""
  }
replaceJsNode
 description Define a variable token and replacement that will be applied to all lines before and after this one.
 extends replaceNode
 catchAllCellType javascriptCell
 example
  replaceJs SUM 1+1
  * 1+1 = SUM
replaceDefaultNode
 description Define the default value for a replacement. Useful if you want to import a file and set a replacement later.
 extends abstractScrollNode
 catchAllCellType stringCell
 baseNodeType blobNode
 example
  replaceDefault YEAR 2021
 cruxFromId
 javascript
  compile() {
   return ""
  }
printFeedNode
 description Prints out the RSS feed for a group.
 extends abstractScrollNode
 cruxFromId
 cells keywordCell groupNameCell
 javascript
  compile() {
   const dayjs = require("dayjs")
   const file = this.getRootNode().file
   const folder = file.folder
   const files = folder.getGroup(this.getWord(1))
   const { title, baseUrl, description } = file
   return `<?xml version="1.0" encoding="ISO-8859-1" ?>
  <rss version="2.0">
  <channel>
   <title>${title}</title>
   <link>${baseUrl}</link>
   <description>${description}</description>
   <lastBuildDate>${dayjs().format("ddd, DD MMM YYYY HH:mm:ss ZZ")}</lastBuildDate>
   <language>en-us</language>
  ${files.map(file => file.toRss()).join("\n")}
  </channel>
  </rss>`
  }
abstractTableNode
 cruxFromId
 catchAllNodeType rowNode
 extends abstractScrollNode
 javascript
  get tableHeader() {
   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\n`)
  }
  get columnNames() {
   const header = this.nodeAt(0)
   return header ? header.getLine().split(this.delimiter) : []
  }
  get columns() {
   const cols = this.columnNames
   return cols.map((name, index) => {
    const isLink = name.endsWith("Link")
    const linkIndex = cols.indexOf(name + "Link")
    return {
     name,
     isLink,
     linkIndex
    }
   })
  }
  get tableBody() {
   const { delimiter } = this
   return this.getTopDownArray()
    .slice(1)
    .map(node => `<tr>${node.toRow(this.columns, delimiter)}</tr>`)
    .join("\n")
  }
  compile() {
   return `<table class="scrollTableComponent"><thead><tr>${this.tableHeader.join("\n")}</tr></thead>\n<tbody>${this.tableBody}</tbody></table>`
  }
tableNode
 description A table with a custom delimiter.
 extends abstractTableNode
 catchAllCellType anyCell
 javascript
  get delimiter() {
    return this.getContent() ?? ""
  }
commaTableNode
 description Comma separated values table.
 extends abstractTableNode
 string delimiter ,
pipeTableNode
 description Pipe separated values table.
 extends abstractTableNode
 string delimiter |
spaceTableNode
 description Space separated values table. Last column is a catch all.
 extends abstractTableNode
 string delimiter  
tabTableNode
 description Tab separated values table.
 extends abstractTableNode
 string delimiter \t
treeTableNode
 description A table of data written in Tree Notation form. Useful when a column contains a text blob.
 extends abstractTableNode
 catchAllNodeType treeRowNode
 javascript
  get columnNames() {
   return this._getUnionNames()
  }
  get tableBody() {
   return this.map(node => `<tr>${node.toRow(this.columns)}</tr>`).join("\n")
  }
 example
  treeTable
   row
    name Javascript
    example
     console.log("Hello world")
   row
    name Python
    example
     print "Hello world"
kpiTableNode
 description Display key statistics in a big font.
 catchAllNodeType rowNode
 cruxFromId
 extends abstractScrollNode
 example
  kpiTable
   #2 Popularity
   30 Years Old
   $456 Revenue
 javascript
  get tableBody() {
   const items = this.getTopDownArray()
   let str = ""
   for (let i = 0; i < items.length; i = i + 3) {
    str += this.makeRow(items.slice(i, i + 3))
   }
   return str
  }
  makeRow(items) {
   return `<tr>` + items.map(node => `<td>${node.getWord(0)}<span>${node.getContent()}</span></td>`).join("\n") + `</tr>\n`
  }
  compile() {
   return `<table class="scrollKpiTable">${this.tableBody}</table>`
  }
abstractAftertextAttributeNode
 cells keywordCell
 boolean isAttributeNode true
 javascript
  get divAttributes() {
   return `${this.getWord(0)}="${this.getContent()}"`
  }
  compile() {
   return ""
  }
aftertextIdNode
 crux id
 description Provide an ID to be output in the generated HTML paragraph.
 extends abstractAftertextAttributeNode
 cells keywordCell htmlIdCell
 single
abstractAftertextDirectiveNode
 cells keywordCell
 catchAllCellType stringCell
 javascript
  isMarkupNode = true
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get shouldMatchAll() {
   return this.has("matchAll")
  }
  getMatches(text) {
   const { pattern } = this
   const escapedPattern = pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   return [...text.matchAll(new RegExp(escapedPattern, "g"))].map(match => {
    const { index } = match
    const endIndex = index + pattern.length
    return [
     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },
     { index: endIndex, endIndex, string: `</${this.closeTag}>` }
    ]
   })
  }
  getInserts(text) {
   const matches = this.getMatches(text)
   if (!matches.length) return false
   if (this.shouldMatchAll) return matches.flat()
   const indexNode = this.getNode("match")
   if (indexNode)
    return indexNode.indexes
     .map(index => matches[index])
     .filter(i => i)
     .flat()
   return matches[0]
  }
  get allAttributes() {
   const attr = this.attributes.join(" ")
   return attr ? " " + attr : ""
  }
  get attributes() {
   return []
  }
  get openTag() {
   return this.tag
  }
  get closeTag() {
   return this.tag
  }
abstractMarkupNode
 extends abstractAftertextDirectiveNode
 inScope abstractMarkupParameterNode
boldNode
 cruxFromId
 extends abstractMarkupNode
 javascript
  tag = "b"
italicsNode
 cruxFromId
 extends abstractMarkupNode
 javascript
  tag = "i"
underlineNode
 cruxFromId
 extends abstractMarkupNode
 javascript
  tag = "u"
aftertextCodeNode
 crux code
 extends abstractMarkupNode
 javascript
  tag = "code"
linkNode
 extends abstractMarkupNode
 cells keywordCell urlCell
 inScope linkTitleNode linkTargetNode commentNode
 cruxFromId
 javascript
  tag = "a"
  get link() {
   return this.getWord(1)
  }
  get attributes() {
   const attrs = [`href="${this.link}"`]
   const options = ["title", "target"]
   options.forEach(option => {
    const node = this.getNode(option)
   if (node) attrs.push(`${option}="${node.getContent()}"`)
   })
   return attrs
  }
  patternStartsAtWord = 2
  get pattern() {
   // If no pattern is provided, apply to the *entire* content.
   const words = this.getWordsFrom(this.patternStartsAtWord)
   return words.length ? words.join(" ") : this.getParent().getContent()
  }
emailLinkNode
 description A mailto link
 crux email
 extends linkNode
 javascript
  get attributes() {
   return [`href="mailto:${this.link}"`]
  }
quickLinkNode
 pattern ^https?\:
 extends linkNode
 cells urlCell
 javascript
  get link() {
   return this.getWord(0)
  }
  patternStartsAtWord = 1
classMarkupNode
 description Add a span with a class name around matching text. If no matching text provided, class will be set on the whole element.
 extends abstractMarkupNode
 cells keywordCell classNameCell
 crux class
 javascript
  tag = "span"
  get className() {
   return this.getWord(1)
  }
  get attributes() {
   return [`class="${this.className}"`]
  }
  get pattern() {
   const words = this.getWordsFrom(2)
   return words.length ? words.join(" ") : this.getParent().getContent()
  }
hoverNoteNode
 description Add a caveat viewable on hover on matching text. When you want to be sure you've thoroughly addressed obvious concerns but ones that don't warrant to distract from the main argument of the text.
 cruxFromId
 extends classMarkupNode
 catchAllNodeType lineOfTextNode
 cells keywordCell
 javascript
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get attributes() {
   return [`class="scrollHoverNote"`, `title="${this.hoverNoteText}"`]
  }
  get hoverNoteText() {
   return this.childrenToString().replace(/\n/g, " ")
  }
strikethroughNode
 cruxFromId
 extends abstractMarkupNode
 javascript
  tag = "s"
wrapsOnNode
 cruxFromId
 description Enable `code`, *bold*, and _italics_ rules.
 extends abstractAftertextDirectiveNode
 javascript
  get shouldMatchAll() {
   return true
  }
  getMatches(text) {
   return [this.runPattern(text, "`", "code"), this.runPattern(text, "*", "strong"), this.runPattern(text, "_", "em")].filter(i => i).flat()
  }
  runPattern(text, delimiter, tag, attributes = "") {
   const escapedDelimiter = delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, "g")
   const delimiterLength = delimiter.length
   return [...text.matchAll(pattern)].map(match => {
    const { index } = match
    const endIndex = index + match[0].length
    return [
     { index, string: `<${tag + (attributes ? " " + attributes : "")}>`, endIndex, consumeStartCharacters: delimiterLength },
     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }
    ]
   })
  }
wrapNode
 cruxFromId
 cells keywordCell delimiterCell tagOrUrlCell
 catchAllCellType htmlAttributesCell
 extends wrapsOnNode
 description Define a custom wrap, for example "wrap _ em" would support: _italics_.
 javascript
  getMatches(text) {
   try {
    const delimiter = this.getWord(1)
    const tag = this.getWord(2)
    const attributes = this.getWordsFrom(3).join(" ")
    if (tag.startsWith("https:")) return this.runPattern(text, delimiter, "a", `href="${tag}"` + attributes)
    return this.runPattern(text, delimiter, tag, attributes)
   } catch (err) {
    console.error(err)
    return []
   }
   // Note: doubling up doesn't work because of the consumption characters.
  }
datelineNode
 cruxFromId
 description Gives your paragraph a dateline like "December 15, 2021 — The..."
 extends abstractAftertextDirectiveNode
 javascript
  getInserts() {
   let day =
    this.getContent() ||
    this.getParent()
     .getParent()
     .get("date")
   if (!day) return false
   try {
    const dayjs = require("dayjs")
    day = dayjs(day).format(`MMMM D, YYYY`)
   } catch (err) {
    console.error(err)
   }
   return [{ index: 0, string: `<span class="scrollDateComponent">${day} — </span>` }]
  }
dayjsNode
 description Advanced directive that evals some Javascript code in an environment including "dayjs".
 cruxFromId
 extends abstractAftertextDirectiveNode
 javascript
  getInserts() {
   const dayjs = require("dayjs")
   const days = eval(this.getContent())
   const index = this.getParent().originalTextPostLinkify.indexOf("days")
   return [{ index, string: `${days} ` }]
  }
abstractMarkupParameterNode
 cells keywordCell
 cruxFromId
matchAllNode
 description Use this to match all occurrences of the text.
 extends abstractMarkupParameterNode
matchNode
 catchAllCellType integerCell
 description Use this to specify which index(es) to match.
 javascript
  get indexes() {
   return this.getWordsFrom(1).map(num => parseInt(num))
  }
 example
  aftertext
   hello ello ello
   bold ello
    match 0 2
 extends abstractMarkupParameterNode
abstractHtmlAttributeNode
 javascript
  compile() {
   return ""
  }
linkTargetNode
 extends abstractHtmlAttributeNode
 description If you want to set the target of the link. To "_blank", for example.
 crux target
 cells keywordCell anyCell
linkTitleNode
 description If you want to set the title of the link.
 crux title
 cells keywordCell
 catchAllCellType anyCell
 example
  * This report showed the treatment had a big impact.
   https://example.com/report This report.
    title The average growth in the treatment group was 14.2x higher than the control group.
catchAllParagraphNode
 description A catch all block. This may be removed in future versions.
 catchAllCellType stringCell
 baseNodeType errorNode
 javascript
  compile() {
   return `<p class="scrollParagraphComponent">${this.getLine()}</p>`
  }
errorNode
 baseNodeType errorNode
chatLineNode
 catchAllCellType anyCell
 catchAllNodeType chatLineNode
lineOfCodeNode
 catchAllCellType codeCell
 catchAllNodeType lineOfCodeNode
commentLineNode
 catchAllCellType commentCell
cssLineNode
 catchAllCellType anyCell
 catchAllNodeType cssLineNode
lineOfTextNode
 catchAllCellType stringCell
 boolean isTextNode true
htmlLineNode
 catchAllCellType htmlAnyCell
 catchAllNodeType htmlLineNode
stumpContentNode
 catchAllCellType anyCell
quoteLineNode
 catchAllCellType anyCell
 catchAllNodeType quoteLineNode
readingListItemNode
 cells urlCell
 catchAllCellType stringCell
 javascript
  compile() {
   const url = this.getWord(0)
   const [title, author] = this.getContent().split(" by ")
   return `<li><a href="${url}">${title ?? url}</a>${author ? ` by ${author}` : ""}</li>`
  }
blankLineNode
 description Blank lines compile to nothing in the HTML.
 cells blankCell
 javascript
  compile() {
   return this.getParent().clearStack()
  }
 pattern ^$
 tags doNotSynthesize
scrollScriptNode
 extensions scroll
 description Tools for thought that compile to HTML.
 root
 inScope abstractScrollNode blankLineNode
 catchAllNodeType catchAllParagraphNode
 compilesTo html
 javascript
  setFile(file) {
   this.file = file
   return this
  }
  stack = []
  clearStack() {
    const result = this.stack.join("")
    this.stack = []
    return result
  }
  compileSnippet() {
   return this.map(child => (child.compileSnippet ? child.compileSnippet() : child.compile())).join("\n")
  }
  get footnotes() {
   if (this._footnotes === undefined)
    this._footnotes = this.filter(node => node.isFootnote)
   return this._footnotes
  }
  file = {}
  get permalink() {
   return this.get("permalink") || this.file.permalink || ""
  }
 example
  # Hello world
  ## This is Scroll
  * It compiles to HTML. Blank lines get turned into brs.
  
  code
   // You can add code as well.
   print("Hello world")
rowNode
 catchAllCellType stringCell
 javascript
  toRow(columns, delimiter) {
   const words = this.getLine().split(delimiter)
   let str = ""
   let column = 0
   const columnCount = columns.length
   while (column < columnCount) {
    const col = columns[column]
    column++
    const content = columnCount === column ? words.slice(columnCount - 1).join(" ") : words[column - 1]
    if (col.isLink) continue
    let tagged = content
    const link = words[col.linkIndex]
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    str += `<td>${tagged}</td>\n`
   }
   return str
  }
hiddenTitleNode
 description Set this to not print the title.
 crux hidden
 cells keywordCell
treeRowContentNode
 description Any blob content in a cell.
 cells stringCell
 catchAllCellType stringCell
treeRowColumnNode
 catchAllNodeType treeRowContentNode
 description A columnName value pair, or just a columnName if the value is a text blob.
 cells idCell
 catchAllCellType stringCell
treeRowNode
 cells idCell
 description The root node of a row.
 catchAllNodeType treeRowColumnNode
 javascript
  toRow(columns) {
   let str = ""
   columns.forEach(col => {
    const node = this.getNode(col.name)
    if (col.isLink) return
    if (!node) {
     str += "<td></td>\n"
     return
    }
    const content = node.length ? node.childrenToString() : node.getContent()
    let tagged = ""
    const link = this.get(col.name + "Link")
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    else if (node.length) tagged = `<pre>${content ?? ""}</pre>`
    else tagged = content ?? ""
    str += `<td>${tagged}</td>\n`
   })
   return str
  }