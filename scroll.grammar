// Related work:
 CSS is great for text selector ideas: https://www.w3schools.com/cssref/css_selectors.asp
 Roff has a lot of related markup ideas: https://www.systutorials.com/docs/linux/man/7-groff_man/
// Note: this is an MVP of Scroll Datasets for initial experimentation and to test the syntax. Few features are implemented yet.
// todo: copy the external library to folder so it works offline?
// Extend this if you want to create a new provider
// Some basic providers:

























wrapNameCell
 description What wraps are available to turn on?
 enum bold italics code katex
anyCell
enumCell
urlCell
 highlightScope constant.language
keywordCell
 highlightScope keyword
stringCell
 highlightScope string
booleanCell
 highlightScope constant.language
 enum true false
idCell
 highlightScope constant.language
dateCell
 highlightScope string
integerCell
 highlightScope constant.numeric
floatCell
 highlightScope constant.numeric
permalinkCell
 highlightScope string
 description A string that doesn't contain characters that might interfere with most filesystems. No slashes, for instance.
commentCell
 highlightScope comment
blankCell
personNameCell
 extends stringCell
codeCell
 highlightScope comment
bulletPointCell
 description Any token used as a bullet point such as "-" or "1." or ">"
 highlightScope keyword
emailAddressCell
 extends stringCell
tagOrUrlCell
 description An HTML tag or a url.
 highlightScope constant.language
delimiterCell
 description String to use as a delimiter.
 highlightScope string
htmlAttributesCell
 highlightScope comment
htmlTagCell
 highlightScope constant.language
 enum div span p a img ul ol li h1 h2 h3 h4 h5 h6 header nav section article aside main footer input button form label select option textarea table tr td th tbody thead tfoot br hr meta link script style title code
classNameCell
 highlightScope constant
htmlIdCell
 extends idCell
filePathCell
 extends stringCell
cssAnyCell
 extends anyCell
valueCell
 highlightScope comment
measureTypeCell
 extends enumCell
 enum string int bool url uid float enum
measureNameCell
 highlightScope keyword
groupNameCell
 extends permalinkCell
groupNameWithOptionalFolderCell
 description A group name optionally combined with a folder path. Only used when referencing groups, not in posts.
 extends stringCell
htmlAnyCell
 extends stringCell
javascriptCell
 extends stringCell
abstractScrollParser
 cells keywordCell
 javascript
  compileEmbeddedVersion(compileSettings) {
   return this.compile(compileSettings)
  }
abstractAftertextParser
 description Text followed by markup commands.
 extends abstractScrollParser
 inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser aftertextTagParser commentParser
 example
  aftertext
   Hello brave new world
   link home.com new
   bold brave new
   underline new world
   strikethrough wor
 javascript
  get markupInserts() {
   const { originalTextPostLinkify } = this
   return this.filter(node => node.isMarkup)
    .map(node => node.getInserts(originalTextPostLinkify))
    .filter(i => i)
    .flat()
  }
  get originalText() {
   return this.content ?? ""
  }
  get originalTextPostLinkify() {
   const { originalText } = this
   const shouldLinkify = this.get("linkify") === "false" || originalText.includes("<a ") ? false : true
   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText
  }
  replaceNotes(originalText) {
   // Skip the replacements if there are no footnotes or the text has none.
   if (!this.root.footnotes.length || !originalText.includes("^")) return originalText
   this.root.footnotes.forEach((note, index) => {
    const needle = note.firstWord
    const {linkBack} = note
    if (originalText.includes(needle)) originalText = originalText.replace(new RegExp("\\" + needle + "\\b"), `<a href="#${note.anchorId}" class="scrollNoteLink" id="${linkBack}"><sup>${note.label}</sup></a>`)
   })
   return originalText
  }
  get text() {
   const { originalTextPostLinkify, markupInserts } = this
   let adjustment = 0
   let newText = originalTextPostLinkify
   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.
   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))
   markupInserts.forEach(insertion => {
    insertion.index += adjustment
    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0
    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0
    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)
    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters
   })
   return newText
  }
  tag = "p"
  get className() {
   const classLine = this.getNode("class")
   if (classLine && classLine.applyToParentElement) return classLine.content
   return this.defaultClassName
  }
  defaultClassName = "scrollParagraph"
  get isHidden() {
    return this.has("hidden")
  }
  compile(compileSettings) {
   if (this.isHidden) return ""
   this.compileSettings = compileSettings
   const { className } = this
   const classAttr = className ? `class="${this.className}"` : ""
   const tag = this.get("tag") || this.tag
   return `<${tag} ${this.divAttributes}${classAttr}>${this.text}</${tag}>`
  }
  get divAttributes() {
   const attrs = this.filter(node => node.isAttribute)
   return attrs.length ? attrs.map(node => node.divAttributes).join(" ") + " " : ""
  }
thoughtParser
 // todo Perhaps rewrite this from scratch and move out of aftertext.
 extends abstractAftertextParser
 catchAllCellType stringCell
 description A thought.
 cruxFromId
 javascript
  compile(compileSettings) {
   if (this.isHidden) return ""
   // Hacky, I know.
   const newLine = this.has("wrapsOn") ? undefined : this.appendLine("wrapsOn")
   const compiled = super.compile(compileSettings)
   if (newLine)
    newLine.destroy()
   return compiled
  }
indentableThoughtParser
 extends thoughtParser
 inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser indentableThoughtParser
 javascript
  compile() {
   return (
    super.compile() +
    this.map(node => node.compile())
     .join("\n")
     .trim()
   )
  }
checklistTodoParser
 extends indentableThoughtParser
 example
  [] Get milk
 description An incomplete checklist item.
 crux []
 string checked 
 javascript
  get text() {
   return `<div style="text-indent:${(this.getIndentLevel() - 1) * 20}px;"><input type="checkbox" ${this.checked} id="${this.id}"><label for="${this.id}">` + super.text + `</label></div>`
  }
  get id() {
   return this.get("id") || "item" + this._getUid()
  }
checklistDoneParser
 extends checklistTodoParser
 description A complete checklist list item.
 string checked checked
 crux [x]
 example
  [x] get milk
listAftertextParser
 extends indentableThoughtParser
 example
  - I had a _new_ thought.
 description A list item.
 crux -
 javascript
  defaultClassName = ""
  compile() {
   const index = this.getIndex()
   const parent = this.parent
   const nodeClass = this.constructor
   const isStartOfList = index === 0 || !(parent.nodeAt(index - 1) instanceof nodeClass)
   const isEndOfList = parent.length === index + 1 || !(parent.nodeAt(index + 1) instanceof nodeClass)
   const { listType } = this
   return (isStartOfList ? `<${listType} ${this.attributes}>` : "") + `${super.compile()}` + (isEndOfList ? `</${listType}>` : "")
  }
  get attributes() {
    return ""
  }
  tag = "li"
  listType = "ul"
orderedListAftertextParser
 extends listAftertextParser
 description A list item.
 example
  1. Hello world
 pattern ^\d+\. 
 javascript
  listType = "ol"
  get attributes() { return ` start="${this.getWord(0)}"`}
blinkParser
 description Useful when you have a client that always needs to find 1 thing they would like you to change.
 extends thoughtParser
 crux blink
 javascript
  compile() {
   return `<span class="scrollBlink">${super.compile()}</span>
    <script>
    setInterval(()=>{
        Array.from(document.getElementsByClassName("scrollBlink")).forEach(el => 
        el.style.color = el.style.color === "white" ? "black" : "white"
        )
    }, 2000)
    </script>`
  }
catchAllParagraphParser
 description Any top level line that doesn't match a keyword is treated as a thought (aka paragraph) node.
 extends thoughtParser
 cells stringCell
 javascript
  get originalText() {
   return this.getLine() || ""
  }
footnoteDefinitionParser
 description A footnote. Can also be used as section notes.
 extends thoughtParser
 boolean isFootnote true
 pattern ^\^.+$
 // We need to quickLinks back in scope because there is currently a bug in JTree/Grammar where if a parser extending a parent class has a child parser defined, then any regex parsers in the parent class will not be tested unless explicitly included in scope again.
 inScope quickLinkParser
 labelParser
  description If you want to show a custom label for a footnote. Default label is the note definition index.
  cruxFromId
  cells keywordCell
  catchAllCellType stringCell
 javascript
  get divAttributes() {
   return super.divAttributes + ` id="${this.anchorId}"`
  }
  get anchorId() {
   return `note${this.noteDefinitionIndex}`
  }
  get label() {
   // In the future we could allow common practices like author name
   return this.get("label") || `[${this.noteDefinitionIndex}]`
  }
  get linkBack() {
   return `noteUsage${this.noteDefinitionIndex}`
  }
  get text() {
   return `<a class="scrollFootNoteUsageLink" href="#noteUsage${this.noteDefinitionIndex}">${this.label}</a> ${super.text}`
  }
  get noteDefinitionIndex() {
   return this.parent.footnotes.indexOf(this) + 1
  }
captionAftertextParser
 description An optional caption to accompany the resource.
 crux caption
 extends thoughtParser
abstractHeaderParser
 extends thoughtParser
 javascript
  compile(compileSettings) {
   if (this.isHidden) return ""
   this.parent.sectionStack.push("</div>")
   return `<div class="scrollSection">` + super.compile(compileSettings)
  }
h4Parser
 description Compiles to an html h4 tag.
 extends abstractHeaderParser
 crux ####
 javascript
  tag = "h4"
questionAftertextParser
 description A question.
 extends h4Parser
 crux ?
 javascript
  defaultClassName = "scrollQuestion"
h1Parser
 description Compiles to an html h1 tag.
 extends abstractHeaderParser
 crux #
 javascript
  tag = "h1"
titleParser
 description Title of the page for meta tags and also compiles to an html h1 tag.
 extends abstractHeaderParser
 crux title
 javascript
  compile(compileSettings) {
   // Hacky, I know.
   const { permalink } = this.parent.file
   if (!permalink) return super.compile(compileSettings)
   const newLine = this.appendLine(`link ${permalink}`)
   const compiled = super.compile(compileSettings)
   newLine.destroy()
   return compiled
  }
  defaultClassName = "scrollTitle"
  tag = "h1"
h2Parser
 description Compiles to an html h2 tag.
 extends abstractHeaderParser
 crux ##
 javascript
  tag = "h2"
h3Parser
 description Compiles to an html h3 tag.
 extends abstractHeaderParser
 crux ###
 javascript
  tag = "h3"
h5Parser
 description Compiles to an html h5 tag.
 extends abstractHeaderParser
 crux #####
 javascript
  tag = "h5"
quickThoughtParser
 crux *
 extends thoughtParser
 example
  * I had a _new_ thought.
startColumnsParser
 extends abstractAftertextParser
 cruxFromId
 catchAllCellType integerCell
 description Start a multicolumn grid.
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  columnWidth = 35
  columnGap = 20
  compile() {
   const {columnWidth, columnGap} = this
   const maxColumns = parseInt(this.getWord(1) ?? 10)
   const maxTotalWidth = maxColumns * columnWidth + (maxColumns - 1) * columnGap
   // Starting the columns always first clears the section stack.
   return this.parent.clearSectionStack() + `<div class="scrollColumns" style="column-width:${columnWidth}ch;column-count:${maxColumns};max-width:${maxTotalWidth}ch;">`
  }
wideColumnsParser
 extends startColumnsParser
 description Start a double wide column.
 javascript
  columnWidth = 90
endColumnsParser
 extends abstractAftertextParser
 cruxFromId
 description End a multicolumn grid.
 javascript
  compile() {
   return "</div>"
  }
  compileEmbeddedVersion() {
   return ""
  }
horizontalRuleParser
 crux ---
 description Prints an html <hr> tag
 extends abstractAftertextParser
 javascript
  compile() {
   return `<hr>`
  }
dinkusParser
 crux ***
 description Prints a centered *
 extends abstractAftertextParser
 javascript
  compile() {
   return `<div class="dinkus"><span>${this.dinkus}</span></div>`
  }
  dinkus = "*"
loopParser
 extends abstractAftertextParser
 cells keywordCell
 description Iterate over files, lines or words, evaluating code and joining the resulting HTML.
 cruxFromId
 inScope abstractItemsProviderParser
 joinParser
  extends abstractLoopConfigParser
  description HTML to use to join the items.
 limitParser
  extends abstractLoopConfigParser
  description HTML to use to join the items.
 javascriptParser
  extends abstractLoopConfigParser
  description Javascript to execute for each file in the loop.
 javascript
  compile() {
   const code = this.get("javascript")
   const joinWith = this.get("join") ?? ""
   try {
    const limit = this.get("limit")
    let items = this.items
    if (limit) items = items.slice(0, parseInt(limit))
    return items.map((item, index) => eval(code)).join(joinWith)
   } catch (err) {
    console.error(err)
    return ""
   } finally {
    this.teardown()
   }
  }
  get items() {
   const provider = this.getChildInstancesOfParserId("abstractItemsProviderParser")[0]
   return provider ? provider.items : []
  }
  teardown() {}
loremIpsumParser
 extends abstractAftertextParser
 cruxFromId
 description Generate dummy text.
 catchAllCellType integerCell
 javascript
  compile() {
   const text = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`
   return text.repeat(this.getWord(1) ? parseInt(this.getWord(1)) : 1)
  }
snippetsParser
 extends abstractAftertextParser
 cruxFromId
 cells keywordCell groupNameWithOptionalFolderCell
 catchAllCellType groupNameWithOptionalFolderCell
 description Prints the snippets of all files in the named group(s).
 example
  snippets index
 javascript
  makeSnippet(file, compileSettings) {
    const {scrollProgram} = file
    const snippetBreak = scrollProgram.getNode("endSnippet")
    if (!snippetBreak) return scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml
    const indexOfBreak = snippetBreak.getIndex()
    const linkRelativeToCompileTarget = compileSettings.relativePath + file.permalink
    const joinChar = "\n"
    const html = scrollProgram
        .map((child, index) => (index >= indexOfBreak ? "" : child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))
        .filter(i => i)
        .join(joinChar)
        .trim() +
      `<a class="scrollContinueReadingLink" href="${linkRelativeToCompileTarget}">Continue reading...</a>`
    return html + file.viewSourceHtml
  }
  compile() {
   const file = this.parent.file
   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1))
   const alreadyRequired = this.root.alreadyRequired
   const snippets = files.map(file => {
   const compileSettings = {relativePath: file.relativePath, alreadyRequired }
   return `<div class="scrollSnippetContainer">${this.makeSnippet(file.file, compileSettings)}</div>`
   }).join("\n\n")
   return `<div class="scrollColumns" style="column-width:35ch;">${snippets}</div>`
  }
fullSnippetsParser
 extends snippetsParser
 cruxFromId
 description Prints the full contents of files that are in the named group.
 javascript
  makeSnippet(file, compileSettings) {
   return file.scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml
  }
viewSourceParser
 extends abstractAftertextParser
 cruxFromId
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const file = this.parent.file
   const { viewSourceUrl } = file
   return file.compileStumpCode(`p
   class scrollViewSource doNotPrint
   a View source
    href ${viewSourceUrl}`)
  }
chatParser
 description A dialogue between two people.
 catchAllParser chatLineParser
 cruxFromId
 extends abstractScrollParser
 javascript
  compile() {
   return this.map((line, index) => `<div style="text-align: ${index % 2 ? "right" : "left"};" class="scrollChat ${index % 2 ? "scrollChatRight" : "scrollChatLeft"}"><span>${line.asString}</span></div>`).join("")
  }
codeParser
 description A code block.
 catchAllParser lineOfCodeParser
 extends abstractScrollParser
 javascript
  compile() {
   return `<code class="scrollCodeBlock">${this.childrenToString().replace(/\</g, "&lt;")}</code>`
  }
 cruxFromId
codeWithLanguageParser
 description Use this to specify the language of the code block, such as csvCode or rustCode.
 extends codeParser
 pattern ^[a-zA-Z0-9_]+Code$
abstractScrollWithRequirementsParser
 extends abstractScrollParser
 javascript
  compile(compileSettings) {
    const {requireOnce} = this
    const set = compileSettings?.alreadyRequired || this.root.alreadyRequired
    let requireSnippet = ""
    if (!set.has(requireOnce)) {
      set.add(requireOnce)
      requireSnippet = requireOnce + "\n\n"
    }
    return requireSnippet + this.compileInstance()
  }
copyButtonsParser
 cruxFromId
 extends abstractScrollWithRequirementsParser
 description Make code snippets copyable.
 javascript
  compileInstance() {
   return ""
  }
 string requireOnce
  <script>
  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollCodeBlock").forEach(block =>
   {
    if (!navigator.clipboard) return
    const button = document.createElement("span")
    button.classList.add("scrollCopyButton")
    block.appendChild(button)
    button.addEventListener("click", async () => {
      await navigator.clipboard.writeText(block.innerText)
      button.classList.add("scrollCopiedButton")
    })
   }
  ))
  </script>
katexParser
 cruxFromId
 extends abstractScrollWithRequirementsParser
 catchAllCellType codeCell
 catchAllParser lineOfCodeParser
 description Use the KaTex library to typeset math.
 string requireOnce
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.6/dist/katex.min.css" integrity="sha384-mXD7x5S50Ko38scHSnD4egvoExgMPbrseZorkbE49evAfv9nNcbrXJ8LLNsDgh9d" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.6/dist/katex.min.js" integrity="sha384-j/ZricySXBnNMJy9meJCtyXTKMhIJ42heyr7oAdxTDBy/CYA9hzpMo+YTNV5C+1X" crossorigin="anonymous"></script>
  <script>
  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollKatex").forEach(el =>
   {
    katex.render(el.innerText, el, {
        throwOnError: false
    });
   }
  ))
  </script>
 javascript
  compileInstance() {
   const id = this._getUid()
   const content = this.content === undefined ? "" : this.content
   return `<div class="scrollKatex" id="${id}">${content + this.childrenToString()}</div>`
  }
mapParser
 cruxFromId
 inScope latParser longParser
 zoomParser
  cells keywordCell integerCell
  cruxFromId
  single
 heightParser
  cells keywordCell floatCell
  cruxFromId
  single
 pointParser
  cells keywordCell
  inScope latParser longParser
  cruxFromId
  titleParser
   extends abstractPointConfigParser
  descriptionParser
   extends abstractPointConfigParser
 extends abstractScrollWithRequirementsParser
 description Uses LeafletJs
 // todo Make this only require once
 string requireOnce
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
 javascript
  compileInstance() {
   const height = 500
   const id = this._getUid()
   return `<div id="map${id}" style="height: ${height}px;"></div>
  <script>
   {
    const lat = ${this.get("lat") ?? 37.8}
    const long = ${this.get("long") ?? 4}
    const zoomLevel = ${this.get("zoom") ?? 4}
    const points = ${JSON.stringify(this.findNodes("point").map(node => node.toObject()))}
    const map = L.map("map${id}").setView([lat, long], zoomLevel)
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
     attribution: '<a href="https://www.openstreetmap.org/">OpenStreetMap</a>',
     maxZoom: 18
    }).addTo(map)
    points.forEach(point => {
     L.marker([point.lat, point.long])
      .addTo(map)
      .bindPopup("<b>" +point.title + "</b><br />" + point.description)
    })
   }
  </script>`
  }
tableSearchParser
 cruxFromId
 extends abstractScrollWithRequirementsParser
 string requireOnce
  <script defer src="https://code.jquery.com/jquery-3.7.1.min.js"></script>
  <style>.dt-search{font-family: "SF Pro", "Helvetica Neue", "Segoe UI", "Arial";}</style>
  <link rel="stylesheet" href="https://cdn.datatables.net/2.0.5/css/dataTables.dataTables.min.css" />
    <script defer src="https://cdn.datatables.net/2.0.5/js/dataTables.min.js"></script>
    <script>
     document.addEventListener("DOMContentLoaded", function () {
      const urlSearchParams = new URLSearchParams(window.location.search)
      const params = Object.fromEntries(urlSearchParams.entries())
      jQuery('table').DataTable({"order": [],"paging": false,search:{ search: params.filter || ""}});
    } );
    </script>
 description Add table search to all tables on the page.
 javascript
  compileInstance() {
   return ""
  }
belowAsCodeParser
 description Print the Scroll code of the next node.
 extends abstractScrollParser
 catchAllCellType integerCell
 cruxFromId
 javascript
  method = "next"
  get code() {
   const { method } = this
   let code = ""
   let howMany = parseInt(this.getWord(1))
   if (!howMany || isNaN(howMany)) howMany = 1
   let nodes = []
   let next = this[method]
   while (howMany) {
    nodes.push(next)
    next = next[method]
    howMany--
   }
   if (this.reverse) nodes.reverse()
   return nodes.map(node => node.asString).join("\n")
  }
  reverse = false
  compile() {
   return `<code class="scrollCodeBlock">${this.code.replace(/\</g, "&lt;")}</code>`
  }
aboveAsCodeParser
 description Print the Scroll code for the previous node.
 extends belowAsCodeParser
 javascript
  method = "previous"
  reverse = true
abstractCommentParser
 description Comments do not appear in the compiled HTML.
 catchAllCellType commentCell
 cells commentCell
 extends abstractScrollParser
 javascript
  compile() {
   return ``
  }
 catchAllParser commentLineParser
commentParser
 extends abstractCommentParser
 cruxFromId
slashCommentParser
 extends commentParser
 crux //
counterpointParser
 description A counterpoint. Will not show up in the compiled HTML.
 extends commentParser
 crux !
thanksToParser
 description A place to store data on reviewers who helped improve a post (and a reminder to seek feedback!). Does not appear in compiled HTML.
 extends abstractCommentParser
 cruxFromId
conceptStartParser
 crux ::
 description Begins a concept.
 extends abstractCommentParser
 javascript
  compile() {
   return `<hr>`
  }
measurementParser
 description Add a measurement to a concept. Also used for defining measures.
 cells measureNameCell
 pattern ^[a-zA-Z0-9_]+:( |$)
 catchAllCellType valueCell
 extends abstractCommentParser
 javascript
  compile() {
   return `<div>${Utils.linkify(this.getLine())}</div>`
  }
 example
  ::
  id: earth
  order: 3
printDatasetParser
 description Print the dataset in a page into an HTML table.
 cruxFromId
 extends abstractCommentParser
 javascript
   compile() {
   // A hacky but simple way to do this for now.
   const node = this.appendSibling("table \t", this.parent.file.makeDataset("tsv"))
   const html = node.compile()
   node.destroy()
   return html
   }
writeDatasetParser
 cruxFromId
 description Write a dataset file to disk.
 extends abstractCommentParser
byLineParser
 description Prints a byline with the author's name and optionally a link to them.
 extends abstractScrollParser
 cruxFromId
 cells keywordCell urlCell
 catchAllCellType personNameCell
 example
  // With Link:
  byLine https://breckyunits.com Breck Yunits
  // No link:
  byLine  Breck Yunits
 javascript
  compile() {
   const link = this.getWord(1)
   return `<div class="scrollByLine">by <a ${link ? `href="${link}"` : ""}>${this.getWordsFrom(2).join(" ")}</a></div>`
  }
authorParser
 extends byLineParser
cssParser
 extends abstractScrollParser
 description Prints CSS content wrapped in a style tag.
 cruxFromId
 catchAllParser cssLineParser
 catchAllCellType cssAnyCell
 javascript
  compile() {
   return `<style>${this.content ?? ""}${this.childrenToString()}</style>`
  }
printFeedParser
 description Prints out the RSS feed for a group.
 extends abstractScrollParser
 cruxFromId
 cells keywordCell groupNameWithOptionalFolderCell
 catchAllCellType groupNameWithOptionalFolderCell
 example
  printFeed index
  printFeed cars/index
  permalink feed.xml
 javascript
  compile() {
   const dayjs = require("dayjs")
   const file = this.root.file
   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1)).map(file => file.file)
   const { title, baseUrl, description } = file
   return `<?xml version="1.0" encoding="ISO-8859-1" ?>
  <rss version="2.0">
  <channel>
   <title>${title}</title>
   <link>${baseUrl}</link>
   <description>${description}</description>
   <lastBuildDate>${dayjs().format("ddd, DD MMM YYYY HH:mm:ss ZZ")}</lastBuildDate>
   <language>en-us</language>
  ${files.map(file => file.toRss()).join("\n")}
  </channel>
  </rss>`
  }
printCsvParser
 description Prints out a group as a CSV.
 extends printFeedParser
 example
  printCsv index
  permalink posts.csv
 javascript
  compile() {
   const file = this.root.file
   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1)).map(file => file.file)
   const header = file.csvFields
   return `${header.join(",")}\n${files.map(file => file.toCsv()).join("\n")}`
  }
printSourceParser
 description Prints out the source code for each file in a group.
 extends printFeedParser
 example
  printSource index
  permalink source.txt
 javascript
  compile() {
   const file = this.root.file
   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1)).map(file => file.file)
   return `${files.map(file => file.filePath + "\n " + file.originalScrollCode.replace(/\n/g, "\n ") ).join("\n")}`
  }
dashboardParser
 description Display key stats in a big font.
 catchAllParser rowParser
 cruxFromId
 extends abstractScrollParser
 example
  dashboard
   #2 Popularity
   30 Years Old
   $456 Revenue
 javascript
  get tableBody() {
   const items = this.topDownArray
   let str = ""
   for (let i = 0; i < items.length; i = i + 3) {
    str += this.makeRow(items.slice(i, i + 3))
   }
   return str
  }
  makeRow(items) {
   return `<tr>` + items.map(node => `<td>${node.firstWord}<span>${node.content}</span></td>`).join("\n") + `</tr>\n`
  }
  compile() {
   return `<table class="scrollDashboard">${this.tableBody}</table>`
  }
abstractTopLevelSingleMetaParser
 description Use these keywords once per file.
 extends abstractScrollParser
 cruxFromId
 cells keywordCell
 javascript
  compile() {
   return ""
  }
dateParser
 catchAllCellType dateCell
 description Date this file was first published.
 extends abstractTopLevelSingleMetaParser
permalinkParser
 description When compiling, Scroll will save this file to {permalink}
 extends abstractTopLevelSingleMetaParser
 cells keywordCell permalinkCell
abstractThemeCssParser
 description Extend this to create a Scroll CSS theme.
 extends abstractTopLevelSingleMetaParser
 inScope tagsParser
 cruxFromId
 catchAllCellType stringCell
 string scrollStyles
  figure
   margin 0
   padding 0
  .dropcap:first-letter
   font-size 3rem
   line-height .9em
   margin-right .125rem
   display block
   float left
  .dinkus
   text-align center
   padding 1rem
   span
    vertical-align sub
  .scrollCaptionedFigure
   display block
   text-align center
   img
    max-width 100%
    height auto
    margin-top .1875rem
   figcaption
    font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"
    font-size .8rem
    .scrollParagraph
     margin-top 0
  .scrollCodeBlock
   overflow auto
   font-size .8rem
   hyphens none
   white-space pre
   break-inside avoid
   display block
   margin .5rem 0
   padding .5rem
   border-radius 0
   position relative
  .scrollCodeBlock:hover
   .scrollCopyButton
    opacity .5
   .scrollCopyButton:hover
    opacity .8
   .scrollCopyButton:active
    opacity 1
  .scrollCopyButton
   position absolute
   top .125rem
   right .125rem
   font-size .875rem
   cursor pointer
   opacity 0
  .scrollCopyButton::after
   content "[ ]"
  .scrollCopiedButton::after
   content "[✓]"
 javascript
  get useTags() {
    return !(this.get("tags") === "false")
  }
  compile() {
   return this.useTags ? `<style>${this.css}</style>` : this.css
  }
  compileEmbeddedVersion() {
   return ""
  }
  get scrollCss() {
    const hakonParser = this.root.hakonParser
    return new hakonParser(this.scrollStyles).compile()
  }
gazetteCssParser
 description The default Scroll theme.
 extends abstractThemeCssParser
 javascript
  get css() {
    if (this.constructor._cachedCss)
      return this.constructor._cachedCss
    const hakonParser = this.root.hakonParser
    this.constructor._cachedCss = this.scrollCss + new hakonParser([this.hakonReset, this.hakonStandardStyles].join("\n")).compile()
    return this.constructor._cachedCss
  }
 // CSS Reset
 string hakonReset
  html,body,div,span,p,ol,ul,li,table,figure
   margin 0
   padding 0
   border 0
   vertical-align baseline
   border-spacing 0
  ol,ul
   padding-left 1rem
  li
   margin-top .4rem
   line-height 1.4
  a
   text-decoration-color transparent
  a:hover
   text-decoration-color initial
  sup,sub
   vertical-align baseline
   position relative
   top -.375rem
  sub
   top .375rem
  html
   padding .25rem
   background-color rgb(244,244,244)
   font-family Exchange,Georgia,serif
   color #000
   font-size var(--base-font-size, 16px)
   hyphens auto
  p
   margin-top .4rem
   line-height 1.4rem
  .scrollQuote
   break-inside avoid
   display block
   margin .5rem 0
   padding .5rem
   background rgba(204,204,204,.5)
   white-space pre-line
   border-left .5rem solid rgba(204,204,204,.8)
  code
   font-size .9rem
   background-color rgba(204,204,204,.5)
   padding .125rem .25rem
   border-radius .25rem
 // Styles for Scroll standard tags
 string hakonStandardStyles
  comment Main body of both pages is similar
  .scrollParagraph
   text-align justify
  .scrollColumns
   column-count auto
   column-fill balance
   column-width 35ch
   column-gap 1.5rem
   padding-left 1.25rem
   padding-right 1.25rem
   margin auto
  comment On group pages add some spacing around files
  .scrollSnippetContainer
   padding 1ch 0
   break-inside avoid
   text-align justify
  h1,h2,h3,h4
   margin .625rem 0
  h1
   font-size 1.25rem
  h2
   font-size 1.125rem
  h3,h4
   font-size 1rem
  h1.scrollTitle
   text-align center
   margin-bottom .15625rem
   margin-top 0
   font-size 1.75rem
   a
    color #000
  .scrollDateline
   font-style italic
   line-height 1.4rem
   comment Decrease font size to deemphasize dateline but keep the line height the same to not cause different line spacing.
   font-size .75rem
  .scrollSection
   break-inside avoid
   h1,h2,h3,h4
    text-align center
  h4.scrollQuestion
   text-align left
   margin 1.4rem 0 0 0
  .scrollSection:first-child
   h1,h2,h3,h4
    margin-top 0
   h4.scrollQuestion
    margin-top 0
  .scrollNoteLink
   opacity .4
   text-decoration none
   &:hover
    opacity 1
  .scrollFootNoteUsageLink
   opacity .7
   text-decoration none
   &:hover
    opacity 1
  
  .scrollHoverNote
   text-decoration underline dashed 1px rgba(0,0,0,.1)
   cursor default
  
  .scrollCodeBlock
   border-left .5rem solid rgba(204,204,204,.8)
  
  .scrollTable
   table-layout fixed
   font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"
   margin .5rem 0
   overflow hidden
   font-size .8rem
   width 100%
   hyphens none
   border 1px solid rgba(224,224,224,.8)
   td,th
    padding .1875rem
    overflow hidden
    white-space nowrap
   th
    text-transform capitalize
   th
    border-bottom 2px solid rgba(0,0,0,.6)
    text-align left
   tr:nth-child(even)
    background rgba(224,224,224,.6)
  
  .scrollByLine
   font-size .875rem
   font-style italic
   margin .25rem 0
   text-align center
  
  comment Subtle "Article Source" link
  .scrollViewSource
   text-align center
   font-size .8rem
   margin 0
   margin-top .4rem
   line-height 1.4rem
   margin-bottom 1rem
   a
    color #000
  
  .scrollContinueReadingLink
   display block
   text-align center
  
  .scrollDashboard
   width 100%
   font-size 1.875rem
   text-align center
   font-weight bold
   break-inside avoid
   margin-top .5rem
   margin-bottom .5rem
   td
    width 33.3%
    border 1px solid #e8e8e8
   span
    font-size 1.25rem
    display block
  .scrollChat
   span
    font-family Verdana
    margin-top .3125rem
    padding .3125rem 1.25rem
    border-radius .9375rem
    display inline-block
  .scrollChatLeft
   span
    background rgba(204,204,204, .5)
  .scrollChatRight
   span
    color white
    background rgb(0,132,255)
  .scrollYouTubeHolder
   position relative
   width 100%
   height 0
   padding-bottom 56.25%
  .scrollYouTubeEmbed
   position absolute
   top 0
   left 0
   width 100%
   height 100%
tufteCssParser
 description A theme built using Tufte CSS. https://github.com/edwardtufte/tufte-css
 extends abstractThemeCssParser
 javascript
  get css() {
    return this.scrollCss + this.tufteCss
  }
  tufteCss = `html {
     font-size: 15px;
  }
   body {
       width: 87.5%;
       margin-left: auto;
       margin-right: auto;
       padding-left: 12.5%;
       font-family: Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
       background-color: #fffff8;
       color: #111;
       max-width: 1400px;
       counter-reset: sidenote-counter;
  }
  /* Adds dark mode */
   @media (prefers-color-scheme: dark) {
       body {
           background-color: #151515;
           color: #ddd;
      }
  }
   h1 {
       font-weight: 400;
       margin-top: 3rem;
       margin-bottom: 1.5rem;
       font-size: 2.4rem;
       line-height: 1;
  }
  .scrollTitle a { text-decoration: none; font-size: 3.2rem;}
  .scrollParagraph { text-align: justify; hyphens: auto;}
  a.scrollNoteLink { text-decoration: none;}
   h2 {
       font-style: italic;
       font-weight: 400;
       margin-top: 2.1rem;
       margin-bottom: 1.4rem;
       font-size: 2.2rem;
       line-height: 1;
  }
   h3 {
       font-style: italic;
       font-weight: 400;
       font-size: 1.7rem;
       margin-top: 2rem;
       margin-bottom: 1.4rem;
       line-height: 1;
  }
   hr {
       display: block;
       height: 1px;
       width: 55%;
       border: 0;
       border-top: 1px solid #ccc;
       margin: 1em 0;
       padding: 0;
  }
   p.subtitle {
       font-style: italic;
       margin-top: 1rem;
       margin-bottom: 1rem;
       font-size: 1.8rem;
       display: block;
       line-height: 1;
  }
   .numeral {
       font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }
   .danger {
       color: red;
  }
   article {
       padding: 5rem 0rem;
  }
   section {
       padding-top: 1rem;
       padding-bottom: 1rem;
  }
   p, dl, ol, ul {
       font-size: 1.4rem;
       line-height: 2rem;
  }
   p {
       margin-top: 1.4rem;
       margin-bottom: 1.4rem;
       padding-right: 0;
       vertical-align: baseline;
  }
  /* Chapter Epigraphs */
   div.epigraph {
       margin: 5em 0;
  }
   div.epigraph > blockquote {
       margin-top: 3em;
       margin-bottom: 3em;
  }
   div.epigraph > blockquote, div.epigraph > blockquote > p {
       font-style: italic;
  }
   div.epigraph > blockquote > footer {
       font-style: normal;
  }
   div.epigraph > blockquote > footer > cite {
       font-style: italic;
  }
  /* end chapter epigraphs styles */
   blockquote {
       font-size: 1.4rem;
  }
   blockquote p {
       width: 55%;
       margin-right: 40px;
  }
   blockquote footer {
       width: 55%;
       font-size: 1.1rem;
       text-align: right;
  }
   section > p, section > footer, section > table {
       width: 55%;
  }
  /* 50 + 5 == 55, to be the same width as paragraph */
   section > dl, section > ol, section > ul {
       width: 50%;
       -webkit-padding-start: 5%;
  }
   dt:not(:first-child), li:not(:first-child) {
       margin-top: 0.25rem;
  }
  /* Links: replicate underline that clears descenders */
   a:link, a:visited {
       color: inherit;
  }
  /* Sidenotes, margin notes, figures, captions */
   img {
       max-width: 100%;
  }
   .sidenote, .marginnote {
       float: right;
       clear: right;
       margin-right: -60%;
       width: 50%;
       margin-top: 0.3rem;
       margin-bottom: 0;
       font-size: 1.1rem;
       line-height: 1.3;
       vertical-align: baseline;
       position: relative;
  }
   .sidenote-number {
       counter-increment: sidenote-counter;
  }
   .sidenote-number:after, .sidenote:before {
       font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
       position: relative;
       vertical-align: baseline;
  }
   .sidenote-number:after {
       content: counter(sidenote-counter);
       font-size: 1rem;
       top: -0.5rem;
       left: 0.1rem;
  }
   .sidenote:before {
       content: counter(sidenote-counter) " ";
       font-size: 1rem;
       top: -0.5rem;
  }
   blockquote .sidenote, blockquote .marginnote {
       margin-right: -82%;
       min-width: 59%;
       text-align: left;
  }
   div.fullwidth, table.fullwidth {
       width: 100%;
  }
   div.table-wrapper {
       overflow-x: auto;
       font-family: "Trebuchet MS", "Gill Sans", "Gill Sans MT", sans-serif;
  }
   .sans {
       font-family: "Gill Sans", "Gill Sans MT", Calibri, sans-serif;
       letter-spacing: 0.03em;
  }
   code, pre > code {
       font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
       font-size: 1rem;
       line-height: 1.42;
       -webkit-text-size-adjust: 100%;
      /* Prevent adjustments of font size after orientation changes in iOS. See https://github.com/edwardtufte/tufte-css/issues/81#issuecomment-261953409 */
  }
   .sans > code {
       font-size: 1.2rem;
  }
   h1 > code, h2 > code, h3 > code {
       font-size: 0.8em;
  }
   .marginnote > code, .sidenote > code {
       font-size: 1rem;
  }
   pre > code {
       font-size: 0.9rem;
       width: 52.5%;
       margin-left: 2.5%;
       overflow-x: auto;
       display: block;
  }
   pre.fullwidth > code {
       width: 90%;
  }
   .fullwidth {
       max-width: 90%;
       clear: both;
  }
   span.newthought {
       font-variant: small-caps;
       font-size: 1.2em;
  }
   input.margin-toggle {
       display: none;
  }
   label.sidenote-number {
       display: inline-block;
       max-height: 2rem;
      /* should be less than or equal to paragraph line-height */
  }
   label.margin-toggle:not(.sidenote-number) {
       display: none;
  }
   .iframe-wrapper {
       position: relative;
       padding-bottom: 56.25%;
      /* 16:9 */
       padding-top: 25px;
       height: 0;
  }
   .iframe-wrapper iframe {
       position: absolute;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
  }
   @media (max-width: 760px) {
       body {
           width: 84%;
           padding-left: 8%;
           padding-right: 8%;
      }
       hr, section > p, section > footer, section > table {
           width: 100%;
      }
       pre > code {
           width: 97%;
      }
       section > dl, section > ol, section > ul {
           width: 90%;
      }
       blockquote {
           margin-left: 1.5em;
           margin-right: 0em;
      }
       blockquote p, blockquote footer {
           width: 100%;
      }
       label.margin-toggle:not(.sidenote-number) {
           display: inline;
      }
       .sidenote, .marginnote {
           display: none;
      }
       .margin-toggle:checked + .sidenote, .margin-toggle:checked + .marginnote {
           display: block;
           float: left;
           left: 1rem;
           clear: both;
           width: 95%;
           margin: 1rem 2.5%;
           vertical-align: baseline;
           position: relative;
      }
       label {
           cursor: pointer;
      }
       div.table-wrapper, table {
           width: 85%;
      }
       img {
           width: 100%;
      }
  }`
groupsParser
 description Add this file to zero or more groups.
 cruxFromId
 example
  groups index.html
 extends abstractTopLevelSingleMetaParser
 cells keywordCell
 catchAllCellType groupNameCell
metaTagsParser
 cruxFromId
 extends abstractTopLevelSingleMetaParser
 description Adds meta tags like title, description, et cetera.
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const { file } = this.parent
   const { title, description, openGraphImage, SCROLL_VERSION, canonicalLink } = file
   const rssFeedUrl = file.get("rssFeedUrl")
   let rssTag = ""
   if (rssFeedUrl) {
    rssTag = `link
   rel alternate
   type application/rss+xml
   title ${title}
   href ${rssFeedUrl}`
   }
   return file.compileStumpCode(`meta
   charset utf-8
  titleTag ${title}
  script /* This HTML was generated by 📜 Scroll v${SCROLL_VERSION}. http://scroll.pub */
  styleTag @media print {.doNotPrint {display: none !important;}}
  link
   rel canonical
   href ${canonicalLink}
  meta
   charset iso-8859-1
  meta
   name viewport
   content width=device-width,initial-scale=1
  meta
   name description
   content ${description}
  meta
   name generator
   content Scroll v${SCROLL_VERSION}
  meta
   property og:title
   content ${title}
  meta
   property og:description
   content ${description}
  meta
   property og:image
   content ${openGraphImage}
  ${rssTag}
  meta
   name twitter:card
   content summary_large_image`)
  }
htmlLangParser
 cells keywordCell stringCell
 description The lang attribute for the <html lang=""> tag. If not specified will be "en". See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang
 extends abstractTopLevelSingleMetaParser
descriptionParser
 catchAllCellType stringCell
 description Description for Open Graph. https://ogp.me/. If not defined, Scroll will try to generate it's own.
 extends abstractTopLevelSingleMetaParser
pageFooterParser
 cruxFromId
 description A footer for your page.
 extends abstractTopLevelSingleMetaParser
 string hakon
  .pageFooter
   margin-top 8px
   padding-top 8px
   text-align center
   svg
    width 30px
    height 30px
    fill rgba(204,204,204, .5)
    padding 0 7px
    &:hover
     fill #333
  .pageFooterScrollLink
   display block
   font-family Verdana
   font-weight 100
   margin .5em
   color rgba(204,204,204,.5)
   &:hover
    color #333
    text-decoration none
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  get css() {
    const hakonParser = this.root.hakonParser
    return new hakonParser(this.hakon).compile()
  }
  compile() {
   const file = this.parent.file
   const { SVGS, SCROLL_VERSION, viewSourceUrl } = file
   const closeContainerTag = "</div>"
   return (
    closeContainerTag + `<style>${this.css}</style>` +
    file.compileStumpCode(`p
   class scrollViewSource doNotPrint
   a View source
    href ${viewSourceUrl}
  div
   class pageFooter doNotPrint
   a ${SVGS.email}
    href mailto:${file.email}
   a ${SVGS.git}
    href ${file.git}
   a Built with Scroll v${SCROLL_VERSION}
    href https://scroll.pub
    class pageFooterScrollLink
    style display:block; margin: .5em;`)
   )
  }
gazetteFooterParser
 extends pageFooterParser
 description DEPRECATED! Use "pageFooter" instead.
pageHeaderParser
 cruxFromId
 description A header for your page.
 extends abstractTopLevelSingleMetaParser
 string hakon
  .pageHeader
   position absolute
   top .25rem
   right 0
   left 0
   svg
    width 1.875rem
    height 1.875rem
    fill rgba(204,204,204,.8)
    &:hover
     fill #333
   a
    color rgba(204,204,204,.8)
    position absolute
    font-size 1.875rem
    line-height 1.7rem
    text-decoration none
    &:hover
     color #333
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  get css() {
    const hakonParser = this.root.hakonParser
    return new hakonParser(this.hakon).compile()
  }
  compile() {
   const file = this.parent.file
   const { SVGS, linkToPrevious, linkToNext } = file
   let previousButton = ""
   if (linkToPrevious)
    previousButton = `a <
    style left:.1875rem;
    href ${linkToPrevious}`
   let nextButton = ""
   if (linkToNext)
    nextButton = `a >
    style right:.1875rem;
    href ${linkToNext}`
   return `<style>${this.css}</style>` + file.compileStumpCode(`div
   class pageHeader doNotPrint
   ${previousButton}
   a ${SVGS.home}
    style text-align:left;left:1.5625rem;
    href ${file.get("homeLink") || "index.html"}
   a ${SVGS.git}
    style text-align:right;right: 1.5625rem;
    href ${file.git}
   ${nextButton}`)
  }
gazetteHeaderParser
 extends pageHeaderParser
 description DEPRECATED! Use "pageHeader" instead.
endSnippetParser
 description Insert one of these where you want to cut the file for a snippet.
 extends abstractTopLevelSingleMetaParser
viewSourceUrlParser
 catchAllCellType urlCell
 description Use this to override the link to the source code for a scroll file.
 extends abstractTopLevelSingleMetaParser
abstractFileSettingParser
 extends abstractScrollParser
 cells keywordCell
 javascript
  compile() {
   return ""
  }
abstractUrlSettingParser
 extends abstractFileSettingParser
 cells keywordCell urlCell
 cruxFromId
baseUrlParser
 description Root url of this published site on the web. Must be provided for RSS Feeds and OpenGraph tags to work, but has no effect locally.
 extends abstractUrlSettingParser
homeLinkParser
 description In the default Scroll theme the home button will link to "index.html". You can override this with this setting.
 extends abstractUrlSettingParser
viewSourceBaseUrlParser
 description The base link to be used to generate the "View source" link.
 extends abstractUrlSettingParser
gitParser
 description A link to the web Git UI for this site.
 extends abstractUrlSettingParser
canonicalLinkParser
 description Canonical URL for SEO. If undefined Scroll generates this from the baseUrl and permalink.
 extends abstractUrlSettingParser
openGraphImageParser
 description URL for Open Graph Image. https://ogp.me/. If not defined, Scroll will try to generate it's own using the first image tag on your page.
 extends abstractUrlSettingParser
rssFeedUrlParser
 description URL for RSS feed, if any.
 extends abstractUrlSettingParser
abstractSiteStringSettingParser
 extends abstractFileSettingParser
 catchAllCellType stringCell
 cruxFromId
emailParser
 description Email address for the site owner.
 extends abstractFileSettingParser
 cruxFromId
 cells keywordCell emailAddressCell
scrollParserDefinitionParser
 extends abstractScrollParser
 // todo Figure out best pattern for integrating Scroll and Grammar?
 pattern ^[a-zA-Z0-9_]+Parser$
 description Define your own parsers in the Grammar language for using in your Scroll files.
 baseParser blobParser
 javascript
  compile() {
   return ""
  }
htmlParser
 description A catch all block to drop in any loose html. Use for HTML one liners and/or blocks of HTML.
 cruxFromId
 extends abstractScrollParser
 catchAllParser htmlLineParser
 catchAllCellType htmlAnyCell
 javascript
  compile() {
   return `${this.content ?? ""}${this.childrenToString()}`
  }
quickHtmlParser
 extends htmlParser
 cells htmlAnyCell
 pattern ^<
 description Start a line with a less than sign to immediately write HTML
 javascript
  compile() {
   return `${this.getLine() ?? ""}${this.childrenToString()}`
  }
stumpParser
 cruxFromId
 extends abstractScrollParser
 description Stump is a Tree Language that compiles to HTML.
 catchAllParser stumpContentParser
 javascript
  compile() {
   const file = this.parent.file
   return file.compileStumpCode(this.childrenToString())
  }
stumpNoSnippetParser
 extends stumpParser
 description Useful for headers and footers when you have something you don't want included in snippets.
 cruxFromId
 javascript
  compileEmbeddedVersion() {
   return ""
  }
abstractCaptionedParser
 extends abstractScrollParser
 cells keywordCell urlCell
 inScope captionAftertextParser slashCommentParser
 cruxFromId
 javascript
  compile(compileSettings) {
   const caption = this.getNode("caption")
   const captionFig = caption ? `<figcaption>${caption.compile()}</figcaption>` : ""
   return `<figure class="scrollCaptionedFigure">${this.getFigureContent(compileSettings)}${captionFig}</figure>`
  }
imageParser
 description An img tag.
 extends abstractCaptionedParser
 inScope classMarkupParser aftertextIdParser
 javascript
  getFigureContent(compileSettings) {
   const file = this.root.file
   const src = this.getWord(1)
   const linkRelativeToCompileTarget = (compileSettings ? (compileSettings.relativePath ?? "") : "") + src
   let dimensionAttributes = ""
   // If its a local image, get the dimensions and put them in the HTML
   // to avoid flicker
   if (!src.startsWith("http:") && !src.startsWith("https:")) {
    try {
     const sizeOf = require("image-size")
     const path = require("path")
     const fullImagePath = path.join(file.folderPath, src)
     const dimensions = sizeOf(fullImagePath)
     const width = dimensions.width
     const height = dimensions.height
     dimensionAttributes = `width="${width}" height="${height}" `
    } catch (err) {
     console.error(err)
    }
   }
   const className = this.has("class") ? ` class="${this.get("class")}" ` : ""
   const id = this.has("id") ? ` id="${this.get("id")}" ` : ""
   return `<a href="${linkRelativeToCompileTarget}" target="_blank" ${className} ${id}><img src="${linkRelativeToCompileTarget}" ${dimensionAttributes}loading="lazy"></a>`
  }
youTubeParser
 extends abstractCaptionedParser
 description Embed a YouTube video. Include the YouTube embed URL such as https://www.youtube.com/embed/CYPYZnVQoLg
 javascript
  getFigureContent() {
   const url = this.getWord(1).replace("youtube.com/watch?v=", "youtube.com/embed/")
   return `<div class="scrollYouTubeHolder"><iframe class="scrollYouTubeEmbed" src="${url}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>`
  }
importParser
 description Import one file into another.
 cruxFromId
 extends abstractScrollParser
 catchAllCellType filePathCell
 javascript
  compile() {
   return ""
  }
 example
  import header.scroll
importOnlyParser
 description Mark a file as not one to build. This line will be not be imported into the importing file.
 cruxFromId
 extends abstractScrollParser
 javascript
  compile() {
   return ""
  }
keyboardNavParser
 description Makes left go to previous file and right go to next file.
 extends abstractScrollParser
 cruxFromId
 catchAllCellType urlCell
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const file = this.root.file
   const linkToPrevious = this.getWord(1) ?? file.linkToPrevious
   const linkToNext = this.getWord(2) ?? file.linkToNext
   const script = `<script>document.addEventListener('keydown', function(event) {
    if (document.activeElement !== document.body) return
    const getLinks = () => document.getElementsByClassName("scrollKeyboardNav")[0].getElementsByTagName("a")
    if (event.key === "ArrowLeft")
      getLinks()[0].click()
    else if (event.key === "ArrowRight")
      getLinks()[1].click()
   });</script>`
   return `<div class="scrollKeyboardNav" style="display:none;"><a href="${linkToPrevious}">${linkToPrevious}</a> · ${file.permalink} · <a href="${linkToNext}">${linkToNext}</a>${script}</div>`
  }
plainTextParser
 description Use for plain text one liners and/or blocks of plain text.
 cruxFromId
 extends abstractScrollParser
 catchAllParser plainTextLineParser
 catchAllCellType stringCell
 javascript
  compile() {
   return `${this.content ?? ""}${this.childrenToString()}`
  }
quoteParser
 cruxFromId
 description A blockquote.
 catchAllParser quoteLineParser
 extends abstractScrollParser
 javascript
  compile() {
   return `<blockquote class="scrollQuote">${this.childrenToString()}</blockquote>`
  }
readingListParser
 extends abstractScrollParser
 description Easily create a reading list with links, titles, and author names.
 cells keywordCell
 cruxFromId
 catchAllParser readingListItemParser
 example
  readingList
   https://example.com/similar by Author Name
 javascript
  compile() {
   return `<br><ul>${this.map(child => child.compile()).join("\n")}</ul>`
  }
redirectToParser
 description Prints an HTML redirect tag. In the future might also emit nginx config.
 extends abstractScrollParser
 cells keywordCell urlCell
 cruxFromId
 example
  redirectTo https://scroll.pub/releaseNotes.html
 javascript
  compile() {
   return `<meta http-equiv="Refresh" content="0; url='${this.getWord(1)}'" />`
  }
replaceParser
 description Define a variable token and replacement that will be applied to all lines before and after this one.
 extends abstractScrollParser
 cruxFromId
 catchAllCellType stringCell
 baseParser blobParser
 example
  replace YEAR 2022
 javascript
  compile() {
   return ""
  }
replaceJsParser
 description Define a variable token and replacement that will be applied to all lines before and after this one.
 extends replaceParser
 catchAllCellType javascriptCell
 example
  replaceJs SUM 1+1
  * 1+1 = SUM
nodejsParser
 description Write nodejs code inside a Scroll file. Sort of like PHP.
 extends abstractScrollParser
 cruxFromId
 catchAllCellType javascriptCell
 baseParser blobParser
 example
  nodejs
   module.exports = {SCORE : 1 + 2}
  * The score is SCORE
replaceDefaultParser
 description Define the default value for a replacement. Useful if you want to import a file and set a replacement later.
 extends abstractScrollParser
 catchAllCellType stringCell
 baseParser blobParser
 example
  replaceDefault YEAR 2021
 cruxFromId
 javascript
  compile() {
   return ""
  }
abstractTableParser
 cruxFromId
 catchAllParser rowParser
 extends abstractScrollParser
 javascript
  get tableHeader() {
   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\n`)
  }
  get columnNames() {
   const header = this.nodeAt(0)
   return header ? header.getLine().split(this.delimiter) : []
  }
  get columns() {
   const cols = this.columnNames
   return cols.map((name, index) => {
    const isLink = name.endsWith("Link")
    const linkIndex = cols.indexOf(name + "Link")
    return {
     name,
     isLink,
     linkIndex
    }
   })
  }
  get tableBody() {
   const { delimiter } = this
   return this.topDownArray
    .slice(1)
    .map(node => `<tr>${node.toRow(this.columns, delimiter)}</tr>`)
    .join("\n")
  }
  compile() {
   return `<table class="scrollTable"><thead><tr>${this.tableHeader.join("\n")}</tr></thead>\n<tbody>${this.tableBody}</tbody></table>`
  }
tableParser
 description A table with a custom delimiter.
 extends abstractTableParser
 catchAllCellType anyCell
 javascript
  get delimiter() {
   return this.content ?? ""
  }
commaTableParser
 description Comma separated values table.
 extends abstractTableParser
 string delimiter ,
pipeTableParser
 description Pipe separated values table.
 extends abstractTableParser
 string delimiter |
spaceTableParser
 description Space separated values table. Last column is a catch all.
 extends abstractTableParser
 string delimiter  
tabTableParser
 description Tab separated values table.
 extends abstractTableParser
 string delimiter \t
treeTableParser
 description A table of data written in Tree Notation form. Useful when a column contains a text blob.
 extends abstractTableParser
 catchAllParser treeRowParser
 javascript
  get columnNames() {
   return this._getUnionNames()
  }
  get tableBody() {
   return this.map(node => `<tr>${node.toRow(this.columns)}</tr>`).join("\n")
  }
 example
  treeTable
   row
    name Javascript
    example
     console.log("Hello world")
   row
    name Python
    example
     print "Hello world"
abstractAftertextAttributeParser
 cells keywordCell
 boolean isAttribute true
 javascript
  get divAttributes() {
   return `${this.firstWord}="${this.content}"`
  }
  compile() {
   return ""
  }
aftertextIdParser
 crux id
 description Provide an ID to be output in the generated HTML tag.
 extends abstractAftertextAttributeParser
 cells keywordCell htmlIdCell
 single
aftertextStyleParser
 crux style
 description Provide code for the generated HTML tag's "style" attribute.
 extends abstractAftertextAttributeParser
 cells keywordCell
 catchAllCellType cssAnyCell
aftertextHiddenParser
 crux hidden
 cells keywordCell
 description Do not compile this node to HTML.
 extends abstractAftertextAttributeParser
 single
aftertextTagParser
 cells keywordCell htmlTagCell
 description Override the HTML tag that the compiled node will use.
 crux tag
 javascript
  compile() {
   return ""
  }
abstractAftertextDirectiveParser
 cells keywordCell
 catchAllCellType stringCell
 javascript
  isMarkup = true
  compile() {
   return ""
  }
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get shouldMatchAll() {
   return this.has("matchAll")
  }
  getMatches(text) {
   const { pattern } = this
   const escapedPattern = pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   return [...text.matchAll(new RegExp(escapedPattern, "g"))].map(match => {
    const { index } = match
    const endIndex = index + pattern.length
    return [
     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },
     { index: endIndex, endIndex, string: `</${this.closeTag}>` }
    ]
   })
  }
  getInserts(text) {
   const matches = this.getMatches(text)
   if (!matches.length) return false
   if (this.shouldMatchAll) return matches.flat()
   const match = this.getNode("match")
   if (match)
    return match.indexes
     .map(index => matches[index])
     .filter(i => i)
     .flat()
   return matches[0]
  }
  get allAttributes() {
   const attr = this.attributes.join(" ")
   return attr ? " " + attr : ""
  }
  get attributes() {
   return []
  }
  get openTag() {
   return this.tag
  }
  get closeTag() {
   return this.tag
  }
abstractMarkupParser
 extends abstractAftertextDirectiveParser
 inScope abstractMarkupParameterParser
boldParser
 cruxFromId
 description Bold the matching text.
 extends abstractMarkupParser
 javascript
  tag = "b"
italicsParser
 cruxFromId
 description Italicize the matching text.
 extends abstractMarkupParser
 javascript
  tag = "i"
underlineParser
 description Underline the matching text.
 cruxFromId
 extends abstractMarkupParser
 javascript
  tag = "u"
aftertextCodeParser
 description Wrap the matching text in a <code> span.
 crux code
 extends abstractMarkupParser
 javascript
  tag = "code"
classMarkupParser
 description Add a custom class to the parent element instead. If matching text provided, a span with the class will be added around the matching text.
 extends abstractMarkupParser
 cells keywordCell classNameCell
 crux class
 javascript
  tag = "span"
  get applyToParentElement() {
   return this.words.length === 2
  }
  getInserts(text) {
   // If no select text is added, set the class on the parent element.
   if (this.applyToParentElement) return []
   return super.getInserts(text)
  }
  get className() {
   return this.getWord(1)
  }
  get attributes() {
   return [`class="${this.className}"`]
  }
  get pattern() {
   const words = this.getWordsFrom(2)
   return words.length ? words.join(" ") : this.parent.content
  }
hoverNoteParser
 description Add a caveat viewable on hover on matching text. When you want to be sure you've thoroughly addressed obvious concerns but ones that don't warrant to distract from the main argument of the text.
 cruxFromId
 extends classMarkupParser
 catchAllParser lineOfTextParser
 cells keywordCell
 javascript
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get attributes() {
   return [`class="scrollHoverNote"`, `title="${this.hoverNoteText}"`]
  }
  get hoverNoteText() {
   return this.childrenToString().replace(/\n/g, " ")
  }
strikethroughParser
 cruxFromId
 extends abstractMarkupParser
 javascript
  tag = "s"
linkParser
 extends abstractMarkupParser
 description Put the matching text in an <a> tag.
 cells keywordCell urlCell
 inScope linkTitleParser linkTargetParser commentParser
 programParser
  description Anything here will be URI encoded and then appended to the link.
  cruxFromId
  cells keywordCell
  catchAllParser programLinkParser
  javascript
   get encoded() {
    return encodeURIComponent(this.childrenToString())
   }
 cruxFromId
 javascript
  tag = "a"
  get link() {
   const {baseLink} = this
   if (this.has("program"))
     return baseLink + this.getNode("program").encoded
   return baseLink
  }
  get baseLink() {
   const link = this.getWord(1)
   const isAbsoluteLink = link.includes("://")
   if (isAbsoluteLink) return link
   const relativePath = this.parent.compileSettings?.relativePath || ""
   return relativePath + link
  }
  get attributes() {
   const attrs = [`href="${this.link}"`]
   const options = ["title", "target"]
   options.forEach(option => {
    const node = this.getNode(option)
    if (node) attrs.push(`${option}="${node.content}"`)
   })
   return attrs
  }
  patternStartsAtWord = 2
  get pattern() {
   // If no pattern is provided, apply to the *entire* content.
   const words = this.getWordsFrom(this.patternStartsAtWord)
   return words.length ? words.join(" ") : this.parent.originalText
  }
emailLinkParser
 description A mailto link
 crux email
 extends linkParser
 javascript
  get attributes() {
   return [`href="mailto:${this.link}"`]
  }
quickLinkParser
 pattern ^https?\:
 extends linkParser
 cells urlCell
 javascript
  get link() {
   return this.firstWord
  }
  patternStartsAtWord = 1
wrapsOnParser
 cruxFromId
 description Enable `code`, *bold*, and _italics_ rules.
 extends abstractAftertextDirectiveParser
 catchAllCellType wrapNameCell
 javascript
  get shouldMatchAll() {
   return true
  }
  get wraps() {
    const wraps = [{delimiter: "`", tag: "code", exclusive: true, name: "code"},{delimiter: "*", tag: "strong", name: "bold"}, {delimiter: "_", tag: "em", name: "italics"}]
    if (this.root.has("katex"))
      wraps.unshift({delimiter: "$", tag: "span", attributes: ' class="scrollKatex"', exclusive: true, name: "katex"})
    if (this.content)
      return wraps.filter(wrap => this.content.includes(wrap.name))
    return wraps
  }
  getMatches(text) {
   const exclusives = []
   return this.wraps.map(wrap => this.runPattern(text, wrap, exclusives)).filter(i => i).flat()
  }
  runPattern(text, wrap, exclusives = []) {
   const {delimiter, tag, attributes} = wrap
   const escapedDelimiter = delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, "g")
   const delimiterLength = delimiter.length
   return [...text.matchAll(pattern)].map(match => {
    const { index } = match
    const endIndex = index + match[0].length
    // I'm too lazy to clean up Grammar to write a proper inline markup parser so doing this for now.
    // The exclusive idea is to not try and apply bold or italic styles inside a TeX or code inline style.
    // Note that the way this is currently implemented any TeX in an inline code will get rendered, but code
    // inline of TeX will not. Seems like an okay tradeoff until a proper refactor and cleanup can be done.
    if (exclusives.some(exclusive => index >= exclusive[0] && index <= exclusive[1]))
      return undefined
    if (wrap.exclusive)
      exclusives.push([index, endIndex])
    return [
     { index, string: `<${tag + (attributes ? " " + attributes : "")}>`, endIndex, consumeStartCharacters: delimiterLength },
     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }
    ]
   }).filter(i => i)
  }
wrapParser
 cruxFromId
 cells keywordCell delimiterCell tagOrUrlCell
 catchAllCellType htmlAttributesCell
 extends wrapsOnParser
 description Define a custom wrap, for example "wrap _ em" would support: _italics_.
 javascript
  getMatches(text) {
   try {
    const delimiter = this.getWord(1)
    const tag = this.getWord(2)
    const attributes = this.getWordsFrom(3).join(" ")
    if (tag.startsWith("https:")) return this.runPattern(text, {delimiter, tag: "a", attributes: `href="${tag}"` + attributes})
    return this.runPattern(text, {delimiter, tag, attributes})
   } catch (err) {
    console.error(err)
    return []
   }
   // Note: doubling up doesn't work because of the consumption characters.
  }
datelineParser
 cruxFromId
 description Gives your paragraph a dateline like "December 15, 2021 — The..."
 extends abstractAftertextDirectiveParser
 javascript
  getInserts() {
   let day = this.content || this.root.get("date")
   if (!day) return false
   try {
    const dayjs = require("dayjs")
    day = dayjs(day).format(`MMMM D, YYYY`)
   } catch (err) {
    console.error(err)
   }
   return [{ index: 0, string: `<span class="scrollDateline">${day} — </span>` }]
  }
dayjsParser
 description Advanced directive that evals some Javascript code in an environment including "dayjs".
 cruxFromId
 extends abstractAftertextDirectiveParser
 javascript
  getInserts() {
   const dayjs = require("dayjs")
   const days = eval(this.content)
   const index = this.parent.originalTextPostLinkify.indexOf("days")
   return [{ index, string: `${days} ` }]
  }
linkifyParser
 description Use this to disable linkify on the text.
 extends abstractAftertextDirectiveParser
 cruxFromId
 cells keywordCell booleanCell
abstractMarkupParameterParser
 cells keywordCell
 cruxFromId
matchAllParser
 description Use this to match all occurrences of the text.
 extends abstractMarkupParameterParser
matchParser
 catchAllCellType integerCell
 description Use this to specify which index(es) to match.
 javascript
  get indexes() {
   return this.getWordsFrom(1).map(num => parseInt(num))
  }
 example
  aftertext
   hello ello ello
   bold ello
    match 0 2
 extends abstractMarkupParameterParser
abstractHtmlAttributeParser
 javascript
  compile() {
   return ""
  }
linkTargetParser
 extends abstractHtmlAttributeParser
 description If you want to set the target of the link. To "_blank", for example.
 crux target
 cells keywordCell anyCell
blankLineParser
 description Blank lines compile to nothing in the HTML.
 cells blankCell
 javascript
  compile() {
   return this.parent.clearSectionStack()
  }
 pattern ^$
 tags doNotSynthesize
errorParser
 baseParser errorParser
chatLineParser
 catchAllCellType anyCell
 catchAllParser chatLineParser
lineOfCodeParser
 catchAllCellType codeCell
 catchAllParser lineOfCodeParser
commentLineParser
 catchAllCellType commentCell
cssLineParser
 catchAllCellType cssAnyCell
 catchAllParser cssLineParser
lineOfTextParser
 catchAllCellType stringCell
 boolean isTextParser true
htmlLineParser
 catchAllCellType htmlAnyCell
 catchAllParser htmlLineParser
stumpContentParser
 catchAllCellType anyCell
linkTitleParser
 description If you want to set the title of the link.
 crux title
 cells keywordCell
 catchAllCellType anyCell
 example
  * This report showed the treatment had a big impact.
   https://example.com/report This report.
    title The average growth in the treatment group was 14.2x higher than the control group.
programLinkParser
 catchAllCellType codeCell
abstractLoopConfigParser
 cells keywordCell
 cruxFromId
 catchAllCellType stringCell
abstractItemsProviderParser
 cells keywordCell
loopLinesParser
 crux lines
 extends abstractItemsProviderParser
 description Iterate over the provided lines.
 catchAllParser loopLineParser
 loopLineParser
  catchAllCellType stringCell
 javascript
  get items() {
   return this.map(node => node.asString)
  }
loopWordsParser
 crux words
 extends abstractItemsProviderParser
 catchAllCellType stringCell
 description Iterate over the provided words.
 javascript
  get items() {
   return this.getWordsFrom(1)
  }
loopGroupsParser
 crux groups
 extends abstractItemsProviderParser
 catchAllCellType groupNameWithOptionalFolderCell
 description Set this to iterate over scroll files in a folder. Provide both the folder and group name like this: [folder]/[groupName]
 javascript
  get items() {
   return this.root.file.getFilesInGroupsForEmbedding(this.getWordsFrom(1))
  }
abstractPointConfigParser
 // todo: scoped parsers should support abstract types
 cruxFromId
 cells keywordCell
 catchAllCellType stringCell
 single
latParser
 cells keywordCell floatCell
 cruxFromId
 single
longParser
 cells keywordCell floatCell
 cruxFromId
 single
plainTextLineParser
 catchAllCellType stringCell
 catchAllParser plainTextLineParser
quoteLineParser
 catchAllCellType anyCell
 catchAllParser quoteLineParser
readingListItemParser
 cells urlCell
 catchAllCellType stringCell
 javascript
  compile() {
   const url = this.firstWord
   const [title, author] = this.content.split(" by ")
   return `<li><a href="${url}">${title ?? url}</a>${author ? ` by ${author}` : ""}</li>`
  }
scrollParser
 extensions scroll
 description Tools for thought thats compile to HTML.
 root
 inScope abstractScrollParser blankLineParser
 catchAllParser catchAllParagraphParser
 compilesTo html
 javascript
  setFile(file) {
   this.file = file
   return this
  }
  compile(compileSettings) {
    this.sectionStack = []
    return this.map(child => child.compile(compileSettings)).filter(i => i).join("\n") + this.clearSectionStack()
  }
  sectionStack = []
  clearSectionStack() {
   const result = this.sectionStack.join("")
   this.sectionStack = []
   return result
  }
  get hakonParser() {
    if (this.isNodeJs())
      return require("jtree/products/hakon.nodejs.js")
    return hakonParser
  }
  alreadyRequired = new Set()
  compileEmbeddedVersion(compileSettings) {
   this.sectionStack = []
   return this.map(child => (child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))
     .filter(i => i)
     .join("\n")
     .trim() + this.clearSectionStack()
  }
  get footnotes() {
   if (this._footnotes === undefined) this._footnotes = this.filter(node => node.isFootnote)
   return this._footnotes
  }
  file = {}
  get permalink() {
   return this.get("permalink") || this.file.permalink || ""
  }
 example
  # Hello world
  ## This is Scroll
  * It compiles to HTML.
  
  code
   // You can add code as well.
   print("Hello world")
rowParser
 catchAllCellType stringCell
 javascript
  toRow(columns, delimiter) {
   const words = this.getLine().split(delimiter)
   let str = ""
   let column = 0
   const columnCount = columns.length
   while (column < columnCount) {
    const col = columns[column]
    column++
    const content = (columnCount === column ? words.slice(columnCount - 1).join(" ") : words[column - 1]) ?? ""
    if (col.isLink) continue
    let tagged = content
    const link = words[col.linkIndex]
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    else if (content.match(/^https?\:[^ ]+$/)) tagged = `<a href="${content}">${content}</a>`
    str += `<td>${tagged}</td>\n`
   }
   return str
  }
tagsParser
 // Todo: there may be a bug with having scoped parsers in abstract classes not being available to child classes.
 cells keywordCell booleanCell
 cruxFromId
treeRowContentParser
 description Any blob content in a cell.
 cells stringCell
 catchAllCellType stringCell
treeRowColumnParser
 catchAllParser treeRowContentParser
 description A columnName value pair, or just a columnName if the value is a text blob.
 cells idCell
 catchAllCellType stringCell
treeRowParser
 cells idCell
 description The root node of a row.
 catchAllParser treeRowColumnParser
 javascript
  toRow(columns) {
   let str = ""
   columns.forEach(col => {
    const node = this.getNode(col.name)
    if (col.isLink) return
    if (!node) {
     str += "<td></td>\n"
     return
    }
    const content = (node.length ? node.childrenToString() : node.content) ?? ""
    let tagged = ""
    const link = this.get(col.name + "Link")
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    else if (node.length) tagged = `<pre>${content}</pre>`
    else tagged = content
    str += `<td>${tagged}</td>\n`
   })
   return str
  }