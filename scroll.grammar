// Related work:
 CSS is great for text selector ideas: https://www.w3schools.com/cssref/css_selectors.asp
 Roff has a lot of related markup ideas: https://www.systutorials.com/docs/linux/man/7-groff_man/
// Extend this if you want to create a new provider
// Some basic providers:








anyCell
urlCell
 highlightScope constant.language
keywordCell
 highlightScope keyword
stringCell
 highlightScope string
booleanCell
 highlightScope constant.language
 enum true false
idCell
 highlightScope constant.language
dateCell
 highlightScope string
integerCell
 highlightScope constant.numeric
floatCell
 highlightScope constant.numeric
permalinkCell
 highlightScope string
 description A string that doesn't contain characters that might interfere with most filesystems. No slashes, for instance.
commentCell
 highlightScope comment
blankCell
personNameCell
 extends stringCell
codeCell
 highlightScope comment
bulletPointCell
 description Any token used as a bullet point such as "-" or "1." or ">"
 highlightScope keyword
emailAddressCell
 extends stringCell
tagOrUrlCell
 description An HTML tag or a url.
 highlightScope constant.language
delimiterCell
 description String to use as a delimiter.
 highlightScope string
htmlAttributesCell
 highlightScope comment
htmlTagCell
 highlightScope constant.language
 enum div span p a img ul ol li h1 h2 h3 h4 h5 h6 header nav section article aside main footer input button form label select option textarea table tr td th tbody thead tfoot br hr meta link script style title code
classNameCell
 highlightScope constant
htmlIdCell
 extends idCell
filePathCell
 extends stringCell
cssAnyCell
 extends anyCell
groupNameCell
 extends permalinkCell
groupNameWithOptionalFolderCell
 description A group name optionally combined with a folder path. Only used when referencing groups, not in posts.
 extends stringCell
htmlAnyCell
 extends stringCell
javascriptCell
 extends stringCell
abstractScrollParser
 cells keywordCell
 javascript
  compileEmbeddedVersion(compileSettings) {
   return this.compile(compileSettings)
  }
abstractAftertextParser
 description Text followed by markup commands.
 extends abstractScrollParser
 inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser aftertextTagParser commentParser
 example
  aftertext
   Hello brave new world
   link home.com new
   bold brave new
   underline new world
   strikethrough wor
 javascript
  get markupInserts() {
   const { originalTextPostLinkify } = this
   return this.filter(node => node.isMarkup)
    .map(node => node.getInserts(originalTextPostLinkify))
    .filter(i => i)
    .flat()
  }
  get originalText() {
   return this.content ?? ""
  }
  get originalTextPostLinkify() {
   const { originalText } = this
   const shouldLinkify = this.get("linkify") === "false" || originalText.includes("<a ") ? false : true
   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText
  }
  replaceNotes(originalText) {
   this.root.footnotes.forEach((note, index) => {
    const needle = note.firstWord
    if (originalText.includes(needle)) originalText = originalText.replace(needle, `<a href="#${note.anchorId}" class="scrollNoteLink" id="${note.linkBack()}"><sup>${note.noteId}</sup></a>`)
   })
   return originalText
  }
  get text() {
   const { originalTextPostLinkify, markupInserts } = this
   let adjustment = 0
   let newText = originalTextPostLinkify
   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.
   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))
   markupInserts.forEach(insertion => {
    insertion.index += adjustment
    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0
    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0
    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)
    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters
   })
   return newText
  }
  tag = "p"
  get className() {
   const classLine = this.getNode("class")
   if (classLine && classLine.applyToParentElement) return classLine.content
   return this.defaultClassName
  }
  defaultClassName = "scrollParagraph"
  compile(compileSettings) {
   this.compileSettings = compileSettings
   const { className } = this
   const classAttr = className ? `class="${this.className}"` : ""
   const tag = this.get("tag") || this.tag
   return `<${tag} ${this.divAttributes}${classAttr}>${this.text}</${tag}>`
  }
  get divAttributes() {
   const attrs = this.filter(node => node.isAttribute)
   return attrs.length ? attrs.map(node => node.divAttributes).join(" ") + " " : ""
  }
thoughtParser
 // todo Perhaps rewrite this from scratch and move out of aftertext.
 extends abstractAftertextParser
 catchAllCellType stringCell
 description A thought.
 cruxFromId
 javascript
  compile(compileSettings) {
   // Hacky, I know.
   const newLine = this.appendLine("wrapsOn")
   const compiled = super.compile(compileSettings)
   newLine.destroy()
   return compiled
  }
indentableThoughtParser
 extends thoughtParser
 inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser indentableThoughtParser
 javascript
  compile() {
   return (
    super.compile() +
    this.map(node => node.compile())
     .join("\n")
     .trim()
   )
  }
checklistTodoParser
 extends indentableThoughtParser
 example
  [] Get milk
 description An incomplete checklist item.
 crux []
 string checked 
 javascript
  get text() {
   return `<div style="text-indent:${(this.getIndentLevel() - 1) * 20}px;"><input type="checkbox" ${this.checked} id="${this.id}"><label for="${this.id}">` + super.text + `</label></div>`
  }
  get id() {
   return this.get("id") || "item" + this._getUid()
  }
checklistDoneParser
 extends checklistTodoParser
 description A complete checklist list item.
 string checked checked
 crux [x]
 example
  [x] get milk
listAftertextParser
 extends indentableThoughtParser
 example
  - I had a _new_ thought.
 description A list item.
 crux -
 javascript
  defaultClassName = ""
  compile() {
   const index = this.getIndex()
   const parent = this.parent
   const nodeClass = this.constructor
   const isStartOfList = index === 0 || !(parent.nodeAt(index - 1) instanceof nodeClass)
   const isEndOfList = parent.length === index + 1 || !(parent.nodeAt(index + 1) instanceof nodeClass)
   const { listType } = this
   return (isStartOfList ? `<${listType} style="text-indent:${(this.getIndentLevel() - 1) * 20}px;">` : "") + `${super.compile()}` + (isEndOfList ? `</${listType}>` : "")
  }
  tag = "li"
  listType = "ul"
orderedListAftertextParser
 extends listAftertextParser
 description A list item.
 example
  1. Hello world
 pattern ^\d+\. 
 javascript
  listType = "ol"
blinkParser
 description Useful when you have a client that always needs to find 1 thing they would like you to change.
 extends thoughtParser
 crux blink
 javascript
  compile() {
   return `<span class="scrollBlink">${super.compile()}</span>
    <script>
    setInterval(()=>{
        Array.from(document.getElementsByClassName("scrollBlink")).forEach(el => 
        el.style.color = el.style.color === "white" ? "black" : "white"
        )
    }, 2000)
    </script>`
  }
catchAllParagraphParser
 description A catch all block. This may be removed in future versions.
 extends thoughtParser
 cells stringCell
 baseParser errorParser
 javascript
  get originalText() {
   return this.getLine() || ""
  }
footnoteDefinitionParser
 description A footnote. Can also be used as section notes.
 extends thoughtParser
 boolean isFootnote true
 pattern ^\^.+$
 javascript
  get divAttributes() {
   return super.divAttributes + ` id="${this.anchorId}"`
  }
  get anchorId() {
   return `note${this.noteIndex}`
  }
  get noteId() {
   // In the future we could allow common practices like author name
   return this.noteIndex
  }
  linkBack() {
   return `noteUsage${this.noteIndex}`
  }
  get text() {
   return `<a class="scrollNoteIndex" href="#noteUsage${this.noteIndex}">${this.noteIndex}</a> ${super.text}`
  }
  get noteIndex() {
   return this.parent.footnotes.indexOf(this) + 1
  }
captionAftertextParser
 description An optional caption to accompany the resource.
 crux caption
 extends thoughtParser
sectionTitleParser
 description Compiles to an html h3 tag.
 extends thoughtParser
 crux #
 javascript
  compile(compileSettings) {
   this.parent.sectionStack.push("</div>")
   return `<div class="scrollSection">` + super.compile(compileSettings)
  }
  tag = "h3"
questionAftertextParser
 description A question.
 extends sectionTitleParser
 crux ?
 javascript
  tag = "h4"
  defaultClassName = "scrollQuestion"
titleParser
 description Title of the page for meta tags and also compiles to an html h1 tag.
 extends sectionTitleParser
 crux title
 javascript
  compile(compileSettings) {
   // Hacky, I know.
   const { permalink } = this.parent.file
   if (!permalink) return super.compile(compileSettings)
   const newLine = this.appendLine(`link ${permalink}`)
   const compiled = super.compile(compileSettings)
   newLine.destroy()
   return compiled
  }
  defaultClassName = "scrollTitle"
  tag = "h1"
sectionSubTitleParser
 description Compiles to an html h4 tag.
 extends sectionTitleParser
 crux ##
 javascript
  tag = "h4"
quickThoughtParser
 crux *
 extends thoughtParser
 example
  * I had a _new_ thought.
startColumnsParser
 extends abstractAftertextParser
 cruxFromId
 catchAllCellType integerCell
 description Start a multicolumn grid.
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const columnWidth = 35
   const COLUMN_GAP = 20
   const maxColumns = parseInt(this.getWord(1) ?? 10)
   const maxTotalWidth = maxColumns * columnWidth + (maxColumns - 1) * COLUMN_GAP
   // Starting the columns always first clears the section stack.
   return this.parent.clearSectionStack() + `<div class="scrollColumns" style="column-width:${columnWidth}ch;column-count:${maxColumns};max-width:${maxTotalWidth}ch;">`
  }
endColumnsParser
 extends abstractAftertextParser
 cruxFromId
 description End a multicolumn grid.
 javascript
  compile() {
   return "</div>"
  }
  compileEmbeddedVersion() {
   return ""
  }
horizontalRuleParser
 crux ---
 description Prints an html <hr> tag
 extends abstractAftertextParser
 javascript
  compile() {
   return `<hr>`
  }
loopParser
 extends abstractAftertextParser
 cells keywordCell
 description Iterate over files, lines or words, evaluating code and joining the resulting HTML.
 cruxFromId
 inScope abstractItemsProviderParser
 joinParser
  extends abstractLoopConfigParser
  description HTML to use to join the items.
 limitParser
  extends abstractLoopConfigParser
  description HTML to use to join the items.
 javascriptParser
  extends abstractLoopConfigParser
  description Javascript to execute for each file in the loop.
 javascript
  compile() {
   const code = this.get("javascript")
   const joinWith = this.get("join") ?? ""
   try {
    const limit = this.get("limit")
    let items = this.items
    if (limit) items = items.slice(0, parseInt(limit))
    return items.map((item, index) => eval(code)).join(joinWith)
   } catch (err) {
    console.error(err)
    return ""
   } finally {
    this.teardown()
   }
  }
  get items() {
   const provider = this.getChildInstancesOfParserId("abstractItemsProviderParser")[0]
   return provider ? provider.items : []
  }
  teardown() {}
loremIpsumParser
 extends abstractAftertextParser
 cruxFromId
 description Generate dummy text.
 catchAllCellType integerCell
 javascript
  compile() {
   const text = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`
   return text.repeat(this.getWord(1) ? parseInt(this.getWord(1)) : 1)
  }
snippetsParser
 extends abstractAftertextParser
 cruxFromId
 cells keywordCell groupNameWithOptionalFolderCell
 catchAllCellType groupNameWithOptionalFolderCell
 description Prints the snippets of all files in the named group(s).
 example
  snippets index
 javascript
  makeSnippet(file, compileSettings) {
    const {scrollProgram} = file
    const snippetBreak = scrollProgram.getNode("endSnippet")
    if (!snippetBreak) return scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml
    const indexOfBreak = snippetBreak.getIndex()
    const linkRelativeToCompileTarget = compileSettings.relativePath + file.permalink
    const joinChar = "\n"
    const html = scrollProgram
        .map((child, index) => (index >= indexOfBreak ? "" : child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))
        .filter(i => i)
        .join(joinChar)
        .trim() +
      `<a class="scrollContinueReadingLink" href="${linkRelativeToCompileTarget}">Continue reading...</a>`
    return html + file.viewSourceHtml
  }
  compile() {
   const file = this.parent.file
   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1))
   const alreadyRequired = this.root.alreadyRequired
   const snippets = files.map(file => {
   const compileSettings = {relativePath: file.relativePath, alreadyRequired }
   return `<div class="scrollSnippetContainer">${this.makeSnippet(file.file, compileSettings)}</div>`
   }).join("\n\n")
   return `<div class="scrollColumns" style="column-width:35ch;">${snippets}</div>`
  }
fullSnippetsParser
 extends snippetsParser
 cruxFromId
 description Prints the full contents of files that are in the named group.
 javascript
  makeSnippet(file, compileSettings) {
   return file.scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml
  }
viewSourceParser
 extends abstractAftertextParser
 cruxFromId
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const file = this.parent.file
   const { viewSourceUrl } = file
   return file.compileStumpCode(`p
   class scrollViewSource doNotPrint
   a View source
    href ${viewSourceUrl}`)
  }
byLineParser
 description Prints a byline with the author's name and optionally a link to them.
 extends abstractScrollParser
 cruxFromId
 cells keywordCell urlCell
 catchAllCellType personNameCell
 example
  // With Link:
  byLine https://breckyunits.com Breck Yunits
  // No link:
  byLine  Breck Yunits
 javascript
  compile() {
   const link = this.getWord(1)
   return `<div class="scrollByLine">by <a ${link ? `href="${link}"` : ""}>${this.getWordsFrom(2).join(" ")}</a></div>`
  }
authorParser
 extends byLineParser
chatParser
 description A dialogue between two people.
 catchAllParser chatLineParser
 cruxFromId
 extends abstractScrollParser
 javascript
  compile() {
   return this.map((line, index) => `<div class="scrollChat ${index % 2 ? "scrollChatRight" : "scrollChatLeft"}"><span>${line.asString}</span></div>`).join("")
  }
codeParser
 description A code block.
 catchAllParser lineOfCodeParser
 extends abstractScrollParser
 javascript
  compile() {
   return `<code class="scrollCodeBlock">${this.childrenToString().replace(/\</g, "&lt;")}</code>`
  }
 cruxFromId
codeWithLanguageParser
 description Use this to specify the language of the code block, such as csvCode or rustCode.
 extends codeParser
 pattern ^[a-zA-Z0-9_]+Code$
abstractScrollWithRequirementsParser
 extends abstractScrollParser
 javascript
  compile(compileSettings) {
    const {requireOnce} = this
    const set = compileSettings?.alreadyRequired || this.root.alreadyRequired
    let requireSnippet = ""
    if (!set.has(requireOnce)) {
      set.add(requireOnce)
      requireSnippet = requireOnce + "\n\n"
    }
    return requireSnippet + this.compileInstance()
  }
copyButtonsParser
 cruxFromId
 extends abstractScrollWithRequirementsParser
 description Make code snippets copyable.
 javascript
  compileInstance() {
   return ""
  }
 string requireOnce
  <script>
  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollCodeBlock").forEach(block =>
   {
    if (!navigator.clipboard) return
    const button = document.createElement("span")
    button.classList.add("scrollCopyButton")
    block.appendChild(button)
    button.addEventListener("click", async () => {
      await navigator.clipboard.writeText(block.innerText)
      button.classList.add("scrollCopiedButton")
    })
   }
  ))
  </script>
katexParser
 cruxFromId
 extends abstractScrollWithRequirementsParser
 catchAllCellType codeCell
 catchAllParser lineOfCodeParser
 description Use the KaTex library to typeset math.
 string requireOnce
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.6/dist/katex.min.css" integrity="sha384-mXD7x5S50Ko38scHSnD4egvoExgMPbrseZorkbE49evAfv9nNcbrXJ8LLNsDgh9d" crossorigin="anonymous">
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.6/dist/katex.min.js" integrity="sha384-j/ZricySXBnNMJy9meJCtyXTKMhIJ42heyr7oAdxTDBy/CYA9hzpMo+YTNV5C+1X" crossorigin="anonymous"></script>
  <script>
  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollKatex").forEach(el =>
   {
    katex.render(el.innerText, el, {
        throwOnError: false
    });
   }
  ))
  </script>
 javascript
  compileInstance() {
   const id = this._getUid()
   const content = this.content === undefined ? "" : this.content
   return `<div class="scrollKatex" id="${id}">${content + this.childrenToString()}</div>`
  }
mapParser
 cruxFromId
 inScope latParser longParser
 zoomParser
  cells keywordCell integerCell
  cruxFromId
  single
 heightParser
  cells keywordCell floatCell
  cruxFromId
  single
 pointParser
  cells keywordCell
  inScope latParser longParser
  cruxFromId
  titleParser
   extends abstractPointConfigParser
  descriptionParser
   extends abstractPointConfigParser
 extends abstractScrollWithRequirementsParser
 description Uses LeafletJs
 // todo Make this only require once
 string requireOnce
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
 javascript
  compileInstance() {
   const height = 500
   const id = this._getUid()
   return `<div id="map${id}" style="height: ${height}px;"></div>
  <script>
   {
    const lat = ${this.get("lat") ?? 37.8}
    const long = ${this.get("long") ?? 4}
    const zoomLevel = ${this.get("zoom") ?? 4}
    const points = ${JSON.stringify(this.findNodes("point").map(node => node.toObject()))}
    const map = L.map("map${id}").setView([lat, long], zoomLevel)
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
     attribution: '<a href="https://www.openstreetmap.org/">OpenStreetMap</a>',
     maxZoom: 18
    }).addTo(map)
    points.forEach(point => {
     L.marker([point.lat, point.long])
      .addTo(map)
      .bindPopup("<b>" +point.title + "</b><br />" + point.description)
    })
   }
  </script>`
  }
belowAsCodeParser
 description Print the Scroll code of the next node.
 extends abstractScrollParser
 catchAllCellType integerCell
 cruxFromId
 javascript
  method = "next"
  get code() {
   const { method } = this
   let code = ""
   let howMany = parseInt(this.getWord(1))
   if (!howMany || isNaN(howMany)) howMany = 1
   let nodes = []
   let next = this[method]
   while (howMany) {
    nodes.push(next)
    next = next[method]
    howMany--
   }
   if (this.reverse) nodes.reverse()
   return nodes.map(node => node.asString).join("\n")
  }
  reverse = false
  compile() {
   return `<code class="scrollCodeBlock">${this.code.replace(/\</g, "&lt;")}</code>`
  }
aboveAsCodeParser
 description Print the Scroll code for the previous node.
 extends belowAsCodeParser
 javascript
  method = "previous"
  reverse = true
commentParser
 description Comments do not appear in the compiled HTML.
 catchAllCellType commentCell
 cells commentCell
 extends abstractScrollParser
 cruxFromId
 javascript
  compile() {
   return ``
  }
 catchAllParser commentLineParser
slashCommentParser
 extends commentParser
 crux //
counterpointParser
 description A counterpoint. Will not show up in the compiled HTML.
 extends commentParser
 crux !
cssParser
 extends abstractScrollParser
 description Prints CSS content wrapped in a style tag.
 cruxFromId
 catchAllParser cssLineParser
 catchAllCellType cssAnyCell
 javascript
  compile() {
   return `<style>${this.content ?? ""}${this.childrenToString()}</style>`
  }
dashboardParser
 description Display key stats in a big font.
 catchAllParser rowParser
 cruxFromId
 extends abstractScrollParser
 example
  dashboard
   #2 Popularity
   30 Years Old
   $456 Revenue
 javascript
  get tableBody() {
   const items = this.topDownArray
   let str = ""
   for (let i = 0; i < items.length; i = i + 3) {
    str += this.makeRow(items.slice(i, i + 3))
   }
   return str
  }
  makeRow(items) {
   return `<tr>` + items.map(node => `<td>${node.firstWord}<span>${node.content}</span></td>`).join("\n") + `</tr>\n`
  }
  compile() {
   return `<table class="scrollDashboard">${this.tableBody}</table>`
  }
abstractTopLevelSingleMetaParser
 description Use these keywords once per file.
 extends abstractScrollParser
 cruxFromId
 cells keywordCell
 javascript
  compile() {
   return ""
  }
dateParser
 catchAllCellType dateCell
 description Date this file was first published.
 extends abstractTopLevelSingleMetaParser
permalinkParser
 description When compiling, Scroll will save this file to {permalink}
 extends abstractTopLevelSingleMetaParser
 cells keywordCell permalinkCell
abstractThemeCssParser
 description Extend this to create a Scroll CSS theme.
 extends abstractTopLevelSingleMetaParser
 inScope tagsParser
 cruxFromId
 catchAllCellType stringCell
 javascript
  get useTags() {
    return !(this.get("tags") === "false")
  }
  compile() {
   return this.useTags ? `<style>${this.css}</style>` : this.css
  }
  compileEmbeddedVersion() {
   return ""
  }
gazetteCssParser
 description The default Scroll theme.
 extends abstractThemeCssParser
 javascript
  get css() {
    if (this.constructor._cachedCss)
      return this.constructor._cachedCss
    const hakonParser = this.hakonParser
    this.constructor._cachedCss = new hakonParser([this.hakonReset, this.hakonStandardStyles, this.hakonCustomElements].join("\n")).compile()
    return this.constructor._cachedCss
  }
  get hakonParser() {
    if (this.isNodeJs())
      return require("jtree/products/hakon.nodejs.js")
    return hakonParser
  }
 // CSS Reset
 string hakonReset
  html,body,div,span,h1,h2,h3,h4,p,ol,ul,li,table,figure
   margin 0
   padding 0
   border 0
   vertical-align baseline
   border-spacing 0
  li
   list-style-position inside
   margin-top .4em
   line-height 1.2em
  a
   text-decoration-color transparent
  a:hover
   text-decoration-color initial
  sup,sub
   vertical-align baseline
   position relative
   top -0.6em
  sub
   top 0.6em
  html
   padding 4px
   background-color rgb(244,244,244)
   font-family Exchange,Georgia,serif
   color #000
   font-size 14px
   hyphens auto
  p
   margin-top 0.4em
   line-height 1.4em
  .scrollQuote
   break-inside avoid
   display block
   margin .5em 0
   padding .5em
   background rgba(204,204,204,.5)
   white-space pre-line
   border-left .5em solid rgba(204,204,204,.8)
  code
   font-size 90%
   background-color rgba(204,204,204,.5)
   padding 2px 4px
   border-radius 4px
 // Header and Footer
 string hakonCustomElements
  .gazetteHeader
   svg
    width 30px
    height 30px
    fill rgba(204,204,204,.8)
    &:hover
     fill #333
   a
    color rgba(204,204,204,.8)
    position absolute
    font-size 30px
    line-height 27px
    text-decoration none
    &:hover
     color #333
   .gazetteTopLeftBar
    text-align left
    left 25px
   .gazetteTopRightBar
    text-align right
    right 25px
   a.gazettePrevPageLink
    left 3px
   a.gazetteNextPageLink
    right 3px
  .gazetteFooter
   margin-top 8px
   padding-top 8px
   text-align center
   svg
    width 30px
    height 30px
    fill rgba(204,204,204, .5)
    padding 0 7px
    &:hover
     fill #333
  .gazetteScrollLink
   display block
   font-family Verdana
   font-weight 100
   margin .5em
   color rgba(204,204,204,.5)
 // Styles for Scroll standard tags
 string hakonStandardStyles
  comment Main body of both pages is similar
  .scrollColumns
   column-count auto
   column-fill balance
   column-width 35ch
   column-gap 20px
   padding-left 20px
   padding-right 20px
   margin auto
  comment On group pages add some spacing around files
  .scrollSnippetContainer
   padding 1ch 0
   break-inside avoid
   text-align justify
  .scrollTitle
   text-align center
   margin-bottom .25em
   a
    color #000
  .scrollDateline
   font-style italic
   font-size 80%
  .scrollSection
   break-inside avoid
   h2
    text-align center
   h3
    margin-top 1em
    text-align center
   h4
    margin-top 1em
    text-align center
  h4.scrollQuestion
   text-align left
  .scrollNoteLink
   opacity .4
  
  .scrollHoverNote
   text-decoration underline dashed 1px rgba(0,0,0,.1)
   cursor default
  
  .scrollCodeBlock
   overflow auto
   font-size 80%
   hyphens none
   white-space pre
   border-left .5em solid rgba(204,204,204,.8)
   break-inside avoid
   display block
   margin .5em 0
   padding .5em
   border-radius 0
   position relative
  .scrollCodeBlock:hover
   .scrollCopyButton
    opacity .5
   .scrollCopyButton:hover
    opacity .8
   .scrollCopyButton:active
    opacity 1
  .scrollCopyButton
   position absolute
   top 2px
   right 2px
   font-size 14px
   cursor pointer
   opacity 0
  .scrollCopyButton::after
   content "[ ]"
  .scrollCopiedButton::after
   content "[âœ“]"
  
  .scrollTable
   table-layout fixed
   margin .5em 0
   overflow hidden
   font-size 80%
   width 100%
   hyphens none
   border 1px solid rgba(224,224,224,.8)
   td,th
    padding 3px
    overflow hidden
   th
    border-bottom 2px solid rgba(0,0,0,.6)
    text-align left
   tr:nth-child(even)
    background rgba(224,224,224,.6)
  
  .scrollByLine
   font-size 12px
   font-style italic
   margin 4px 0
   text-align center
  
  comment Subtle "Article Source" link
  .scrollViewSource
   text-align center
   font-size 80%
   margin 0
   margin-top 0.4em
   line-height 1.4em
   margin-bottom 1em
   a
    color #000
  
  .scrollContinueReadingLink
   display block
   text-align center
  
  .scrollCaptionedFigure
   display block
   text-align center
   img
    max-width 98%
    height auto
   figcaption
    font-style italic
  .scrollDashboard
   width 100%
   font-size 30px
   text-align center
   font-weight bold
   break-inside avoid
   margin-top 8px
   margin-bottom 8px
   td
    width 33.3%
    border 1px solid #e8e8e8
   span
    font-size 20p;
    display block
  .scrollChat
   span
    font-family Verdana
    margin-top 5px
    padding 5px 20px
    border-radius 15px
    display inline-block
  .scrollChatLeft
   text-align left
   span
    background rgba(204,204,204, .5)
  .scrollChatRight
   text-align right
   span
    color white
    background rgb(0,132,255)
  .scrollYouTubeHolder
   position relative
   width 100%
   height 0
   padding-bottom 56.25%
  .scrollYouTubeEmbed
   position absolute
   top 0
   left 0
   width 100%
   height 100%
abstractThemeHeaderParser
 cruxFromId
 description A theme header.
 extends abstractTopLevelSingleMetaParser
 javascript
  compileEmbeddedVersion() {
   return ""
  }
gazetteHeaderParser
 extends abstractThemeHeaderParser
 javascript
  compile() {
   const file = this.parent.file
   const { SVGS, linkToPrevious, linkToNext } = file
   let previousButton = ""
   if (linkToPrevious)
    previousButton = `a <
    class gazettePrevPageLink
    href ${linkToPrevious}`
   let nextButton = ""
   if (linkToNext)
    nextButton = `a >
    class gazetteNextPageLink
    href ${linkToNext}`
   return file.compileStumpCode(`div
   class gazetteHeader doNotPrint
   ${previousButton}
   a ${SVGS.home}
    class gazetteTopLeftBar
    href ${file.get("homeLink") || "index.html"}
   a ${SVGS.git}
    class gazetteTopRightBar
    href ${file.git}
   ${nextButton}`)
  }
abstractThemeFooterParser
 cruxFromId
 description A theme footer.
 extends abstractTopLevelSingleMetaParser
 javascript
  compileEmbeddedVersion() {
   return ""
  }
gazetteFooterParser
 extends abstractThemeFooterParser
 javascript
  compile() {
   const file = this.parent.file
   const { SVGS, SCROLL_VERSION, viewSourceUrl } = file
   const closeContainerTag = "</div>"
   return (
    closeContainerTag +
    file.compileStumpCode(`p
   class scrollViewSource doNotPrint
   a View source
    href ${viewSourceUrl}
  div
   class gazetteFooter doNotPrint
   a ${SVGS.email}
    href mailto:${file.email}
   a ${SVGS.git}
    href ${file.git}
   a Built with Scroll v${SCROLL_VERSION}
    href https://scroll.pub
    class gazetteScrollLink`)
   )
  }
groupsParser
 description Add this file to zero or more groups.
 cruxFromId
 example
  groups index.html
 extends abstractTopLevelSingleMetaParser
 cells keywordCell
 catchAllCellType groupNameCell
metaTagsParser
 cruxFromId
 extends abstractTopLevelSingleMetaParser
 description Adds meta tags like title, description, et cetera.
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const { file } = this.parent
   const { title, description, openGraphImage, SCROLL_VERSION, canonicalLink } = file
   const rssFeedUrl = file.get("rssFeedUrl")
   let rssTag = ""
   if (rssFeedUrl) {
    rssTag = `link
   rel alternate
   type application/rss+xml
   title ${title}
   href ${rssFeedUrl}`
   }
   return file.compileStumpCode(`meta
   charset utf-8
  titleTag ${title}
  script /* This HTML was generated by ðŸ“œ Scroll v${SCROLL_VERSION}. http://scroll.pub */
  styleTag @media print {.doNotPrint {display: none !important;}}
  link
   rel canonical
   href ${canonicalLink}
  meta
   charset iso-8859-1
  meta
   name viewport
   content width=device-width,initial-scale=1
  meta
   name description
   content ${description}
  meta
   name generator
   content Scroll v${SCROLL_VERSION}
  meta
   property og:title
   content ${title}
  meta
   property og:description
   content ${description}
  meta
   property og:image
   content ${openGraphImage}
  ${rssTag}
  meta
   name twitter:card
   content summary_large_image`)
  }
descriptionParser
 catchAllCellType stringCell
 description Description for Open Graph. https://ogp.me/. If not defined, Scroll will try to generate it's own.
 extends abstractTopLevelSingleMetaParser
endSnippetParser
 description Insert one of these where you want to cut the file for a snippet.
 extends abstractTopLevelSingleMetaParser
viewSourceUrlParser
 catchAllCellType urlCell
 description Use this to override the link to the source code for a scroll file.
 extends abstractTopLevelSingleMetaParser
abstractFileSettingParser
 extends abstractScrollParser
 cells keywordCell
 javascript
  compile() {
   return ""
  }
abstractUrlSettingParser
 extends abstractFileSettingParser
 cells keywordCell urlCell
 cruxFromId
baseUrlParser
 description Root url of this published site on the web. Must be provided for RSS Feeds and OpenGraph tags to work, but has no effect locally.
 extends abstractUrlSettingParser
homeLinkParser
 description In the default Scroll theme the home button will link to "index.html". You can override this with this setting.
 extends abstractUrlSettingParser
viewSourceBaseUrlParser
 description The base link to be used to generate the "View source" link.
 extends abstractUrlSettingParser
gitParser
 description A link to the web Git UI for this site.
 extends abstractUrlSettingParser
canonicalLinkParser
 description Canonical URL for SEO. If undefined Scroll generates this from the baseUrl and permalink.
 extends abstractUrlSettingParser
openGraphImageParser
 description URL for Open Graph Image. https://ogp.me/. If not defined, Scroll will try to generate it's own using the first image tag on your page.
 extends abstractUrlSettingParser
rssFeedUrlParser
 description URL for RSS feed, if any.
 extends abstractUrlSettingParser
abstractSiteStringSettingParser
 extends abstractFileSettingParser
 catchAllCellType stringCell
 cruxFromId
emailParser
 description Email address for the site owner.
 extends abstractFileSettingParser
 cruxFromId
 cells keywordCell emailAddressCell
scrollParserDefinitionParser
 extends abstractScrollParser
 // todo Figure out best pattern for integrating Scroll and Grammar?
 pattern ^[a-zA-Z0-9_]+Parser$
 description Define your own parsers in the Grammar language for using in your Scroll files.
 baseParser blobParser
 javascript
  compile() {
   return ""
  }
htmlParser
 description A catch all block to drop in any loose html. Use for HTML one liners and/or blocks of HTML.
 cruxFromId
 extends abstractScrollParser
 catchAllParser htmlLineParser
 catchAllCellType htmlAnyCell
 javascript
  compile() {
   return `${this.content ?? ""}${this.childrenToString()}`
  }
quickHtmlParser
 extends htmlParser
 cells htmlAnyCell
 pattern ^<
 description Start a line with a less than sign to immediately write HTML
 javascript
  compile() {
   return `${this.getLine() ?? ""}${this.childrenToString()}`
  }
stumpParser
 cruxFromId
 extends abstractScrollParser
 description Stump is a Tree Language that compiles to HTML.
 catchAllParser stumpContentParser
 javascript
  compile() {
   const file = this.parent.file
   return file.compileStumpCode(this.childrenToString())
  }
stumpNoSnippetParser
 extends stumpParser
 description Useful for headers and footers when you have something you don't want included in snippets.
 cruxFromId
 javascript
  compileEmbeddedVersion() {
   return ""
  }
abstractCaptionedParser
 extends abstractScrollParser
 cells keywordCell urlCell
 inScope captionAftertextParser slashCommentParser
 cruxFromId
 javascript
  compile(compileSettings) {
   const caption = this.getNode("caption")
   const captionFig = caption ? `<figcaption>${caption.compile()}</figcaption>` : ""
   return `<figure class="scrollCaptionedFigure">${this.getFigureContent(compileSettings)}${captionFig}</figure>`
  }
imageParser
 description An img tag.
 extends abstractCaptionedParser
 inScope classMarkupParser aftertextIdParser
 javascript
  getFigureContent(compileSettings) {
   const file = this.root.file
   const src = this.getWord(1)
   const linkRelativeToCompileTarget = (compileSettings ? (compileSettings.relativePath ?? "") : "") + src
   let dimensionAttributes = ""
   // If its a local image, get the dimensions and put them in the HTML
   // to avoid flicker
   if (!src.startsWith("http:") && !src.startsWith("https:")) {
    try {
     const sizeOf = require("image-size")
     const path = require("path")
     const fullImagePath = path.join(file.folderPath, src)
     const dimensions = sizeOf(fullImagePath)
     const width = dimensions.width
     const height = dimensions.height
     dimensionAttributes = `width="${width}" height="${height}" `
    } catch (err) {
     console.error(err)
    }
   }
   const className = this.has("class") ? ` class="${this.get("class")}" ` : ""
   const id = this.has("id") ? ` id="${this.get("id")}" ` : ""
   return `<a href="${linkRelativeToCompileTarget}" target="_blank" ${className} ${id}><img src="${linkRelativeToCompileTarget}" ${dimensionAttributes}loading="lazy"></a>`
  }
youTubeParser
 extends abstractCaptionedParser
 description Embed a YouTube video. Include the YouTube embed URL such as https://www.youtube.com/embed/CYPYZnVQoLg
 javascript
  getFigureContent() {
   const url = this.getWord(1).replace("youtube.com/watch?v=", "youtube.com/embed/")
   return `<div class="scrollYouTubeHolder"><iframe class="scrollYouTubeEmbed" src="${url}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>`
  }
importParser
 description Import one file into another.
 cruxFromId
 extends abstractScrollParser
 catchAllCellType filePathCell
 javascript
  compile() {
   return ""
  }
 example
  import header.scroll
importOnlyParser
 description Mark a file as not one to build. This line will be not be imported into the importing file.
 cruxFromId
 extends abstractScrollParser
 javascript
  compile() {
   return ""
  }
keyboardNavParser
 description Makes left go to previous file and right go to next file.
 extends abstractScrollParser
 cruxFromId
 catchAllCellType urlCell
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const file = this.root.file
   const linkToPrevious = this.getWord(1) ?? file.linkToPrevious
   const linkToNext = this.getWord(2) ?? file.linkToNext
   const script = `<script>document.addEventListener('keydown', function(event) {
    if (document.activeElement !== document.body) return
    const getLinks = () => document.getElementsByClassName("scrollKeyboardNav")[0].getElementsByTagName("a")
    if (event.key === "ArrowLeft")
      getLinks()[0].click()
    else if (event.key === "ArrowRight")
      getLinks()[1].click()
   });</script>`
   return `<div class="scrollKeyboardNav" style="display:none;"><a href="${linkToPrevious}">${linkToPrevious}</a> Â· ${file.permalink} Â· <a href="${linkToNext}">${linkToNext}</a>${script}</div>`
  }
quoteParser
 cruxFromId
 description A blockquote.
 catchAllParser quoteLineParser
 extends abstractScrollParser
 javascript
  compile() {
   return `<blockquote class="scrollQuote">${this.childrenToString()}</blockquote>`
  }
readingListParser
 extends abstractScrollParser
 description Easily create a reading list with links, titles, and author names.
 cells keywordCell
 cruxFromId
 catchAllParser readingListItemParser
 example
  readingList
   https://example.com/similar by Author Name
 javascript
  compile() {
   return `<br><ul>${this.map(child => child.compile()).join("\n")}</ul>`
  }
redirectToParser
 description Prints an HTML redirect tag. In the future might also emit nginx config.
 extends abstractScrollParser
 cells keywordCell urlCell
 cruxFromId
 example
  redirectTo https://scroll.pub/releaseNotes.html
 javascript
  compile() {
   return `<meta http-equiv="Refresh" content="0; url='${this.getWord(1)}'" />`
  }
replaceParser
 description Define a variable token and replacement that will be applied to all lines before and after this one.
 extends abstractScrollParser
 cruxFromId
 catchAllCellType stringCell
 baseParser blobParser
 example
  replace YEAR 2022
 javascript
  compile() {
   return ""
  }
replaceJsParser
 description Define a variable token and replacement that will be applied to all lines before and after this one.
 extends replaceParser
 catchAllCellType javascriptCell
 example
  replaceJs SUM 1+1
  * 1+1 = SUM
nodejsParser
 description Write nodejs code inside a Scroll file. Sort of like PHP.
 extends abstractScrollParser
 cruxFromId
 catchAllCellType javascriptCell
 baseParser blobParser
 example
  nodejs
   module.exports = {SCORE : 1 + 2}
  * The score is SCORE
replaceDefaultParser
 description Define the default value for a replacement. Useful if you want to import a file and set a replacement later.
 extends abstractScrollParser
 catchAllCellType stringCell
 baseParser blobParser
 example
  replaceDefault YEAR 2021
 cruxFromId
 javascript
  compile() {
   return ""
  }
printFeedParser
 description Prints out the RSS feed for a group.
 extends abstractScrollParser
 cruxFromId
 cells keywordCell groupNameWithOptionalFolderCell
 catchAllCellType groupNameWithOptionalFolderCell
 example
  printFeed index
  printFeed cars/index
 javascript
  compile() {
   const dayjs = require("dayjs")
   const file = this.root.file
   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1)).map(file => file.file)
   const { title, baseUrl, description } = file
   return `<?xml version="1.0" encoding="ISO-8859-1" ?>
  <rss version="2.0">
  <channel>
   <title>${title}</title>
   <link>${baseUrl}</link>
   <description>${description}</description>
   <lastBuildDate>${dayjs().format("ddd, DD MMM YYYY HH:mm:ss ZZ")}</lastBuildDate>
   <language>en-us</language>
  ${files.map(file => file.toRss()).join("\n")}
  </channel>
  </rss>`
  }
abstractTableParser
 cruxFromId
 catchAllParser rowParser
 extends abstractScrollParser
 javascript
  get tableHeader() {
   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\n`)
  }
  get columnNames() {
   const header = this.nodeAt(0)
   return header ? header.getLine().split(this.delimiter) : []
  }
  get columns() {
   const cols = this.columnNames
   return cols.map((name, index) => {
    const isLink = name.endsWith("Link")
    const linkIndex = cols.indexOf(name + "Link")
    return {
     name,
     isLink,
     linkIndex
    }
   })
  }
  get tableBody() {
   const { delimiter } = this
   return this.topDownArray
    .slice(1)
    .map(node => `<tr>${node.toRow(this.columns, delimiter)}</tr>`)
    .join("\n")
  }
  compile() {
   return `<table class="scrollTable"><thead><tr>${this.tableHeader.join("\n")}</tr></thead>\n<tbody>${this.tableBody}</tbody></table>`
  }
tableParser
 description A table with a custom delimiter.
 extends abstractTableParser
 catchAllCellType anyCell
 javascript
  get delimiter() {
   return this.content ?? ""
  }
commaTableParser
 description Comma separated values table.
 extends abstractTableParser
 string delimiter ,
pipeTableParser
 description Pipe separated values table.
 extends abstractTableParser
 string delimiter |
spaceTableParser
 description Space separated values table. Last column is a catch all.
 extends abstractTableParser
 string delimiter  
tabTableParser
 description Tab separated values table.
 extends abstractTableParser
 string delimiter \t
treeTableParser
 description A table of data written in Tree Notation form. Useful when a column contains a text blob.
 extends abstractTableParser
 catchAllParser treeRowParser
 javascript
  get columnNames() {
   return this._getUnionNames()
  }
  get tableBody() {
   return this.map(node => `<tr>${node.toRow(this.columns)}</tr>`).join("\n")
  }
 example
  treeTable
   row
    name Javascript
    example
     console.log("Hello world")
   row
    name Python
    example
     print "Hello world"
abstractAftertextAttributeParser
 cells keywordCell
 boolean isAttribute true
 javascript
  get divAttributes() {
   return `${this.firstWord}="${this.content}"`
  }
  compile() {
   return ""
  }
aftertextIdParser
 crux id
 description Provide an ID to be output in the generated HTML tag.
 extends abstractAftertextAttributeParser
 cells keywordCell htmlIdCell
 single
aftertextStyleParser
 crux style
 description Provide code for the generated HTML tag's "style" attribute.
 extends abstractAftertextAttributeParser
 cells keywordCell
 catchAllCellType cssAnyCell
aftertextHiddenParser
 crux hidden
 cells keywordCell
 description Do not compile this node to HTML.
 extends abstractAftertextAttributeParser
 single
aftertextTagParser
 cells keywordCell htmlTagCell
 crux tag
 javascript
  compile() {
   return ""
  }
abstractAftertextDirectiveParser
 cells keywordCell
 catchAllCellType stringCell
 javascript
  isMarkup = true
  compile() {
   return ""
  }
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get shouldMatchAll() {
   return this.has("matchAll")
  }
  getMatches(text) {
   const { pattern } = this
   const escapedPattern = pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   return [...text.matchAll(new RegExp(escapedPattern, "g"))].map(match => {
    const { index } = match
    const endIndex = index + pattern.length
    return [
     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },
     { index: endIndex, endIndex, string: `</${this.closeTag}>` }
    ]
   })
  }
  getInserts(text) {
   const matches = this.getMatches(text)
   if (!matches.length) return false
   if (this.shouldMatchAll) return matches.flat()
   const match = this.getNode("match")
   if (match)
    return match.indexes
     .map(index => matches[index])
     .filter(i => i)
     .flat()
   return matches[0]
  }
  get allAttributes() {
   const attr = this.attributes.join(" ")
   return attr ? " " + attr : ""
  }
  get attributes() {
   return []
  }
  get openTag() {
   return this.tag
  }
  get closeTag() {
   return this.tag
  }
abstractMarkupParser
 extends abstractAftertextDirectiveParser
 inScope abstractMarkupParameterParser
boldParser
 cruxFromId
 extends abstractMarkupParser
 javascript
  tag = "b"
italicsParser
 cruxFromId
 extends abstractMarkupParser
 javascript
  tag = "i"
underlineParser
 cruxFromId
 extends abstractMarkupParser
 javascript
  tag = "u"
aftertextCodeParser
 crux code
 extends abstractMarkupParser
 javascript
  tag = "code"
linkParser
 extends abstractMarkupParser
 cells keywordCell urlCell
 inScope linkTitleParser linkTargetParser commentParser
 cruxFromId
 javascript
  tag = "a"
  get link() {
   const link = this.getWord(1)
   const isAbsoluteLink = link.startsWith("https://") || link.startsWith("http://")
   if (isAbsoluteLink) return link
   const relativePath = this.parent.compileSettings?.relativePath || ""
   return relativePath + link
  }
  get attributes() {
   const attrs = [`href="${this.link}"`]
   const options = ["title", "target"]
   options.forEach(option => {
    const node = this.getNode(option)
    if (node) attrs.push(`${option}="${node.content}"`)
   })
   return attrs
  }
  patternStartsAtWord = 2
  get pattern() {
   // If no pattern is provided, apply to the *entire* content.
   const words = this.getWordsFrom(this.patternStartsAtWord)
   return words.length ? words.join(" ") : this.parent.originalText
  }
emailLinkParser
 description A mailto link
 crux email
 extends linkParser
 javascript
  get attributes() {
   return [`href="mailto:${this.link}"`]
  }
quickLinkParser
 pattern ^https?\:
 extends linkParser
 cells urlCell
 javascript
  get link() {
   return this.firstWord
  }
  patternStartsAtWord = 1
classMarkupParser
 description Add a custom class to the parent element instead. If matching text provided, a span with the class will be added around the matching text.
 extends abstractMarkupParser
 cells keywordCell classNameCell
 crux class
 javascript
  tag = "span"
  get applyToParentElement() {
   return this.words.length === 2
  }
  getInserts(text) {
   // If no select text is added, set the class on the parent element.
   if (this.applyToParentElement) return []
   return super.getInserts(text)
  }
  get className() {
   return this.getWord(1)
  }
  get attributes() {
   return [`class="${this.className}"`]
  }
  get pattern() {
   const words = this.getWordsFrom(2)
   return words.length ? words.join(" ") : this.parent.content
  }
hoverNoteParser
 description Add a caveat viewable on hover on matching text. When you want to be sure you've thoroughly addressed obvious concerns but ones that don't warrant to distract from the main argument of the text.
 cruxFromId
 extends classMarkupParser
 catchAllParser lineOfTextParser
 cells keywordCell
 javascript
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get attributes() {
   return [`class="scrollHoverNote"`, `title="${this.hoverNoteText}"`]
  }
  get hoverNoteText() {
   return this.childrenToString().replace(/\n/g, " ")
  }
strikethroughParser
 cruxFromId
 extends abstractMarkupParser
 javascript
  tag = "s"
linkifyParser
 description Use this to disable linkify on the text.
 extends abstractAftertextDirectiveParser
 cruxFromId
 cells keywordCell booleanCell
wrapsOnParser
 cruxFromId
 description Enable `code`, *bold*, and _italics_ rules.
 extends abstractAftertextDirectiveParser
 javascript
  get shouldMatchAll() {
   return true
  }
  getMatches(text) {
   return [this.runPattern(text, "`", "code"), this.runPattern(text, "*", "strong"), this.runPattern(text, "_", "em")].filter(i => i).flat()
  }
  runPattern(text, delimiter, tag, attributes = "") {
   const escapedDelimiter = delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, "g")
   const delimiterLength = delimiter.length
   return [...text.matchAll(pattern)].map(match => {
    const { index } = match
    const endIndex = index + match[0].length
    return [
     { index, string: `<${tag + (attributes ? " " + attributes : "")}>`, endIndex, consumeStartCharacters: delimiterLength },
     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }
    ]
   })
  }
wrapParser
 cruxFromId
 cells keywordCell delimiterCell tagOrUrlCell
 catchAllCellType htmlAttributesCell
 extends wrapsOnParser
 description Define a custom wrap, for example "wrap _ em" would support: _italics_.
 javascript
  getMatches(text) {
   try {
    const delimiter = this.getWord(1)
    const tag = this.getWord(2)
    const attributes = this.getWordsFrom(3).join(" ")
    if (tag.startsWith("https:")) return this.runPattern(text, delimiter, "a", `href="${tag}"` + attributes)
    return this.runPattern(text, delimiter, tag, attributes)
   } catch (err) {
    console.error(err)
    return []
   }
   // Note: doubling up doesn't work because of the consumption characters.
  }
datelineParser
 cruxFromId
 description Gives your paragraph a dateline like "December 15, 2021 â€” The..."
 extends abstractAftertextDirectiveParser
 javascript
  getInserts() {
   let day = this.content || this.root.get("date")
   if (!day) return false
   try {
    const dayjs = require("dayjs")
    day = dayjs(day).format(`MMMM D, YYYY`)
   } catch (err) {
    console.error(err)
   }
   return [{ index: 0, string: `<span class="scrollDateline">${day} â€” </span>` }]
  }
dayjsParser
 description Advanced directive that evals some Javascript code in an environment including "dayjs".
 cruxFromId
 extends abstractAftertextDirectiveParser
 javascript
  getInserts() {
   const dayjs = require("dayjs")
   const days = eval(this.content)
   const index = this.parent.originalTextPostLinkify.indexOf("days")
   return [{ index, string: `${days} ` }]
  }
abstractMarkupParameterParser
 cells keywordCell
 cruxFromId
matchAllParser
 description Use this to match all occurrences of the text.
 extends abstractMarkupParameterParser
matchParser
 catchAllCellType integerCell
 description Use this to specify which index(es) to match.
 javascript
  get indexes() {
   return this.getWordsFrom(1).map(num => parseInt(num))
  }
 example
  aftertext
   hello ello ello
   bold ello
    match 0 2
 extends abstractMarkupParameterParser
abstractHtmlAttributeParser
 javascript
  compile() {
   return ""
  }
linkTargetParser
 extends abstractHtmlAttributeParser
 description If you want to set the target of the link. To "_blank", for example.
 crux target
 cells keywordCell anyCell
linkTitleParser
 description If you want to set the title of the link.
 crux title
 cells keywordCell
 catchAllCellType anyCell
 example
  * This report showed the treatment had a big impact.
   https://example.com/report This report.
    title The average growth in the treatment group was 14.2x higher than the control group.
blankLineParser
 description Blank lines compile to nothing in the HTML.
 cells blankCell
 javascript
  compile() {
   return this.parent.clearSectionStack()
  }
 pattern ^$
 tags doNotSynthesize
errorParser
 baseParser errorParser
chatLineParser
 catchAllCellType anyCell
 catchAllParser chatLineParser
lineOfCodeParser
 catchAllCellType codeCell
 catchAllParser lineOfCodeParser
commentLineParser
 catchAllCellType commentCell
cssLineParser
 catchAllCellType cssAnyCell
 catchAllParser cssLineParser
lineOfTextParser
 catchAllCellType stringCell
 boolean isTextParser true
htmlLineParser
 catchAllCellType htmlAnyCell
 catchAllParser htmlLineParser
stumpContentParser
 catchAllCellType anyCell
abstractLoopConfigParser
 cells keywordCell
 cruxFromId
 catchAllCellType stringCell
abstractItemsProviderParser
 cells keywordCell
loopLinesParser
 crux lines
 extends abstractItemsProviderParser
 description Iterate over the provided lines.
 catchAllParser loopLineParser
 loopLineParser
  catchAllCellType stringCell
 javascript
  get items() {
   return this.map(node => node.asString)
  }
loopWordsParser
 crux words
 extends abstractItemsProviderParser
 catchAllCellType stringCell
 description Iterate over the provided words.
 javascript
  get items() {
   return this.getWordsFrom(1)
  }
loopGroupsParser
 crux groups
 extends abstractItemsProviderParser
 catchAllCellType groupNameWithOptionalFolderCell
 description Set this to iterate over scroll files in a folder. Provide both the folder and group name like this: [folder]/[groupName]
 javascript
  get items() {
   return this.root.file.getFilesInGroupsForEmbedding(this.getWordsFrom(1))
  }
abstractPointConfigParser
 // todo: scoped parsers should support abstract types
 cruxFromId
 cells keywordCell
 catchAllCellType stringCell
 single
latParser
 cells keywordCell floatCell
 cruxFromId
 single
longParser
 cells keywordCell floatCell
 cruxFromId
 single
quoteLineParser
 catchAllCellType anyCell
 catchAllParser quoteLineParser
readingListItemParser
 cells urlCell
 catchAllCellType stringCell
 javascript
  compile() {
   const url = this.firstWord
   const [title, author] = this.content.split(" by ")
   return `<li><a href="${url}">${title ?? url}</a>${author ? ` by ${author}` : ""}</li>`
  }
scrollParser
 extensions scroll
 description Tools for thought thats compile to HTML.
 root
 inScope abstractScrollParser blankLineParser
 catchAllParser catchAllParagraphParser
 compilesTo html
 javascript
  setFile(file) {
   this.file = file
   return this
  }
  compile(compileSettings) {
    this.sectionStack = []
    return this.map(child => child.compile(compileSettings)).filter(i => i).join("\n") + this.clearSectionStack()
  }
  sectionStack = []
  clearSectionStack() {
   const result = this.sectionStack.join("")
   this.sectionStack = []
   return result
  }
  alreadyRequired = new Set()
  compileEmbeddedVersion(compileSettings) {
   this.sectionStack = []
   return this.map(child => (child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))
     .filter(i => i)
     .join("\n")
     .trim() + this.clearSectionStack()
  }
  get footnotes() {
   if (this._footnotes === undefined) this._footnotes = this.filter(node => node.isFootnote)
   return this._footnotes
  }
  file = {}
  get permalink() {
   return this.get("permalink") || this.file.permalink || ""
  }
 example
  # Hello world
  ## This is Scroll
  * It compiles to HTML.
  
  code
   // You can add code as well.
   print("Hello world")
rowParser
 catchAllCellType stringCell
 javascript
  toRow(columns, delimiter) {
   const words = this.getLine().split(delimiter)
   let str = ""
   let column = 0
   const columnCount = columns.length
   while (column < columnCount) {
    const col = columns[column]
    column++
    const content = columnCount === column ? words.slice(columnCount - 1).join(" ") : words[column - 1]
    if (col.isLink) continue
    let tagged = content
    const link = words[col.linkIndex]
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    else if (content && content.match(/^https?\:[^ ]+$/)) tagged = `<a href="${content}">${content}</a>`
    str += `<td>${tagged}</td>\n`
   }
   return str
  }
tagsParser
 // Todo: there may be a bug with having scoped parsers in abstract classes not being available to child classes.
 cells keywordCell booleanCell
 cruxFromId
treeRowContentParser
 description Any blob content in a cell.
 cells stringCell
 catchAllCellType stringCell
treeRowColumnParser
 catchAllParser treeRowContentParser
 description A columnName value pair, or just a columnName if the value is a text blob.
 cells idCell
 catchAllCellType stringCell
treeRowParser
 cells idCell
 description The root node of a row.
 catchAllParser treeRowColumnParser
 javascript
  toRow(columns) {
   let str = ""
   columns.forEach(col => {
    const node = this.getNode(col.name)
    if (col.isLink) return
    if (!node) {
     str += "<td></td>\n"
     return
    }
    const content = node.length ? node.childrenToString() : node.content
    let tagged = ""
    const link = this.get(col.name + "Link")
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    else if (node.length) tagged = `<pre>${content ?? ""}</pre>`
    else tagged = content ?? ""
    str += `<td>${tagged}</td>\n`
   })
   return str
  }