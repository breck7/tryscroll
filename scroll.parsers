// Related work:
 CSS is great for text selector ideas: https://www.w3schools.com/cssref/css_selectors.asp
 Roff has a lot of related markup ideas: https://www.systutorials.com/docs/linux/man/7-groff_man/
// Basic cell types
// Enum cell types
// String cell types
// Date cell types
// Numeric cell types
// Scroll cell types
// Link cell types
// File system cell types
// HTML cell types
// todo: copy the external library to folder so it works offline?
// Extend this if you want to create a new provider
// Some basic providers:
// The main measure parser. All measures should extend from this.
// String Measures
// URL Parsers
// Required ID measure which denotes a concept
// Numeric Measures
// Enum Measures
// Boolean Measures
// https://developers.google.com/search/docs/crawling-indexing/sitemaps/build-sitemap#text
// A joint effort from:
// - Breck Yunits https://github.com/breck7
// - Guillaume Papin https://github.com/Sarcasm
// Origin: https://github.com/breck7/scrollsdk/issues/120




















































































































































































wrapNameCell
 description What wraps are available to turn on?
 enum bold italics code katex
blankCell
anyCell
enumCell
 highlightScope constant.language
booleanCell
 enum true false
 extends enumCell
stringCell
 highlightScope string
wordCell
 highlightScope string
 description A non-empty single word string.
 regex .+
semanticVersionCell
 highlightScope string
 description A 3 part sem version string like 1.2.1
dateCell
 highlightScope string
numberCell
 highlightScope constant.numeric
integerCell
 extends numberCell
 highlightScope constant.numeric.integer
floatCell
 extends numberCell
 highlightScope constant.numeric.float
percentCell
 highlightScope constant.numeric.float
 extends stringCell
 // todo: this currently extends from stringCell b/c scrollsdk needs to be fixed. seems like if extending from number then the hard coded number typescript regex takes precedence over a custom regex
countCell
 extends integerCell
yearCell
 extends integerCell
keywordCell
 highlightScope keyword
commentCell
 highlightScope comment
delimiterCell
 description String to use as a delimiter.
 highlightScope string
codeCell
 highlightScope comment
bulletPointCell
 description Any token used as a bullet point such as "-" or "1." or ">"
 highlightScope keyword
personNameCell
 extends stringCell
urlCell
 highlightScope constant.language
absoluteUrlCell
 highlightScope constant.language
 regex (ftp|https?)://.+
emailAddressCell
 extends stringCell
permalinkCell
 highlightScope string
 description A string that doesn't contain characters that might interfere with most filesystems. No slashes, for instance.
filePathCell
 extends stringCell
tagOrUrlCell
 description An HTML tag or a url.
 highlightScope constant.language
htmlAttributesCell
 highlightScope comment
htmlTagCell
 highlightScope constant.language
 enum div span p a img ul ol li h1 h2 h3 h4 h5 h6 header nav section article aside main footer input button form label select option textarea table tr td th tbody thead tfoot br hr meta link script style title code
classNameCell
 highlightScope constant
htmlIdCell
 extends anyCell
cssAnyCell
 extends anyCell
groupNameCell
 extends permalinkCell
groupNameWithOptionalFolderCell
 description A group name optionally combined with a folder path. Only used when referencing groups, not in posts.
 extends stringCell
htmlAnyCell
 extends stringCell
measureNameCell
 extends keywordCell
 // A regex for column names for max compatibility with a broad range of data science tools:
 regex [a-zA-Z][a-zA-Z0-9]*
javascriptCell
 extends stringCell
scriptAnyCell
 extends anyCell
abstractScrollParser
 cells keywordCell
 javascript
  compileEmbeddedVersion(compileSettings) {
   return this.compile(compileSettings)
  }
  compileTxt() {
    return ""
  }
  getHtmlRequirements(compileSettings) {
    const {requireOnce} = this
    if (!requireOnce)
      return ""
    const set = compileSettings?.alreadyRequired || this.root.alreadyRequired
    if (set.has(requireOnce))
      return ""
    
    set.add(requireOnce)
    return requireOnce + "\n\n"
  }
abstractAftertextParser
 description Text followed by markup commands.
 extends abstractScrollParser
 inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser aftertextTagParser commentParser
 example
  aftertext
   Hello brave new world
   link home.com new
   bold brave new
   underline new world
   strike wor
 javascript
  get markupInserts() {
   const { originalTextPostLinkify } = this
   return this.filter(node => node.isMarkup)
    .map(node => node.getInserts(originalTextPostLinkify))
    .filter(i => i)
    .flat()
  }
  get originalText() {
   return this.content ?? ""
  }
  get originalTextPostLinkify() {
   const { originalText } = this
   const shouldLinkify = this.get("linkify") === "false" || originalText.includes("<a ") ? false : true
   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText
  }
  replaceNotes(originalText) {
   // Skip the replacements if there are no footnotes or the text has none.
   if (!this.root.footnotes.length || !originalText.includes("^")) return originalText
   this.root.footnotes.forEach((note, index) => {
    const needle = note.firstWord
    const {linkBack} = note
    if (originalText.includes(needle)) originalText = originalText.replace(new RegExp("\\" + needle + "\\b"), `<a href="#${note.anchorId}" class="scrollNoteLink" id="${linkBack}"><sup>${note.label}</sup></a>`)
   })
   return originalText
  }
  get text() {
   const { originalTextPostLinkify, markupInserts } = this
   let adjustment = 0
   let newText = originalTextPostLinkify
   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.
   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))
   markupInserts.forEach(insertion => {
    insertion.index += adjustment
    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0
    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0
    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)
    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters
   })
   return newText
  }
  tag = "p"
  get className() {
   if (this.get("classes"))
     return this.get("classes")
   const classLine = this.getNode("class")
   if (classLine && classLine.applyToParentElement) return classLine.content
   return this.defaultClassName
  }
  defaultClassName = "scrollParagraph"
  get isHidden() {
    return this.has("hidden")
  }
  compile(compileSettings) {
   if (this.isHidden) return ""
   this.compileSettings = compileSettings
   const { className } = this
   const classAttr = className ? `class="${this.className}"` : ""
   const tag = this.get("tag") || this.tag
   if (tag === "none") // Allow no tag for aftertext in tables
     return this.text
   return this.getHtmlRequirements(compileSettings) + `<${tag} ${this.divAttributes}${classAttr}>${this.text}</${tag}>`
  }
  get divAttributes() {
   const attrs = this.filter(node => node.isAttribute)
   return attrs.length ? attrs.map(node => node.divAttributes).join(" ") + " " : ""
  }
paragraphParser
 // todo Perhaps rewrite this from scratch and move out of aftertext.
 extends abstractAftertextParser
 catchAllCellType stringCell
 description A paragraph.
 cruxFromId
 javascript
  compile(compileSettings) {
   if (this.isHidden) return ""
   // Hacky, I know.
   const newLine = this.has("wrapsOn") ? undefined : this.appendLine("wrapsOn")
   const compiled = super.compile(compileSettings)
   if (newLine)
    newLine.destroy()
   return compiled
  }
  compileTxt() {
    const children = this.filter(node => node.compileTxt).map(node => node.compileTxt()).filter(i => i).join("\n")
    const dateline = this.getNode("dateline")
    return (dateline ? dateline.day + "\n\n" : "") + (this.originalText || "") + (children ? "\n " + children.replace(/\n/g, "\n ") : "")
  }
blinkParser
 description Useful when you have a client that always needs to find 1 thing they would like you to change.
 extends paragraphParser
 crux blink
 javascript
  compile() {
   return `<span class="scrollBlink">${super.compile()}</span>
    <script>
    setInterval(()=>{
        Array.from(document.getElementsByClassName("scrollBlink")).forEach(el => 
        el.style.color = el.style.color === "white" ? "black" : "white"
        )
    }, 2000)
    </script>`
  }
catchAllParagraphParser
 description Any top level line that doesn't match a keyword is treated as a paragraph node.
 extends paragraphParser
 cells stringCell
 javascript
  get originalText() {
   return this.getLine() || ""
  }
indentableParagraphParser
 extends paragraphParser
 inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser indentableParagraphParser
 javascript
  compile() {
   return (
    super.compile() +
    this.map(node => node.compile())
     .join("\n")
     .trim()
   )
  }
  compileTxt() {
    return this.getWord(0) + " " + super.compileTxt()
  }
checklistTodoParser
 extends indentableParagraphParser
 example
  [] Get milk
 description An incomplete checklist item.
 crux []
 string checked 
 javascript
  get text() {
   return `<div style="text-indent:${(this.getIndentLevel() - 1) * 20}px;"><input type="checkbox" ${this.checked} id="${this.id}"><label for="${this.id}">` + super.text + `</label></div>`
  }
  get id() {
   return this.get("id") || "item" + this._getUid()
  }
checklistDoneParser
 extends checklistTodoParser
 description A complete checklist list item.
 string checked checked
 crux [x]
 example
  [x] get milk
listAftertextParser
 extends indentableParagraphParser
 example
  - I had a _new_ thought.
 description A list item.
 crux -
 javascript
  defaultClassName = ""
  compile() {
   const index = this.getIndex()
   const parent = this.parent
   const nodeClass = this.constructor
   const isStartOfList = index === 0 || !(parent.nodeAt(index - 1) instanceof nodeClass)
   const isEndOfList = parent.length === index + 1 || !(parent.nodeAt(index + 1) instanceof nodeClass)
   const { listType } = this
   return (isStartOfList ? `<${listType} ${this.attributes}>` : "") + `${super.compile()}` + (isEndOfList ? `</${listType}>` : "")
  }
  get attributes() {
    return ""
  }
  tag = "li"
  listType = "ul"
abstractCustomListItemParser
 extends listAftertextParser
 javascript
  get requireOnce() {
    return `<style>\n.${this.constructor.name} li::marker {content: "${this.firstWord} ";}\n</style>`
  }
  get attributes() {
    return `class="${this.constructor.name}"`
  }
orderedListAftertextParser
 extends listAftertextParser
 description A list item.
 example
  1. Hello world
 pattern ^\d+\. 
 javascript
  listType = "ol"
  get attributes() { return ` start="${this.getWord(0)}"`}
quickQuoteParser
 crux >
 extends indentableParagraphParser
 javascript
  defaultClassName = "scrollQuote"
  tag = "blockquote"
expanderParser
 cruxFromId
 description Prints the section in an expandable html details and summary tag.
 extends paragraphParser
 javascript
  compile() {
   this.parent.sectionStack.push("</details>")
   return `<details>${super.compile()}`
  }
  compileTxt() {
    return this.content
  }
  tag = "summary"
  defaultClassName = ""
footnoteDefinitionParser
 description A footnote. Can also be used as section notes.
 extends paragraphParser
 boolean isFootnote true
 pattern ^\^.+$
 // We need to quickLinks back in scope because there is currently a bug in ScrollSDK/parsers where if a parser extending a parent class has a child parser defined, then any regex parsers in the parent class will not be tested unless explicitly included in scope again.
 inScope quickLinkParser
 labelParser
  description If you want to show a custom label for a footnote. Default label is the note definition index.
  cruxFromId
  cells keywordCell
  catchAllCellType stringCell
 javascript
  get divAttributes() {
   return super.divAttributes + ` id="${this.anchorId}"`
  }
  get anchorId() {
   return `note${this.noteDefinitionIndex}`
  }
  get label() {
   // In the future we could allow common practices like author name
   return this.get("label") || `[${this.noteDefinitionIndex}]`
  }
  get linkBack() {
   return `noteUsage${this.noteDefinitionIndex}`
  }
  get text() {
   return `<a class="scrollFootNoteUsageLink" href="#noteUsage${this.noteDefinitionIndex}">${this.label}</a> ${super.text}`
  }
  get noteDefinitionIndex() {
   return this.parent.footnotes.indexOf(this) + 1
  }
  compileTxt() {
    return this.getWord(0) + ": " + super.compileTxt()
  }
abstractHeaderParser
 extends paragraphParser
 javascript
  compile(compileSettings) {
   if (this.isHidden) return ""
   this.parent.sectionStack.push("</div>")
   return `<div class="scrollSection">` + super.compile(compileSettings)
  }
  compileTxt() {
    const line = super.compileTxt()
    return line + "\n" + "=".repeat(line.length)
  }
h1Parser
 description Compiles to an html h1 tag.
 extends abstractHeaderParser
 crux #
 javascript
  tag = "h1"
h2Parser
 description Compiles to an html h2 tag.
 extends abstractHeaderParser
 crux ##
 javascript
  tag = "h2"
h3Parser
 description Compiles to an html h3 tag.
 extends abstractHeaderParser
 crux ###
 javascript
  tag = "h3"
h4Parser
 description Compiles to an html h4 tag.
 extends abstractHeaderParser
 crux ####
 javascript
  tag = "h4"
questionAftertextParser
 description A question.
 extends h4Parser
 crux ?
 javascript
  defaultClassName = "scrollQuestion"
h5Parser
 description Compiles to an html h5 tag.
 extends abstractHeaderParser
 crux #####
 javascript
  tag = "h5"
printTitleParser
 description Print the page title.
 extends abstractHeaderParser
 cruxFromId
 javascript
  compile(compileSettings) {
   // Hacky, I know.
   const {content} = this
   if (content === undefined)
    this.setContent(this.parent.file.title)
   const { permalink } = this.parent.file
   if (!permalink) {
    this.setContent(content) // Restore it as it was.
    return super.compile(compileSettings)
   }
   const newLine = this.appendLine(`link ${permalink}`)
   const compiled = super.compile(compileSettings)
   newLine.destroy()
   this.setContent(content) // Restore it as it was.
   return compiled
  }
  get originalText() {
   return this.content ?? this.parent.file.title ?? ""
  }
  defaultClassName = "scrollTitle"
  tag = "h1"
captionAftertextParser
 description An optional caption to accompany the resource.
 crux caption
 extends paragraphParser
quickParagraphParser
 crux *
 extends paragraphParser
 example
  * I had a _new_ idea.
thinColumnsParser
 extends abstractAftertextParser
 cruxFromId
 catchAllCellType integerCell
 description Start a multicolumn grid.
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  columnWidth = 35
  columnGap = 20
  compile() {
   const {columnWidth, columnGap} = this
   const maxColumns = parseInt(this.getWord(1) ?? 10)
   const maxTotalWidth = maxColumns * columnWidth + (maxColumns - 1) * columnGap
   // Starting the columns always first clears the section stack.
   return this.parent.clearSectionStack() + `<div class="scrollColumns" style="column-width:${columnWidth}ch;column-count:${maxColumns};max-width:${maxTotalWidth}ch;">`
  }
startColumnsParser
 description Deprecated. Use "thinColumns" instead.
 boolean isDeprecated true
 extends thinColumnsParser
wideColumnsParser
 extends thinColumnsParser
 description Start a double wide column.
 javascript
  columnWidth = 90
mediumColumnsParser
 extends thinColumnsParser
 javascript
  columnWidth = 65
endColumnsParser
 extends abstractAftertextParser
 cruxFromId
 description End a multicolumn grid.
 javascript
  compile() {
   return "</div>"
  }
  compileEmbeddedVersion() {
   return ""
  }
abstractDinkusParser
 extends abstractAftertextParser
 string dinkus *
 boolean isDinkus true
 javascript
  compile() {
   return `<div class="dinkus"><span>${this.dinkus}</span></div>`
  }
  compileTxt() {
    return this.getLine()
  }
horizontalRuleParser
 crux ---
 description Prints an html <hr> tag
 extends abstractDinkusParser
 javascript
  compile() {
   return `<hr>`
  }
dinkusParser
 crux ***
 description Prints a centered *
 extends abstractDinkusParser
endOfPostDinkusParser
 extends abstractDinkusParser
 crux ****
 string dinkus ⁂
loopParser
 extends abstractAftertextParser
 cells keywordCell
 description Iterate over files, lines or words, evaluating code and joining the resulting HTML.
 cruxFromId
 inScope abstractItemsProviderParser
 joinParser
  extends abstractLoopConfigParser
  description HTML to use to join the items.
 limitParser
  extends abstractLoopConfigParser
  description HTML to use to join the items.
 javascriptParser
  extends abstractLoopConfigParser
  description Javascript to execute for each file in the loop.
 javascript
  compile() {
   const code = this.get("javascript")
   const joinWith = this.get("join") ?? ""
   try {
    const limit = this.get("limit")
    let items = this.items
    if (limit) items = items.slice(0, parseInt(limit))
    return items.map((item, index) => eval(code)).join(joinWith)
   } catch (err) {
    console.error(err)
    return ""
   } finally {
    this.teardown()
   }
  }
  get items() {
   const provider = this.getChildInstancesOfParserId("abstractItemsProviderParser")[0]
   return provider ? provider.items : []
  }
  teardown() {}
loremIpsumParser
 extends abstractAftertextParser
 cruxFromId
 description Generate dummy text.
 catchAllCellType integerCell
 javascript
  compile() {
   const text = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`
   return text.repeat(this.getWord(1) ? parseInt(this.getWord(1)) : 1)
  }
printSnippetsParser
 // todo: why are we extending AT here and not loops? Is it for class/id etc?
 extends abstractAftertextParser
 cruxFromId
 cells keywordCell
 catchAllCellType groupNameWithOptionalFolderCell
 description Prints the snippets of all files in the named group(s).
 example
  printSnippets index
 javascript
  makeSnippet(file, compileSettings) {
    const {scrollProgram, endSnippetIndex} = file
    if (endSnippetIndex === -1) return scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml
    const linkRelativeToCompileTarget = compileSettings.relativePath + file.permalink
    const joinChar = "\n"
    const html = scrollProgram
        .map((child, index) => (index >= endSnippetIndex ? "" : child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))
        .filter(i => i)
        .join(joinChar)
        .trim() +
      `<a class="scrollContinueReadingLink" href="${linkRelativeToCompileTarget}">Continue reading...</a>`
    return html
  }
  get files() {
   return this.parent.file.getFilesInGroupsForEmbedding(this.getWordsFrom(1), this.has("limit") ? parseInt(this.get("limit")) : undefined)
  }
  compile() {
   const alreadyRequired = this.root.alreadyRequired
   const snippets = this.files.map(file => {
    const compileSettings = {relativePath: file.relativePath, alreadyRequired }
    return `<div class="scrollSnippetContainer">${this.makeSnippet(file.file, compileSettings)}</div>`
    }).join("\n\n")
   return `<div class="scrollColumns" style="column-width:35ch;">${snippets}</div>`
  }
  compileTxt() {
   return this.files.map(file =>  {
    const title = file.file.title
    const ruler = "=".repeat(title.length)
    // Note: I tried to print the description here but the description generating code needs work.
    return `${title}\n${ruler}\n${file.file.date}\n${file.file.absoluteLink}`
   }).join("\n\n")
  }
printFullSnippetsParser
 extends printSnippetsParser
 cruxFromId
 description Prints the full contents of files that are in the named group.
 javascript
  makeSnippet(file, compileSettings) {
   return file.scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml
  }
printViewSourceParser
 description Print a "View source" link.
 extends abstractAftertextParser
 cruxFromId
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const file = this.parent.file
   const { viewSourceUrl } = file
   return file.compileStumpCode(`p
   class scrollViewSource doNotPrint
   a View source
    href ${viewSourceUrl}`)
  }
printViewSourceBadgeParser
 description Print a "View source" badge in top right.
 extends abstractAftertextParser
 cruxFromId
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const file = this.parent.file
   const { viewSourceUrl, SVGS } = file
   return file.compileStumpCode(`div
   class scrollViewSourceBadge doNotPrint
   a ${SVGS.git}
    href ${viewSourceUrl}`)
  }
printAuthorParser
 description Prints a byline with the author's name and optionally a link to them.
 extends abstractScrollParser
 cruxFromId
 // todo: we need pattern matching added to sdk to support having no params or a url and personNameCell
 cells keywordCell
 catchAllCellType anyCell
 example
  // With Link:
  printAuthor https://breckyunits.com Breck Yunits
  // No link:
  printAuthor  Breck Yunits
 javascript
  compile() {
   const {link, name} = this
   return `<div class="scrollByLine">by <a ${link ? `href="${link}"` : ""}>${name}</a></div>`
  }
  get link() {
    return this.getWord(1) || this.parent.getNode("author")?.getWord(1)
  }
  get name() {
    return this.getWordsFrom(2).join(" ") || this.parent.getNode("author")?.getWordsFrom(2).join(" ")
  }
  compileTxt() {
    return `by ${this.name}`
  }
byLineParser
 extends printAuthorParser
 boolean isDeprecated true
 description DEPRECATED! Use "printAuthor" instead.
abstractTopLevelSingleMetaParser
 description Use these keywords once per file.
 extends abstractScrollParser
 inScope slashCommentParser
 cruxFromId
 cells keywordCell
 javascript
  isTopMatter = true
  isSetterParser = true
  compile() {
   return ""
  }
authorParser
 cells keywordCell urlCell
 catchAllCellType personNameCell
 description Set the author(s) for a post. Prints nothing by itself, but is printed with the title in text mode and in various metadata outputs.
 extends abstractTopLevelSingleMetaParser
dateParser
 catchAllCellType dateCell
 description Date this file was first published.
 extends abstractTopLevelSingleMetaParser
abstractFileSettingParser
 extends abstractTopLevelSingleMetaParser
 cells keywordCell
 javascript
  compile() {
   return ""
  }
emailParser
 description Email address for the site owner.
 extends abstractFileSettingParser
 cruxFromId
 cells keywordCell emailAddressCell
abstractUrlSettingParser
 extends abstractFileSettingParser
 cells keywordCell urlCell
 cruxFromId
gitParser
 description A link to the web Git UI for this site.
 extends abstractUrlSettingParser
canonicalUrlParser
 description Canonical URL for SEO. If undefined Scroll generates this from the baseUrl and permalink.
 extends abstractUrlSettingParser
openGraphImageParser
 description URL for Open Graph Image. https://ogp.me/. If not defined, Scroll will try to generate it's own using the first image tag on your page.
 extends abstractUrlSettingParser
baseUrlParser
 description Root url of this published site on the web. Must be provided for RSS Feeds and OpenGraph tags to work, but has no effect locally.
 extends abstractUrlSettingParser
downloadUrlParser
 description In the default Scroll theme the download button will link to this.
 extends abstractUrlSettingParser
homeUrlParser
 description In the default Scroll theme the home button will link to "index.html". You can override this with this setting.
 extends abstractUrlSettingParser
rssFeedUrlParser
 description URL for RSS feed, if any.
 extends abstractUrlSettingParser
viewSourceBaseUrlParser
 description The base link to be used to generate all of the git "View source" links. If not provided, the scroll filename will be used.
 extends abstractUrlSettingParser
abstractSiteStringSettingParser
 extends abstractFileSettingParser
 catchAllCellType stringCell
 cruxFromId
groupsParser
 description Add this file to zero or more groups.
 cruxFromId
 example
  groups index.html
 extends abstractTopLevelSingleMetaParser
 cells keywordCell
 catchAllCellType groupNameCell
importOnlyParser
 description Mark a file as not one to build. This line will be not be imported into the importing file.
 cruxFromId
 extends abstractTopLevelSingleMetaParser
 javascript
  compile() {
   return ""
  }
htmlLangParser
 cells keywordCell stringCell
 description The lang attribute for the <html lang=""> tag. If not specified will be "en". See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang
 extends abstractTopLevelSingleMetaParser
openGraphDescriptionParser
 catchAllCellType stringCell
 crux description
 description Description for Open Graph. https://ogp.me/. If not defined, Scroll will try to generate it's own.
 extends abstractTopLevelSingleMetaParser
permalinkParser
 description When compiling, Scroll will save this file to {permalink}
 extends abstractTopLevelSingleMetaParser
 cells keywordCell permalinkCell
relatedScrollFilesParser
 extends abstractTopLevelSingleMetaParser
 catchAllCellType permalinkCell
 crux related
 description Set any related posts. Prints nothing by itself.
 example
  ...
  That's all I have to say about hiking.
  related fishing camping
  # Related Posts
  printRelatedList
pageTitleParser
 catchAllCellType personNameCell
 crux title
 description Title of the page for meta tags. Prints nothing by itself. Use "printTitle" to print this title in a big HTML tag.
 extends abstractTopLevelSingleMetaParser
viewSourceUrlParser
 catchAllCellType urlCell
 description Use this to override the link to the source code for a scroll file.
 extends abstractTopLevelSingleMetaParser
abstractBuildCommandParser
 extends abstractScrollParser
 cruxFromId
 cells keywordCell
 catchAllCellType filePathCell
 inScope slashCommentParser
 javascript
  isTopMatter = true
  compile() {
   return ""
  }
buildConceptsParser
 cruxFromId
 description Compiles concepts to a data format(s) and save to disk.
 extends abstractBuildCommandParser
 sortByParser
  cruxFromId
  cells keywordCell anyCell
buildCssParser
 description Compile document to CSS and save to disk.
 extends abstractBuildCommandParser
buildHtmlParser
 description Compile document to html and save to disk.
 extends abstractBuildCommandParser
buildMeasuresParser
 cruxFromId
 description Compile measure metadata to a data format(s) and save to disk.
 extends abstractBuildCommandParser
 sortByParser
  cruxFromId
  cells keywordCell anyCell
buildRssParser
 description Compile metadata on a group(s) of documents to RSS and save to disk.
 extends abstractBuildCommandParser
buildJsParser
 description Compile document to JS and save to disk.
 extends abstractBuildCommandParser
buildTxtParser
 description Compile document to plain text and save to disk.
 extends abstractBuildCommandParser
chatParser
 description A dialogue between two people.
 catchAllParser chatLineParser
 cruxFromId
 extends abstractScrollParser
 javascript
  compile() {
   return this.map((line, index) => `<div style="text-align: ${index % 2 ? "right" : "left"};" class="scrollChat ${index % 2 ? "scrollChatRight" : "scrollChatLeft"}"><span>${line.asString}</span></div>`).join("")
  }
  compileTxt() {
    return this.childrenToString()
  }
codeParser
 description A code block.
 catchAllParser lineOfCodeParser
 extends abstractScrollParser
 javascript
  compile() {
   return `<code class="scrollCodeBlock">${this.childrenToString().replace(/\</g, "&lt;")}</code>`
  }
  compileTxt() {
    return this.childrenToString()
  }
 cruxFromId
codeWithLanguageParser
 description Use this to specify the language of the code block, such as csvCode or rustCode.
 extends codeParser
 pattern ^[a-zA-Z0-9_]+Code$
abstractScrollWithRequirementsParser
 extends abstractScrollParser
 cruxFromId
 javascript
  compile(compileSettings) {
    return this.getHtmlRequirements(compileSettings) + this.compileInstance()
  }
copyButtonsParser
 extends abstractScrollWithRequirementsParser
 description Make code snippets copyable.
 javascript
  compileInstance() {
   return ""
  }
 string requireOnce
  <script>
  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollCodeBlock").forEach(block =>
   {
    if (!navigator.clipboard) return
    const button = document.createElement("span")
    button.classList.add("scrollCopyButton")
    block.appendChild(button)
    button.addEventListener("click", async () => {
      await navigator.clipboard.writeText(block.innerText)
      button.classList.add("scrollCopiedButton")
    })
   }
  ))
  </script>
katexParser
 extends abstractScrollWithRequirementsParser
 catchAllCellType codeCell
 catchAllParser lineOfCodeParser
 description Use the KaTex library to typeset math.
 string copyFromExternal katex.min.css katex.min.js
 string requireOnce
  <link rel="stylesheet" href="katex.min.css">
  <script defer src="katex.min.js"></script>
  <script>
  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollKatex").forEach(el =>
   {
    katex.render(el.innerText, el, {
        throwOnError: false
    });
   }
  ))
  </script>
 javascript
  compileInstance() {
   const id = this._getUid()
   const content = this.content === undefined ? "" : this.content
   return `<div class="scrollKatex" id="${id}">${content + this.childrenToString()}</div>`
  }
  compileTxt() {
    return ( this.content ? this.content : "" )+ this.childrenToString()
  }
mapParser
 inScope latParser longParser
 zoomParser
  cells keywordCell integerCell
  cruxFromId
  single
 heightParser
  cells keywordCell floatCell
  cruxFromId
  single
 pointParser
  cells keywordCell
  inScope latParser longParser
  cruxFromId
  titleParser
   extends abstractPointConfigParser
  descriptionParser
   extends abstractPointConfigParser
 extends abstractScrollWithRequirementsParser
 description Uses LeafletJs
 string copyFromExternal leaflet.css leaflet.js
 string requireOnce
  <link rel="stylesheet" href="leaflet.css">
  <script src="leaflet.js"></script>
 javascript
  compileInstance() {
   const height = 500
   const id = this._getUid()
   return `<div id="map${id}" style="height: ${height}px;"></div>
  <script>
   {
    const lat = ${this.get("lat") ?? 37.8}
    const long = ${this.get("long") ?? 4}
    const zoomLevel = ${this.get("zoom") ?? 4}
    const points = ${JSON.stringify(this.findNodes("point").map(node => node.toObject()))}
    const map = L.map("map${id}").setView([lat, long], zoomLevel)
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
     attribution: '<a href="https://www.openstreetmap.org/">OpenStreetMap</a>',
     maxZoom: 18
    }).addTo(map)
    points.forEach(point => {
     L.marker([point.lat, point.long])
      .addTo(map)
      .bindPopup("<b>" +point.title + "</b><br />" + point.description)
    })
   }
  </script>`
  }
helpfulNotFoundParser
 extends abstractScrollWithRequirementsParser
 catchAllCellType filePathCell
 string copyFromExternal helpfulNotFound.js
 description Add a helpful not found element to the page.
 javascript
  compileInstance() {
   return `<style>#helpfulNotFound{margin: 100px 0;}</style><h1 id="helpfulNotFound"></h1><script defer src="/helpfulNotFound.js"></script><script>document.addEventListener("DOMContentLoaded", () => new NotFoundApp('${this.content}'))</script>`
  }
abstractPlotParser
 description Use Plot from observablehq.
 extends abstractScrollWithRequirementsParser
 string iris
  sepal_length,sepal_width,petal_length,petal_width,species
  6.1,3,4.9,1.8,virginica
  5.6,2.7,4.2,1.3,versicolor
  5.6,2.8,4.9,2,virginica
  6.2,2.8,4.8,1.8,virginica
  7.7,3.8,6.7,2.2,virginica
  5.3,3.7,1.5,0.2,setosa
  6.2,3.4,5.4,2.3,virginica
  4.9,2.5,4.5,1.7,virginica
  5.1,3.5,1.4,0.2,setosa
  5,3.4,1.5,0.2,setosa
 string copyFromExternal d3.js plot.js
 string requireOnce
  <script src="d3.js"></script>
  <script src="plot.js"></script>
 example
  plot
 javascript
  compileInstance() {
   const id = "plot" + this._getUid()
   return `<div id="${id}"></div><script>
   {
    let loadChart = async () => {
    const data = ${this.dataCode}
    const get = (col, index ) => col !== "undefined" ? col : (index === undefined ? undefined : Object.keys(data[0])[index])
    document.querySelector("#${id}").append(Plot.plot(${this.plotOptions}))
    }
    loadChart()
    }
    </script>`
  }
  get marks() {
    // just for testing purposes
    return `Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: d3.randomNormal()}))`
  }
  get dataCode() {
    return '[]'
  }
  get plotOptions() {
    return `{
      title: "${this.get("title") || ""}",
      subtitle: "${this.get("subtitle") || ""}",
      caption: "${this.get("caption") || ""}",
      symbol: {legend: ${this.has("symbol")}},
      color: {legend: ${this.has("fill")}},
      grid: ${this.get("grid") !== "false"},
      marks: [${this.marks}],
    }`
  }
scatterplotParser
 extends abstractPlotParser
 // todo: make copyFromExternal work with inheritance
 string copyFromExternal d3.js plot.js
 javascript
  get dataCode() {
    let data = this.iris
    const dataset = this.getNode("data")
    const datasetContent = dataset?.content
    const isUrl = !!datasetContent?.match(/^https?:/)
    const fileExtension = datasetContent ? datasetContent.split(".").pop() : "csv"
    if (dataset?.length)
      data = dataset.childrenToString()
    else if (datasetContent && !isUrl) {
      const { Disk } = require("scrollsdk/products/Disk.node.js")
      const path = require("path")
      const {file} = this.parent
      data = Disk.read(path.join(file.folderPath, datasetContent))
    }
    let dataString = `d3.${fileExtension}Parse(\`${data}\`, d3.autoType)`
    if (isUrl)
      dataString = `await d3.${fileExtension}("${datasetContent}")`
    return dataString
  }
  get marks() {
    const x = this.get("x")
    const y = this.get("y")
    const text = this.get("label")
    return `Plot.dot(data, {
      x: get("${x}", 0),
      y: get("${y}", 1),
      r: get("${this.get("radius")}"),
      fill: get("${this.get("fill")}"),
      tip: true,
      symbol: get("${this.get("symbol")}")} ), Plot.text(data, {x: get("${x}",0), y: get("${y}", 1), text: "${text}", dy: -6, lineAnchor: "bottom"})`
  }
slideshowParser
 description Turns a page into a slideshow. A dinkus (***) separates slides. Left and right arrows navigate.
 extends abstractScrollWithRequirementsParser
 string copyFromExternal jquery-3.7.1.min.js slideshow.js
 example
  slideshow
  Why did the cow cross the road?
  ***
  Because it wanted to go to the MOOOO-vies.
  ***
  THE END
  ****
 javascript
  compile() {
   return `<style>html {font-size: var(--base-font-size, 28px);} body {margin: auto; width: 500px;}.slideshowNav{text-align: center; margin-bottom:20px; font-size: 14px;} a{text-decoration: none;</style><script defer src="jquery-3.7.1.min.js"></script><div class="slideshowNav"></div><script defer src="slideshow.js"></script>`
  }
sparklineParser
 description Generate a sparkline.
 extends abstractScrollWithRequirementsParser
 example
  sparkline 1 2 3 4 5
 string copyFromExternal sparkline.js
 string requireOnce <script src="sparkline.js"></script>
 catchAllCellType numberCell
 javascript
  compileInstance() {
   const id = "spark" + this._getUid()
   const data = this.content.split(" ").map(str => parseFloat(str))
   const start = this.has("start") ? parseInt(this.get("start")) : 0
   const width = this.get("width") || 100
   const height = this.get("height") || 30
   const lineColor = this.get("color") || "black"
   return `<span id="${id}"></span><script>new Sparkline(document.getElementById("${id}"), {dotRadius: 0, width: ${width}, height: ${height}, lineColor: "${lineColor}", tooltip: (value,index) => ${start} + index + ": " + value}).draw(${JSON.stringify(data)})</script>`
  }
tableSearchParser
 extends abstractScrollWithRequirementsParser
 string copyFromExternal jquery-3.7.1.min.js dataTables.dataTables.min.css dataTables.min.js tableSearch.js
 string requireOnce
  <script defer src="jquery-3.7.1.min.js"></script>
  <style>.dt-search{font-family: "SF Pro", "Helvetica Neue", "Segoe UI", "Arial";}</style>
  <link rel="stylesheet" href="dataTables.dataTables.min.css">
  <script defer src="dataTables.min.js"></script>
  <script defer src="tableSearch.js"></script>
 description Add table search and sort to all tables on the page.
 javascript
  compileInstance() {
   return ""
  }
abstractCommentParser
 description Comments do not appear in the compiled HTML.
 catchAllCellType commentCell
 cells commentCell
 extends abstractScrollParser
 baseParser blobParser
 javascript
  compile() {
   return ``
  }
 catchAllParser commentLineParser
commentParser
 extends abstractCommentParser
 cruxFromId
slashCommentParser
 extends commentParser
 crux //
counterpointParser
 description A counterpoint. Will not show up in the compiled HTML.
 extends commentParser
 crux !
printConceptsParser
 description Print the concepts in a page into an HTML table.
 cruxFromId
 extends abstractCommentParser
 javascript
   compile() {
   // A hacky but simple way to do this for now.
   const node = this.appendSibling("table \t", this.parent.file.compileConcepts("concepts.tsv", this.get("sortBy")))
   const html = node.compile()
   node.destroy()
   return html
   }
thanksToParser
 description A place to store data on reviewers who helped improve a post (and a reminder to seek feedback!). Does not appear in compiled HTML.
 extends abstractCommentParser
 cruxFromId
printMeasuresParser
 description Print measures statistics in a page into an HTML table.
 cruxFromId
 extends abstractCommentParser
 javascript
   compile() {
   // A hacky but simple way to do this for now.
   const node = this.appendSibling("table \t", this.parent.file.compileMeasures("tsv"))
   const html = node.compile()
   node.destroy()
   return html
   }
tabularDataParser
 description Root lines with tabs are parsed as tsv data and printed as tables.
 pattern \t
 extends abstractCommentParser
 javascript
  compileTxt() {
    return ""
  }
  get headerNode() {
    return this.isFirst ? this : this.previous.headerNode
  }
  compile() {
    return ""
  }
  get isFirst() {
    return !this.previous.isTabularData
  }
  get lastNode() {
    if (this.next.isTabularData && this.next.lineNumber)
      return this.next.lastNode
    return this
  }
  applyAftertext(aftertext) {
    const node = this.parent.appendLineAndChildren("* " + this.getLine(), aftertext + "\ntag none")
    const html = node.compile()
    node.destroy()
    return html
  }
  isTabularData = true
 example
  // The below lines will print a table
  printTable
  Index Name
  1 Thermos
loadConceptsParser
 description Load all concepts in all scroll files in a folder and remove any "import" statements.
 extends abstractScrollParser
 cruxFromId
 cells keywordCell filePathCell
 javascript
  build() {
   const { Disk } = require("scrollsdk/products/Disk.node.js")
   const path = require("path")
   const {file} = this.parent
   const folder = path.join(file.folderPath, this.getWord(1))
   const ONE_BIG_FILE = Disk.getFiles(folder).filter(file => file.endsWith(".scroll")).map(Disk.read).filter(str => /^id /mg.test(str)).join("\n\n").replace(/import .+/g, "")
    this.parent.concat(ONE_BIG_FILE)
   //console.log(ONE_BIG_FILE)
  }
  compile() {
    return ""
  }
cssParser
 extends abstractScrollParser
 description Prints CSS content wrapped in a style tag.
 cruxFromId
 catchAllParser cssLineParser
 catchAllCellType cssAnyCell
 javascript
  compile() {
   return `<style>${this.css}</style>`
  }
  get css() {
    return this.content ?? this.childrenToString()
  }
  compileCss() {
    return this.css
  }
abstractPostLoopParser
 description Do something with all posts. Takes an optional list of folder/group names.
 extends abstractScrollParser
 cruxFromId
 cells keywordCell
 catchAllCellType groupNameWithOptionalFolderCell
 javascript
  get files() {
   return this.root.file.getFilesInGroupsForEmbedding(this.getWordsFrom(1))
  }
printFeedParser
 description Prints out the RSS feed for a group.
 extends abstractPostLoopParser
 example
  printFeed index
  printFeed cars/index
  buildRss feed.xml
 javascript
  compile() {
   const dayjs = require("dayjs")
   const file = this.root.file
   const files = this.files.map(file => file.file)
   const { title, baseUrl, description } = file
   return `<?xml version="1.0" encoding="ISO-8859-1" ?>
  <rss version="2.0">
  <channel>
   <title>${title}</title>
   <link>${baseUrl}</link>
   <description>${description}</description>
   <lastBuildDate>${dayjs().format("ddd, DD MMM YYYY HH:mm:ss ZZ")}</lastBuildDate>
   <language>en-us</language>
  ${files.map(file => file.toRss()).join("\n")}
  </channel>
  </rss>`
  }
  compileTxt() {
    return this.compile()
  }
printCsvParser
 description Prints out a group as a CSV.
 extends printFeedParser
 example
  printCsv index
  buildTxt posts.csv
 javascript
  compile() {
   const file = this.root.file
   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1)).map(file => file.file)
   const header = file.csvFields
   return `${header.join(",")}\n${files.map(file => file.toCsv()).join("\n")}`
  }
printSourceParser
 description Prints out the source code for each file in a group.
 extends printFeedParser
 example
  printSource index
  buildTxt source.txt
 javascript
  compile() {
   const file = this.root.file
   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1)).map(file => file.file)
   return `${files.map(file => file.filePath + "\n " + file.originalScrollCode.replace(/\n/g, "\n ") ).join("\n")}`
  }
printSearchTableParser
 description Prints out all pages into an HTML table that can be searched.
 extends abstractPostLoopParser
 example
  printSearchTable
  tableSearch
 javascript
  compile() {
   const file = this.root.file
   const files = this.files
   const data = files.map(file => file.file.toSearchTsvRow(file.relativePath)).join("\n")
   // A hacky but simple way to do this for now.
   const node = this.appendSibling("table \t", "title titleLink text date wordCount minutes".replace(/ /g, "\t") + "\n" + data)
   const html = node.compile()
   node.destroy()
   return html
  }
printSiteMapParser
 extends abstractPostLoopParser
 description Prints out a plain text sitemap.
 example
  baseUrl http://test.com
  printSiteMap
 javascript
  compile() {
   const file = this.root.file
   const { baseUrl } = file
   return this.files.map(file => baseUrl + file.relativePath + file.file.permalink).join("\n")
  }
  compileTxt() {
    return this.compile()
  }
dashboardParser
 description Display key stats in a big font.
 catchAllParser rowParser
 cruxFromId
 extends abstractScrollParser
 example
  dashboard
   #2 Popularity
   30 Years Old
   $456 Revenue
 javascript
  get tableBody() {
   const items = this.topDownArray
   let str = ""
   for (let i = 0; i < items.length; i = i + 3) {
    str += this.makeRow(items.slice(i, i + 3))
   }
   return str
  }
  makeRow(items) {
   return `<tr>` + items.map(node => `<td>${node.firstWord}<span>${node.content}</span></td>`).join("\n") + `</tr>\n`
  }
  compile() {
   return `<table class="scrollDashboard">${this.tableBody}</table>`
  }
  compileTxt() {
    return this.childrenToString()
  }
printDateParser
 extends abstractScrollParser
 cruxFromId
 cells keywordCell
 javascript
  compile() {
   return `<div style="text-align: center;" class="scrollDateline">${this.day}</div>`
  }
  get day() {
   let day = this.content || this.root.get("date") || this.root.file?.date
   if (!day) return ""
   try {
    const dayjs = require("dayjs")
    return dayjs(day).format(`MMMM D, YYYY`)
   } catch (err) {
    console.error(err)
   }
   return day || ""
  }
  compileTxt() {
    return this.day
  }
belowAsCodeParser
 description Print the Scroll code of the next node.
 extends abstractScrollParser
 catchAllCellType integerCell
 cruxFromId
 javascript
  method = "next"
  get code() {
   const { method } = this
   let code = ""
   
   let nodes = []
   let next = this[method]
   let {howMany} = this
   while (howMany) {
    nodes.push(next)
    next = next[method]
    howMany--
   }
   if (this.reverse) nodes.reverse()
   return nodes.map(node => node.asString).join("\n")
  }
  reverse = false
  compile() {
   return `<code class="scrollCodeBlock">${this.code.replace(/\</g, "&lt;")}</code>`
  }
  get howMany() {
    let howMany = parseInt(this.getWord(1))
   if (!howMany || isNaN(howMany)) howMany = 1
   return howMany
  }
belowAsCodeUntilParser
 description Same as belowAsCode, except you can provide a search string to find the line where printing should stop.
 extends belowAsCodeParser
 catchAllCellType anyCell
 javascript
  get howMany() {
    let howMany = 1
    const query = this.content
    let node = this.next
    while (node !== this) {
      if (node.getLine().startsWith(query))
        return howMany
      node = node.next
      howMany++
    }
    return howMany
  }
aboveAsCodeParser
 description Print the Scroll code for the previous node.
 extends belowAsCodeParser
 javascript
  method = "previous"
  reverse = true
abstractThemeCssParser
 description Extend this to create a Scroll CSS theme.
 extends abstractScrollParser
 inScope themeTagsParser
 cruxFromId
 catchAllCellType stringCell
 string scrollStyles
  figure
   margin 0
   padding 0
  .dropcap:first-letter
   font-size 3rem
   line-height .9em
   margin-right .125rem
   display block
   float left
  .dinkus
   text-align center
   padding 1rem
   span
    vertical-align sub
  details
   margin-top 10px
  summary
   font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"
   cursor pointer
  .scrollCaptionedFigure
   display block
   break-inside avoid
   text-align center
   img
    max-width 100%
    height auto
    margin-top .1875rem
   figcaption
    font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"
    font-size .8rem
    .scrollParagraph
     margin-top 0
  .scrollCodeBlock
   overflow auto
   font-size .8rem
   hyphens none
   white-space pre
   break-inside avoid
   display block
   margin .5rem 0
   padding .5rem
   border-radius 0
   position relative
  .scrollCodeBlock:hover
   .scrollCopyButton
    opacity .5
   .scrollCopyButton:hover
    opacity .8
   .scrollCopyButton:active
    opacity 1
  .scrollCopyButton
   position absolute
   top .125rem
   right .125rem
   font-size .875rem
   cursor pointer
   opacity 0
  .scrollCopyButton::after
   content "[ ]"
  .scrollCopiedButton::after
   content "[✓]"
 javascript
  compile() {
   return `<style>\n${this.css}\n</style>`
  }
  compileTxt() {
    return ""
  }
  compileCss() {
    return this.css
  }
  compileEmbeddedVersion() {
   return ""
  }
  get scrollCss() {
    const hakonParser = this.root.hakonParser
    return new hakonParser(this.scrollStyles).compile()
  }
gazetteCssParser
 description The default Scroll theme.
 extends abstractThemeCssParser
 javascript
  get css() {
    if (this.constructor._cachedCss)
      return this.constructor._cachedCss
    const hakonParser = this.root.hakonParser
    this.constructor._cachedCss = this.scrollCss + new hakonParser([this.hakonReset, this.hakonStandardStyles].join("\n")).compile()
    return this.constructor._cachedCss
  }
 // CSS Reset
 string hakonReset
  html,body,div,span,p,ol,ul,li,table,figure
   margin 0
   padding 0
   border 0
   vertical-align baseline
   border-spacing 0
  ol,ul
   padding-left 1rem
  li
   margin-top .4rem
   line-height 1.4
  a
   text-decoration-color transparent
  a:hover
   text-decoration-color initial
  sup,sub
   vertical-align baseline
   position relative
   top -.375rem
  sub
   top .375rem
  html
   padding .25rem
   background-color rgb(244,244,244)
   font-family Exchange,Georgia,serif
   color #000
   font-size var(--base-font-size, 16px)
   hyphens auto
  p
   margin-top .4rem
   line-height 1.4rem
  .scrollQuote
   break-inside avoid
   display block
   margin .5rem 0
   padding .5rem
   background rgba(204,204,204,.5)
   white-space pre-line
   border-left .5rem solid rgba(204,204,204,.8)
  code
   font-size .9rem
   background-color rgba(204,204,204,.5)
   padding .125rem .25rem
   border-radius .25rem
 // Styles for Scroll standard tags
 string hakonStandardStyles
  comment Main body of both pages is similar
  .scrollParagraph
   text-align justify
  .scrollColumns
   column-count auto
   column-fill balance
   column-width 35ch
   column-gap 1.5rem
   padding-left 1.25rem
   padding-right 1.25rem
   margin auto
  comment On group pages add some spacing around files
  .scrollSnippetContainer
   padding 1ch 0
   break-inside avoid
   text-align justify
  h1,h2,h3,h4
   margin .625rem 0
  h1
   font-size 1.25rem
  h2
   font-size 1.125rem
  h3,h4
   font-size 1rem
  h1.scrollTitle
   text-align center
   margin auto
   margin-bottom .15625rem
   margin-top 0
   font-size 1.75rem
   comment On narrow browsers like phones make sure the title doesn't overlap with the icons buttons in top left and right.
   max-width calc(100vw - 2 * (1.5625rem + 1.875rem))
   a
    color #000
  .scrollDateline
   font-style italic
   line-height 1.4rem
   comment Decrease font size to deemphasize dateline but keep the line height the same to not cause different line spacing.
   font-size .75rem
  .scrollSection
   break-inside avoid
   h1,h2,h3,h4
    text-align center
  h4.scrollQuestion
   text-align left
   margin 1.4rem 0 0 0
  .scrollSection:first-child
   h1,h2,h3,h4
    margin-top 0
   h4.scrollQuestion
    margin-top 0
  .scrollNoteLink
   opacity .4
   text-decoration none
   &:hover
    opacity 1
  .scrollFootNoteUsageLink
   opacity .7
   text-decoration none
   &:hover
    opacity 1
  
  .scrollHoverNote
   text-decoration underline dashed 1px rgba(0,0,0,.1)
   cursor default
  
  .scrollCodeBlock
   border-left .5rem solid rgba(204,204,204,.8)
  
  .scrollTable
   table-layout fixed
   font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"
   margin .5rem 0
   overflow hidden
   font-size .8rem
   width 100%
   hyphens none
   border 1px solid rgba(224,224,224,.8)
   td,th
    padding .1875rem
    overflow hidden
    white-space nowrap
   th
    text-transform capitalize
    border-bottom 2px solid rgba(0,0,0,.6)
    text-align left
   td
    cursor zoom-in
   tr:nth-child(even)
    background rgba(224,224,224,.6)
  .scrollTable.expandedTable
   table-layout unset
   background white
   position relative
   z-index 10
   overflow unset
   td,th
    overflow unset
    white-space unset
   td
    cursor zoom-out
  
  .scrollByLine
   font-size .875rem
   font-style italic
   margin .25rem 0
   text-align center
  
  comment View source badge
  .scrollViewSourceBadge
   text-align right
   position absolute
   display block
   right 20px
   top 8px
   svg
    width 24px
    height 24px
    fill rgba(204,204,204,0.8)
   svg:hover
    fill #333
  comment Subtle "Article Source" link
  .scrollViewSource
   text-align center
   font-family Verdana
   font-weight 100
   a
    color rgba(204,204,204,.5)
    &:hover
     color #333
  
  .scrollContinueReadingLink
   display block
   text-align center
  
  .scrollDashboard
   width 100%
   font-size 1.875rem
   text-align center
   font-weight bold
   break-inside avoid
   margin-top .5rem
   margin-bottom .5rem
   td
    width 33.3%
    border 1px solid #e8e8e8
   span
    font-size 1.25rem
    display block
  .scrollChat
   span
    font-family Verdana
    margin-top .3125rem
    padding .3125rem 1.25rem
    border-radius .9375rem
    display inline-block
  .scrollChatLeft
   span
    background rgba(204,204,204, .5)
  .scrollChatRight
   span
    color white
    background rgb(0,132,255)
  .scrollYouTubeHolder
   position relative
   width 100%
   height 0
   padding-bottom 56.25%
  .scrollYouTubeEmbed
   position absolute
   top 0
   left 0
   width 100%
   height 100%
tufteCssParser
 description A theme built using Tufte CSS. https://github.com/edwardtufte/tufte-css
 extends abstractThemeCssParser
 javascript
  get css() {
    return this.scrollCss + this.tufteCss
  }
  tufteCss = `html {
     font-size: 15px;
  }
   body {
       width: 87.5%;
       margin-left: auto;
       margin-right: auto;
       padding-left: 12.5%;
       font-family: Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
       background-color: #fffff8;
       color: #111;
       max-width: 1400px;
       counter-reset: sidenote-counter;
  }
  /* Adds dark mode */
   @media (prefers-color-scheme: dark) {
       body {
           background-color: #151515;
           color: #ddd;
      }
  }
   h1 {
       font-weight: 400;
       margin-top: 3rem;
       margin-bottom: 1.5rem;
       font-size: 2.4rem;
       line-height: 1;
  }
  .scrollTitle a { text-decoration: none; font-size: 3.2rem;}
  .scrollParagraph { text-align: justify; hyphens: auto;}
  a.scrollNoteLink { text-decoration: none;}
   h2 {
       font-style: italic;
       font-weight: 400;
       margin-top: 2.1rem;
       margin-bottom: 1.4rem;
       font-size: 2.2rem;
       line-height: 1;
  }
   h3 {
       font-style: italic;
       font-weight: 400;
       font-size: 1.7rem;
       margin-top: 2rem;
       margin-bottom: 1.4rem;
       line-height: 1;
  }
   hr {
       display: block;
       height: 1px;
       width: 55%;
       border: 0;
       border-top: 1px solid #ccc;
       margin: 1em 0;
       padding: 0;
  }
   p.subtitle {
       font-style: italic;
       margin-top: 1rem;
       margin-bottom: 1rem;
       font-size: 1.8rem;
       display: block;
       line-height: 1;
  }
   .numeral {
       font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }
   .danger {
       color: red;
  }
   article {
       padding: 5rem 0rem;
  }
   section {
       padding-top: 1rem;
       padding-bottom: 1rem;
  }
   p, dl, ol, ul {
       font-size: 1.4rem;
       line-height: 2rem;
  }
   p {
       margin-top: 1.4rem;
       margin-bottom: 1.4rem;
       padding-right: 0;
       vertical-align: baseline;
  }
  /* Chapter Epigraphs */
   div.epigraph {
       margin: 5em 0;
  }
   div.epigraph > blockquote {
       margin-top: 3em;
       margin-bottom: 3em;
  }
   div.epigraph > blockquote, div.epigraph > blockquote > p {
       font-style: italic;
  }
   div.epigraph > blockquote > footer {
       font-style: normal;
  }
   div.epigraph > blockquote > footer > cite {
       font-style: italic;
  }
  /* end chapter epigraphs styles */
   blockquote {
       font-size: 1.4rem;
  }
   blockquote p {
       width: 55%;
       margin-right: 40px;
  }
   blockquote footer {
       width: 55%;
       font-size: 1.1rem;
       text-align: right;
  }
   section > p, section > footer, section > table {
       width: 55%;
  }
  /* 50 + 5 == 55, to be the same width as paragraph */
   section > dl, section > ol, section > ul {
       width: 50%;
       -webkit-padding-start: 5%;
  }
   dt:not(:first-child), li:not(:first-child) {
       margin-top: 0.25rem;
  }
  /* Links: replicate underline that clears descenders */
   a:link, a:visited {
       color: inherit;
  }
  /* Sidenotes, margin notes, figures, captions */
   img {
       max-width: 100%;
  }
   .sidenote, .marginnote {
       float: right;
       clear: right;
       margin-right: -60%;
       width: 50%;
       margin-top: 0.3rem;
       margin-bottom: 0;
       font-size: 1.1rem;
       line-height: 1.3;
       vertical-align: baseline;
       position: relative;
  }
   .sidenote-number {
       counter-increment: sidenote-counter;
  }
   .sidenote-number:after, .sidenote:before {
       font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
       position: relative;
       vertical-align: baseline;
  }
   .sidenote-number:after {
       content: counter(sidenote-counter);
       font-size: 1rem;
       top: -0.5rem;
       left: 0.1rem;
  }
   .sidenote:before {
       content: counter(sidenote-counter) " ";
       font-size: 1rem;
       top: -0.5rem;
  }
   blockquote .sidenote, blockquote .marginnote {
       margin-right: -82%;
       min-width: 59%;
       text-align: left;
  }
   div.fullwidth, table.fullwidth {
       width: 100%;
  }
   div.table-wrapper {
       overflow-x: auto;
       font-family: "Trebuchet MS", "Gill Sans", "Gill Sans MT", sans-serif;
  }
   .sans {
       font-family: "Gill Sans", "Gill Sans MT", Calibri, sans-serif;
       letter-spacing: 0.03em;
  }
   code, pre > code {
       font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
       font-size: 1rem;
       line-height: 1.42;
       -webkit-text-size-adjust: 100%;
      /* Prevent adjustments of font size after orientation changes in iOS. See https://github.com/edwardtufte/tufte-css/issues/81#issuecomment-261953409 */
  }
   .sans > code {
       font-size: 1.2rem;
  }
   h1 > code, h2 > code, h3 > code {
       font-size: 0.8em;
  }
   .marginnote > code, .sidenote > code {
       font-size: 1rem;
  }
   pre > code {
       font-size: 0.9rem;
       width: 52.5%;
       margin-left: 2.5%;
       overflow-x: auto;
       display: block;
  }
   pre.fullwidth > code {
       width: 90%;
  }
   .fullwidth {
       max-width: 90%;
       clear: both;
  }
   span.newthought {
       font-variant: small-caps;
       font-size: 1.2em;
  }
   input.margin-toggle {
       display: none;
  }
   label.sidenote-number {
       display: inline-block;
       max-height: 2rem;
      /* should be less than or equal to paragraph line-height */
  }
   label.margin-toggle:not(.sidenote-number) {
       display: none;
  }
   .iframe-wrapper {
       position: relative;
       padding-bottom: 56.25%;
      /* 16:9 */
       padding-top: 25px;
       height: 0;
  }
   .iframe-wrapper iframe {
       position: absolute;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
  }
   @media (max-width: 760px) {
       body {
           width: 84%;
           padding-left: 8%;
           padding-right: 8%;
      }
       hr, section > p, section > footer, section > table {
           width: 100%;
      }
       pre > code {
           width: 97%;
      }
       section > dl, section > ol, section > ul {
           width: 90%;
      }
       blockquote {
           margin-left: 1.5em;
           margin-right: 0em;
      }
       blockquote p, blockquote footer {
           width: 100%;
      }
       label.margin-toggle:not(.sidenote-number) {
           display: inline;
      }
       .sidenote, .marginnote {
           display: none;
      }
       .margin-toggle:checked + .sidenote, .margin-toggle:checked + .marginnote {
           display: block;
           float: left;
           left: 1rem;
           clear: both;
           width: 95%;
           margin: 1rem 2.5%;
           vertical-align: baseline;
           position: relative;
      }
       label {
           cursor: pointer;
      }
       div.table-wrapper, table {
           width: 85%;
      }
       img {
           width: 100%;
      }
  }`
htmlParser
 description A catch all block to drop in any loose html. Use for HTML one liners and/or blocks of HTML.
 cruxFromId
 extends abstractScrollParser
 catchAllParser htmlLineParser
 catchAllCellType htmlAnyCell
 javascript
  compile() {
   return `${this.content ?? ""}${this.childrenToString()}`
  }
  compileTxt() {
    return ""
  }
quickHtmlParser
 extends htmlParser
 cells htmlAnyCell
 pattern ^<
 description Start a line with a less than sign to immediately write HTML
 javascript
  compile() {
   return `${this.getLine() ?? ""}${this.childrenToString()}`
  }
stumpParser
 cruxFromId
 extends abstractScrollParser
 description Stump is a Tree Language that compiles to HTML.
 catchAllParser stumpContentParser
 javascript
  compile() {
   const file = this.parent.file
   return file.compileStumpCode(this.childrenToString())
  }
stumpNoSnippetParser
 extends stumpParser
 description Useful for headers and footers when you have something you don't want included in snippets.
 cruxFromId
 javascript
  compileEmbeddedVersion() {
   return ""
  }
abstractCaptionedParser
 extends abstractScrollParser
 cells keywordCell urlCell
 inScope captionAftertextParser slashCommentParser
 cruxFromId
 javascript
  compile(compileSettings) {
   const caption = this.getNode("caption")
   const captionFig = caption ? `<figcaption>${caption.compile()}</figcaption>` : ""
   return `<figure class="scrollCaptionedFigure">${this.getFigureContent(compileSettings)}${captionFig}</figure>`
  }
imageParser
 description An img tag.
 extends abstractCaptionedParser
 inScope classMarkupParser aftertextIdParser linkParser linkTargetParser
 openGraphParser
  description Add this line to make this the open graph image.
  cruxFromId
  cells keywordCell
 javascript
  getFigureContent(compileSettings) {
   const file = this.root.file
   const src = this.getWord(1)
   const linkRelativeToCompileTarget = (compileSettings ? (compileSettings.relativePath ?? "") : "") + src
   let dimensionAttributes = ""
   // If its a local image, get the dimensions and put them in the HTML
   // to avoid flicker
   if (!src.startsWith("http:") && !src.startsWith("https:")) {
    try {
     const sizeOf = require("image-size")
     const path = require("path")
     const fullImagePath = path.join(file.folderPath, src)
     const dimensions = sizeOf(fullImagePath)
     const width = dimensions.width
     const height = dimensions.height
     dimensionAttributes = `width="${width}" height="${height}" `
    } catch (err) {
     console.error(err)
    }
   }
   // Todo: can we reuse more code from aftertext?
   const className = this.has("class") ? ` class="${this.get("class")}" ` : ""
   const id = this.has("id") ? ` id="${this.get("id")}" ` : ""
   const clickLink = this.get("link") || linkRelativeToCompileTarget
   const target = this.has("target") ? this.get("target") : (this.has("link") ? "" : "_blank")
   return `<a href="${clickLink}" target="${target}" ${className} ${id}><img src="${linkRelativeToCompileTarget}" ${dimensionAttributes}loading="lazy"></a>`
  }
  compileTxt() {
    const children = this.filter(node => node.compileTxt).map(node => node.compileTxt()).filter(i => i).join("\n")
    return  "[Image Omitted]" + (children ? "\n " + children.replace(/\n/g, "\n ") : "")
  }
youTubeParser
 extends abstractCaptionedParser
 description Embed a YouTube video. Include the YouTube embed URL such as https://www.youtube.com/embed/CYPYZnVQoLg
 javascript
  getFigureContent() {
   const url = this.getWord(1).replace("youtube.com/watch?v=", "youtube.com/embed/")
   return `<div class="scrollYouTubeHolder"><iframe class="scrollYouTubeEmbed" src="${url}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>`
  }
importParser
 description Import one file into another.
 cruxFromId
 extends abstractScrollParser
 catchAllCellType filePathCell
 javascript
  compile() {
   return ""
  }
 example
  import header.scroll
keyboardNavParser
 description Makes left go to previous file and right go to next file.
 extends abstractScrollParser
 cruxFromId
 catchAllCellType urlCell
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const file = this.root.file
   const linkToPrevious = this.getWord(1) ?? file.linkToPrevious
   const linkToNext = this.getWord(2) ?? file.linkToNext
   const script = `<script>document.addEventListener('keydown', function(event) {
    if (document.activeElement !== document.body) return
    const getLinks = () => document.getElementsByClassName("scrollKeyboardNav")[0].getElementsByTagName("a")
    if (event.key === "ArrowLeft")
      getLinks()[0].click()
    else if (event.key === "ArrowRight")
      getLinks()[1].click()
   });</script>`
   return `<div class="scrollKeyboardNav" style="display:none;"><a href="${linkToPrevious}">${linkToPrevious}</a> · ${file.permalink} · <a href="${linkToNext}">${linkToNext}</a>${script}</div>`
  }
abstractMeasureParser
 cells measureNameCell
 cruxFromId
 boolean isMeasure true
 float sortIndex 1.9
 boolean isComputed false
 string typeForCsvDocs unspecified
 extends abstractScrollParser
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   return ""
  }
  get measureValue() {
    return this.content ?? ""
  }
  get measureName() {
    return this.getFirstWordPath().replace(/ /g, "_")
  }
abstractWordMeasureParser
 description A measure that contains a single word.
 cells measureNameCell wordCell
 string typeForCsvDocs word
 extends abstractMeasureParser
abstractUrlMeasureParser
 string typeForCsvDocs url
 cells measureNameCell urlCell
 extends abstractWordMeasureParser
abstractStringMeasureParser
 string typeForCsvDocs string
 catchAllCellType stringCell
 extends abstractMeasureParser
abstractIdParser
 crux id
 description What is the ID of this concept?
 extends abstractStringMeasureParser
 float sortIndex 1
 boolean isMeasureRequired true
 boolean isConceptDelimiter true
 javascript
  getErrors() {
    const errors = super.getErrors()
    let requiredMeasureNames = this.parent.file.measures.filter(measure => measure.isMeasureRequired).map(measure => measure.Name).filter(name => name !== "id")
    if (!requiredMeasureNames.length) return errors
    let next = this.next
    while (requiredMeasureNames.length && next.firstWord !== "id" && next.getIndex() !== 0) {
      requiredMeasureNames = requiredMeasureNames.filter(i => i !== next.firstWord)
      next = next.next
    }
    requiredMeasureNames.forEach(name => {
      errors.push({toObject: () => {return { message: `Concept "${this.content}" is missing required measure "${name}".`}}})
    })
    return errors
  }
abstractNumericMeasureParser
 string typeForCsvDocs number
 extends abstractMeasureParser
 javascript
  get measureValue() {
    const {content} = this
    return content === undefined ? "" : parseFloat(content)
  }
abstractIntegerMeasureParser
 string typeForCsvDocs integer
 cells measureNameCell integerCell
 extends abstractNumericMeasureParser
abstractFloatMeasureParser
 cells measureNameCell floatCell
 extends abstractNumericMeasureParser
abstractPercentageMeasureParser
 cells measureNameCell percentCell
 extends abstractNumericMeasureParser
 javascript
  get measureValue() {
    const {content} = this
    return content === undefined ? "" : parseFloat(content)
  }
abstractEnumMeasureParser
 string typeForCsvDocs enum
 cells measureNameCell enumCell
 extends abstractMeasureParser
abstractBooleanMeasureParser
 string typeForCsvDocs boolean
 cells measureNameCell booleanCell
 extends abstractMeasureParser
 javascript
  get measureValue() {
    const {content} = this
    return content === undefined ? "" : content == "true"
  }
metaTagsParser
 cruxFromId
 extends abstractScrollParser
 description Prints meta tags like title, description, et cetera.
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const { file } = this.parent
   const { title, description, openGraphImage, SCROLL_VERSION, canonicalUrl } = file
   const rssFeedUrl = this.parent.get("rssFeedUrl")
   let rssTag = ""
   if (rssFeedUrl)
    rssTag = `<link rel="alternate" type="application/rss+xml" title="${title}" href="${rssFeedUrl}">`
   // todo: cleanup the head/body stuff.
   return `<head>
   <meta charset="utf-8">
   <title>${title}</title>
   <script>/* This HTML was generated by 📜 Scroll v${SCROLL_VERSION}. https://scroll.pub */</script>
   <style>@media print {.doNotPrint {display: none !important;}}</style>
   <link rel="canonical" href="${canonicalUrl}">
   <meta name="viewport" content="width=device-width,initial-scale=1">
   <meta name="description" content="${description}">
   <meta name="generator" content="Scroll v${SCROLL_VERSION}">
   <meta property="og:title" content="${title}">
   <meta property="og:description" content="${description}">
   <meta property="og:image" content="${openGraphImage}">
   ${rssTag}
   <meta name="twitter:card" content="summary_large_image">
  </head>
  <body>`
  }
pageFooterParser
 cruxFromId
 description A footer for your page.
 extends abstractScrollParser
 string hakon
  .pageFooter
   margin-top 8px
   padding-top 8px
   text-align center
   svg
    width 30px
    height 30px
    fill rgba(204,204,204, .5)
    padding 0 7px
    &:hover
     fill #333
  .pageFooterScrollLink
   font-family Verdana
   font-weight 100
   margin .5em
   a
    color rgba(204,204,204,.5)
    &:hover
     color #333
     text-decoration none
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  get css() {
    const hakonParser = this.root.hakonParser
    return new hakonParser(this.hakon).compile()
  }
  compile() {
   const file = this.parent.file
   const { SVGS, SCROLL_VERSION, viewSourceUrl } = file
   const closeContainerTag = "</div>"
   const emailLink = file.email ? `a ${SVGS.email}
    href mailto:${file.email}` : ""
   const downloadLink = file.downloadUrl ? `a ${SVGS.download}
    href ${file.downloadUrl}` : ""
   const gitLink = file.viewSourceUrl ? `a ${SVGS.git}
    title View Source
    href ${file.viewSourceUrl}` : ""
   return (
    closeContainerTag + `<style>${this.css}</style>` +
    file.compileStumpCode(`p
   class scrollViewSource doNotPrint
  div
   class pageFooter doNotPrint
   ${emailLink}
   ${downloadLink}
   ${gitLink}
   div
    class pageFooterScrollLink
    a Built with Scroll v${SCROLL_VERSION}
     href https://scroll.pub`)
   )
  }
gazetteFooterParser
 extends pageFooterParser
 boolean isDeprecated true
 description DEPRECATED! Use "pageFooter" instead.
pageHeaderParser
 cruxFromId
 description A header for your page.
 extends abstractScrollParser
 string hakon
  .pageHeader
   position absolute
   top .25rem
   right 0
   left 0
   svg
    width 1.875rem
    height 1.875rem
    fill rgba(204,204,204,.8)
    &:hover
     fill #333
   a
    color rgba(204,204,204,.8)
    position absolute
    font-size 1.875rem
    line-height 1.7rem
    text-decoration none
    &:hover
     color #333
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  get css() {
    const hakonParser = this.root.hakonParser
    return new hakonParser(this.hakon).compile()
  }
  compile() {
   const file = this.parent.file
   const { SVGS, linkToPrevious, linkToNext, viewSourceUrl } = file
   let previousButton = ""
   if (linkToPrevious)
    previousButton = `a &lt;
    style left:.1875rem;
    href ${linkToPrevious}`
   let nextButton = ""
   if (linkToNext)
    nextButton = `a &gt;
    style right:.1875rem;
    href ${linkToNext}`
   const gitLink = file.viewSourceUrl ? `a ${SVGS.git}
    style text-align:right;right: 1.5625rem;
    title View Source
    href ${file.viewSourceUrl}` : ""
   return `<style>\n${this.css}\n</style>` + file.compileStumpCode(`div
   class pageHeader doNotPrint
   ${previousButton}
   a ${SVGS.home}
    style text-align:left;left:1.5625rem;
    href ${file.get("homeUrl") || "index.html"}
   ${gitLink}
   ${nextButton}`)
  }
gazetteHeaderParser
 extends pageHeaderParser
 boolean isDeprecated true
 description DEPRECATED! Use "pageHeader" instead.
scrollParserDefinitionParser
 extends abstractScrollParser
 // todo Figure out best pattern for merging Scroll and Parsers?
 pattern ^[a-zA-Z0-9_]+Parser$
 description Define your own Parsers.
 baseParser blobParser
 javascript
  compile() {
   return ""
  }
quoteParser
 cruxFromId
 description A blockquote.
 catchAllParser quoteLineParser
 extends abstractScrollParser
 javascript
  compile() {
   return `<blockquote class="scrollQuote">${this.childrenToString()}</blockquote>`
  }
  compileTxt() {
    return this.childrenToString()
  }
readingListParser
 extends abstractScrollParser
 description Easily create a reading list with links, titles, and author names.
 cells keywordCell
 cruxFromId
 catchAllParser readingListItemParser
 example
  readingList
   https://example.com/similar by Author Name
 javascript
  compile() {
   return `<br><ul>${this.map(child => child.compile()).join("\n")}</ul>`
  }
redirectToParser
 description Prints an HTML redirect tag. In the future might also emit nginx config.
 extends abstractScrollParser
 cells keywordCell urlCell
 cruxFromId
 example
  redirectTo https://scroll.pub/releaseNotes.html
 javascript
  compile() {
   return `<meta http-equiv="Refresh" content="0; url='${this.getWord(1)}'" />`
  }
printRelatedListParser
 description Prints a list of related posts with years.
 extends abstractScrollParser
 cruxFromId
 cells keywordCell
 javascript
  compile() {
   const file = this.root.file
   const ids = this.root.get("related")?.split(" ") || []
   return ids.map(id => {
    // get title, permalink, and year
    const {title, permalink, year} = file.getFileFromId(id)
    const node = this.appendSibling(`- ${title}${year ? " (" + year + ")" : ""}`, `link ${permalink}`)
    // A hacky but simple way to do this for now.
    const html = node.compile()
    node.destroy()
    return html
   }).join("\n")
  }
  compileTxt() {
   // Todo: reuse code between these 2 methods.
   const file = this.root.file
   const ids = this.root.get("related")?.split(" ") || []
   return ids.map(id => {
    // get title, permalink, and year
    const {title, permalink, year} = file.getFileFromId(id)
    const link = file.ensureAbsoluteLink(permalink)
    return `- ${title}${year ? " (" + year + ")" : ""}\n ${link}`
  }).join("\n")
  }
abstractVariableParser
 extends abstractScrollParser
 catchAllCellType stringCell
 cruxFromId
 javascript
  isTopMatter = true
  compile() {
   return ""
  }
replaceParser
 description Define a variable token and replacement that will be applied to all lines before and after this one.
 extends abstractVariableParser
 baseParser blobParser
 example
  replace YEAR 2022
replaceJsParser
 description Define a variable token and replacement that will be applied to all lines before and after this one.
 extends replaceParser
 catchAllCellType javascriptCell
 example
  replaceJs SUM 1+1
  * 1+1 = SUM
replaceNodejsParser
 description Write nodejs code inside a Scroll file. Sort of like PHP.
 extends abstractVariableParser
 catchAllCellType javascriptCell
 baseParser blobParser
 example
  replaceNodejs
   module.exports = {SCORE : 1 + 2}
  * The score is SCORE
scriptParser
 extends abstractScrollParser
 description Prints Javascript content wrapped in script tags.
 cruxFromId
 catchAllParser scriptLineParser
 catchAllCellType scriptAnyCell
 javascript
  compile() {
   return `<script>${this.scriptContent}</script>`
  }
  get scriptContent() {
    return this.content ?? this.childrenToString()
  }
  compileJs() {
    return this.scriptContent
  }
endSnippetParser
 description Insert one of these where you want to cut the file for a snippet.
 extends abstractScrollParser
 cruxFromId
 javascript
  compile() {
   return ""
  }
stampParser
 description Share entire folders as plain text.
 extends abstractScrollParser
 inScope stampFolderParser
 catchAllParser stampFileParser
 example
  stamp
   .gitignore
    *.html
   readme.scroll
    # Hello world
    <script src="scripts/nested/hello.js"></script>
   scripts/
    nested/
     hello.js
      console.log("Hello world")
 cruxFromId
 cells keywordCell
 javascript
  build() {
    const dir = this.root.file.folderPath
    this.forEach(node => node.build(dir))
  }
abstractTableParser
 cruxFromId
 catchAllParser rowParser
 extends abstractScrollParser
 javascript
  get tableHeader() {
   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\n`)
  }
  get columnNames() {
   const header = this.nodeAt(0)
   return header ? header.getLine().split(this.delimiter) : []
  }
  get columns() {
   const cols = this.columnNames
   return cols.map((name, index) => {
    const isLink = name.endsWith("Link")
    const linkIndex = cols.indexOf(name + "Link")
    return {
     name,
     isLink,
     linkIndex
    }
   })
  }
  get tableBody() {
   const { delimiter } = this
   return this.topDownArray
    .slice(1)
    .map(node => `<tr>${node.toRow(this.columns, delimiter)}</tr>`)
    .join("\n")
  }
  compile() {
   return `<table id="table${this._getUid()}" class="scrollTable">
   <thead><tr>${this.tableHeader.join("\n")}</tr></thead>
   <tbody>${this.tableBody}</tbody>
   </table>
   <script>
   document.querySelector('#table${this._getUid()}').addEventListener('click', e => {
    if (window.getSelection().toString() || e.target.closest('a') || !e.target.closest('tbody')) return;
    e.currentTarget.classList.toggle('expandedTable');
   });
   </script>`
  }
  compileTxt() {
    return this.childrenToString()
  }
tableParser
 description A table with a custom delimiter.
 extends abstractTableParser
 catchAllCellType anyCell
 javascript
  get delimiter() {
   return this.content ?? ""
  }
commaTableParser
 description Comma separated values table.
 extends abstractTableParser
 string delimiter ,
pipeTableParser
 description Pipe separated values table.
 extends abstractTableParser
 string delimiter |
spaceTableParser
 description Space separated values table. Last column is a catch all.
 extends abstractTableParser
 string delimiter  
tabTableParser
 description Tab separated values table.
 extends abstractTableParser
 string delimiter \t
treeTableParser
 description A table of data written in Scroll Notation form. Useful when a column contains a text blob.
 extends abstractTableParser
 catchAllParser treeRowParser
 javascript
  get columnNames() {
   return this._getUnionNames()
  }
  get tableBody() {
   return this.map(node => `<tr>${node.toRow(this.columns)}</tr>`).join("\n")
  }
 example
  treeTable
   row
    name Javascript
    example
     console.log("Hello world")
   row
    name Python
    example
     print "Hello world"
printTableParser
 description Print a tabular table in a page into an HTML table.
 cruxFromId
 catchAllCellType integerCell
 extends abstractScrollParser
 javascript
   compile() {
    const node = this.appendSibling("table \t", this.tsv)
    const html = node.compile()
    node.destroy()
    return html
   }
   getTableByIndex(index) {
      const hit = this.root.file.tables[parseInt(index)]
      if (!hit)
        console.error(`Table "${index}" not found`)
      return hit
   }
   get table() {
     const index = this.getWord(1)
     if (index !== undefined)
        return this.getTableByIndex(index)
     if (this.next.isTabularData)
       return this.next
     if (this.previous.isTabularData)
       return this.previous.headerNode
    return this.getTableByIndex(0)
   }
   get tsv() {
    const firstNode = this.table
    const lastNode = firstNode.lastNode
    const aftertext = lastNode.childrenToString() // todo: we could be more specific and ignore comments
    let tableNode = firstNode
    let tsv = tableNode.getLine()
    while (tableNode.next.isTabularData) {
      tsv += "\n" + (aftertext ? tableNode.next.applyAftertext(aftertext) : tableNode.next.getLine())
      tableNode = tableNode.next
      if (tableNode === firstNode)
        break
    }
     return tsv
   }
   compileTxt() {
     return this.tsv
   }
plainTextParser
 description Use for plain text one liners and/or blocks of plain text. Will print in all output formats.
 cruxFromId
 extends abstractScrollParser
 catchAllParser plainTextLineParser
 catchAllCellType stringCell
 javascript
  compile() {
   return this.compileTxt()
  }
  compileTxt() {
    return `${this.content ?? ""}${this.childrenToString()}`
  }
plainTextOnlyParser
 extends plainTextParser
 description Only prints its contents in text output.
 javascript
  compile() {
   return ""
  }
abstractAftertextAttributeParser
 cells keywordCell
 boolean isAttribute true
 javascript
  get divAttributes() {
   return `${this.firstWord}="${this.content}"`
  }
  compile() {
   return ""
  }
aftertextIdParser
 crux id
 description Provide an ID to be output in the generated HTML tag.
 extends abstractAftertextAttributeParser
 cells keywordCell htmlIdCell
 single
aftertextStyleParser
 crux style
 description Provide code for the generated HTML tag's "style" attribute.
 extends abstractAftertextAttributeParser
 cells keywordCell
 catchAllCellType cssAnyCell
aftertextHiddenParser
 crux hidden
 cells keywordCell
 description Do not compile this node to HTML.
 extends abstractAftertextAttributeParser
 single
aftertextTagParser
 cells keywordCell htmlTagCell
 description Override the HTML tag that the compiled node will use.
 crux tag
 javascript
  compile() {
   return ""
  }
abstractAftertextDirectiveParser
 cells keywordCell
 catchAllCellType stringCell
 javascript
  isMarkup = true
  compile() {
   return ""
  }
  getErrors() {
    const errors = super.getErrors()
    if (!this.isMarkup || this.matchWholeLine) return errors
    const inserts = this.getInserts(this.parent.originalTextPostLinkify)
    // todo: make AbstractTreeError class exported by sdk to allow Parsers to define their own error types.
    // todo: also need to be able to map lines back to their line in source (pre-imports)
    if (!inserts.length)
      errors.push({toObject: () => {return { message: `No match found for "${this.getLine()}".`}}})
    return errors
  }
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get shouldMatchAll() {
   return this.has("matchAll")
  }
  getMatches(text) {
   const { pattern } = this
   const escapedPattern = pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   return [...text.matchAll(new RegExp(escapedPattern, "g"))].map(match => {
    const { index } = match
    const endIndex = index + pattern.length
    return [
     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },
     { index: endIndex, endIndex, string: `</${this.closeTag}>` }
    ]
   })
  }
  getInserts(text) {
   const matches = this.getMatches(text)
   if (!matches.length) return false
   if (this.shouldMatchAll) return matches.flat()
   const match = this.getNode("match")
   if (match)
    return match.indexes
     .map(index => matches[index])
     .filter(i => i)
     .flat()
   return matches[0]
  }
  get allAttributes() {
   const attr = this.attributes.join(" ")
   return attr ? " " + attr : ""
  }
  get attributes() {
   return []
  }
  get openTag() {
   return this.tag
  }
  get closeTag() {
   return this.tag
  }
abstractMarkupParser
 extends abstractAftertextDirectiveParser
 inScope abstractMarkupParameterParser
boldParser
 cruxFromId
 description Bold the matching text.
 extends abstractMarkupParser
 javascript
  tag = "b"
italicsParser
 cruxFromId
 description Italicize the matching text.
 extends abstractMarkupParser
 javascript
  tag = "i"
underlineParser
 description Underline the matching text.
 cruxFromId
 extends abstractMarkupParser
 javascript
  tag = "u"
aftertextCodeParser
 description Wrap the matching text in a <code> span.
 crux code
 extends abstractMarkupParser
 javascript
  tag = "code"
classMarkupParser
 description Add a custom class to the parent element instead. If matching text provided, a span with the class will be added around the matching text.
 extends abstractMarkupParser
 cells keywordCell classNameCell
 crux class
 javascript
  tag = "span"
  get applyToParentElement() {
   return this.words.length === 2
  }
  getInserts(text) {
   // If no select text is added, set the class on the parent element.
   if (this.applyToParentElement) return []
   return super.getInserts(text)
  }
  get className() {
   return this.getWord(1)
  }
  get attributes() {
   return [`class="${this.className}"`]
  }
  get matchWholeLine() {
    return this.applyToParentElement
  }
  get pattern() {
   return this.matchWholeLine ? this.parent.content : this.getWordsFrom(2).join(" ")
  }
classesMarkupParser
 extends classMarkupParser
 crux classes
 javascript
  applyToParentElement = true
  get className() {
   return this.content
  }
hoverNoteParser
 description Add a caveat viewable on hover on matching text. When you want to be sure you've thoroughly addressed obvious concerns but ones that don't warrant to distract from the main argument of the text.
 cruxFromId
 extends classMarkupParser
 catchAllParser lineOfTextParser
 cells keywordCell
 javascript
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get attributes() {
   return [`class="scrollHoverNote"`, `title="${this.hoverNoteText}"`]
  }
  get hoverNoteText() {
   return this.childrenToString().replace(/\n/g, " ")
  }
aftertextStrikeParser
 crux strike
 extends abstractMarkupParser
 javascript
  tag = "s"
linkParser
 extends abstractMarkupParser
 description Put the matching text in an <a> tag.
 cells keywordCell urlCell
 inScope linkTitleParser linkTargetParser commentParser
 programParser
  description Anything here will be URI encoded and then appended to the link.
  cruxFromId
  cells keywordCell
  catchAllParser programLinkParser
  javascript
   get encoded() {
    return encodeURIComponent(this.childrenToString())
   }
 cruxFromId
 javascript
  tag = "a"
  compileTxt() {
    return this.root.file.ensureAbsoluteLink(this.link)
  }
  get link() {
   const {baseLink} = this
   if (this.has("program"))
     return baseLink + this.getNode("program").encoded
   return baseLink
  }
  get baseLink() {
   const link = this.getWord(1)
   const isAbsoluteLink = link.includes("://")
   if (isAbsoluteLink) return link
   const relativePath = this.parent.compileSettings?.relativePath || ""
   return relativePath + link
  }
  get attributes() {
   const attrs = [`href="${this.link}"`]
   const options = ["title", "target"]
   options.forEach(option => {
    const node = this.getNode(option)
    if (node) attrs.push(`${option}="${node.content}"`)
   })
   return attrs
  }
  get matchWholeLine() {
    return this.getWordsFrom(this.patternStartsAtWord).length === 0
  }
  patternStartsAtWord = 2
  get pattern() {
   return this.matchWholeLine ? this.parent.originalText : this.getWordsFrom(this.patternStartsAtWord).join(" ")
  }
emailLinkParser
 description A mailto link
 crux email
 extends linkParser
 javascript
  get attributes() {
   return [`href="mailto:${this.link}"`]
  }
quickLinkParser
 pattern ^https?\:
 extends linkParser
 cells urlCell
 javascript
  get link() {
   return this.firstWord
  }
  patternStartsAtWord = 1
wrapsOnParser
 cruxFromId
 description Enable `code`, *bold*, and _italics_ rules.
 extends abstractAftertextDirectiveParser
 catchAllCellType wrapNameCell
 javascript
  get shouldMatchAll() {
   return true
  }
  get wraps() {
    const wraps = [{delimiter: "`", tag: "code", exclusive: true, name: "code"},{delimiter: "*", tag: "strong", name: "bold"}, {delimiter: "_", tag: "em", name: "italics"}]
    if (this.root.has("katex"))
      wraps.unshift({delimiter: "$", tag: "span", attributes: ' class="scrollKatex"', exclusive: true, name: "katex"})
    if (this.content)
      return wraps.filter(wrap => this.content.includes(wrap.name))
    return wraps
  }
  getMatches(text) {
   const exclusives = []
   return this.wraps.map(wrap => this.runPattern(text, wrap, exclusives)).filter(i => i).flat()
  }
  runPattern(text, wrap, exclusives = []) {
   const {delimiter, tag, attributes} = wrap
   const escapedDelimiter = delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, "g")
   const delimiterLength = delimiter.length
   return [...text.matchAll(pattern)].map(match => {
    const { index } = match
    const endIndex = index + match[0].length
    // I'm too lazy to clean up sdk to write a proper inline markup parser so doing this for now.
    // The exclusive idea is to not try and apply bold or italic styles inside a TeX or code inline style.
    // Note that the way this is currently implemented any TeX in an inline code will get rendered, but code
    // inline of TeX will not. Seems like an okay tradeoff until a proper refactor and cleanup can be done.
    if (exclusives.some(exclusive => index >= exclusive[0] && index <= exclusive[1]))
      return undefined
    if (wrap.exclusive)
      exclusives.push([index, endIndex])
    return [
     { index, string: `<${tag + (attributes ? " " + attributes : "")}>`, endIndex, consumeStartCharacters: delimiterLength },
     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }
    ]
   }).filter(i => i)
  }
wrapParser
 cruxFromId
 cells keywordCell delimiterCell tagOrUrlCell
 catchAllCellType htmlAttributesCell
 extends wrapsOnParser
 description Define a custom wrap, for example "wrap _ em" would support: _italics_.
 javascript
  getMatches(text) {
   try {
    const delimiter = this.getWord(1)
    const tag = this.getWord(2)
    const attributes = this.getWordsFrom(3).join(" ")
    if (tag.startsWith("https:")) return this.runPattern(text, {delimiter, tag: "a", attributes: `href="${tag}"` + attributes})
    return this.runPattern(text, {delimiter, tag, attributes})
   } catch (err) {
    console.error(err)
    return []
   }
   // Note: doubling up doesn't work because of the consumption characters.
  }
datelineParser
 cruxFromId
 description Gives your paragraph a dateline like "December 15, 2021 — The..."
 extends abstractAftertextDirectiveParser
 javascript
  getInserts() {
   const {day} = this
   if (!day) return false
   return [{ index: 0, string: `<span class="scrollDateline">${day} — </span>` }]
  }
  matchWholeLine = true
  get day() {
   let day = this.content || this.root.get("date") || this.root.file?.date
   if (!day) return ""
   try {
    const dayjs = require("dayjs")
    return dayjs(day).format(`MMMM D, YYYY`)
   } catch (err) {
    console.error(err)
   }
   return day || ""
  }
dayjsParser
 description Advanced directive that evals some Javascript code in an environment including "dayjs".
 cruxFromId
 extends abstractAftertextDirectiveParser
 javascript
  getInserts() {
   const dayjs = require("dayjs")
   const days = eval(this.content)
   const index = this.parent.originalTextPostLinkify.indexOf("days")
   return [{ index, string: `${days} ` }]
  }
linkifyParser
 description Use this to disable linkify on the text.
 extends abstractAftertextDirectiveParser
 cruxFromId
 cells keywordCell booleanCell
abstractMarkupParameterParser
 cells keywordCell
 cruxFromId
matchAllParser
 description Use this to match all occurrences of the text.
 extends abstractMarkupParameterParser
matchParser
 catchAllCellType integerCell
 description Use this to specify which index(es) to match.
 javascript
  get indexes() {
   return this.getWordsFrom(1).map(num => parseInt(num))
  }
 example
  aftertext
   hello ello ello
   bold ello
    match 0 2
 extends abstractMarkupParameterParser
abstractHtmlAttributeParser
 javascript
  compile() {
   return ""
  }
linkTargetParser
 extends abstractHtmlAttributeParser
 description If you want to set the target of the link. To "_blank", for example.
 crux target
 cells keywordCell anyCell
blankLineParser
 description Blank lines compile to nothing in the HTML.
 cells blankCell
 javascript
  compile() {
   return this.parent.clearSectionStack()
  }
 pattern ^$
 tags doNotSynthesize
chatLineParser
 catchAllCellType anyCell
 catchAllParser chatLineParser
lineOfCodeParser
 catchAllCellType codeCell
 catchAllParser lineOfCodeParser
commentLineParser
 catchAllCellType commentCell
cssLineParser
 catchAllCellType cssAnyCell
 catchAllParser cssLineParser
errorParser
 baseParser errorParser
lineOfTextParser
 catchAllCellType stringCell
 boolean isTextParser true
htmlLineParser
 catchAllCellType htmlAnyCell
 catchAllParser htmlLineParser
stumpContentParser
 catchAllCellType anyCell
linkTitleParser
 description If you want to set the title of the link.
 crux title
 cells keywordCell
 catchAllCellType anyCell
 example
  * This report showed the treatment had a big impact.
   https://example.com/report This report.
    title The average growth in the treatment group was 14.2x higher than the control group.
programLinkParser
 catchAllCellType codeCell
abstractLoopConfigParser
 cells keywordCell
 cruxFromId
 catchAllCellType stringCell
abstractItemsProviderParser
 cells keywordCell
loopLinesParser
 crux lines
 extends abstractItemsProviderParser
 description Iterate over the provided lines.
 catchAllParser loopLineParser
 loopLineParser
  catchAllCellType stringCell
 javascript
  get items() {
   return this.map(node => node.asString)
  }
loopWordsParser
 crux words
 extends abstractItemsProviderParser
 catchAllCellType stringCell
 description Iterate over the provided words.
 javascript
  get items() {
   return this.getWordsFrom(1)
  }
loopGroupsParser
 crux groups
 extends abstractItemsProviderParser
 catchAllCellType groupNameWithOptionalFolderCell
 description Set this to iterate over scroll files in a folder. Provide both the folder and group name like this: [folder]/[groupName]
 javascript
  get items() {
   return this.root.file.getFilesInGroupsForEmbedding(this.getWordsFrom(1))
  }
abstractPointConfigParser
 // todo: scoped parsers should support abstract types
 cruxFromId
 cells keywordCell
 catchAllCellType stringCell
 single
latParser
 cells keywordCell floatCell
 cruxFromId
 single
longParser
 cells keywordCell floatCell
 cruxFromId
 single
quoteLineParser
 catchAllCellType anyCell
 catchAllParser quoteLineParser
readingListItemParser
 cells urlCell
 catchAllCellType stringCell
 javascript
  compile() {
   const url = this.firstWord
   const [title, author] = this.content.split(" by ")
   return `<li><a href="${url}">${title ?? url}</a>${author ? ` by ${author}` : ""}</li>`
  }
scrollParser
 extensions scroll
 description Scroll is a language for scientists of all ages. Refine, share and collaborate on ideas.
 root
 inScope abstractScrollParser blankLineParser
 catchAllParser catchAllParagraphParser
 compilesTo html
 javascript
  setFile(file) {
   this.file = file
   return this
  }
  compile(compileSettings) {
    this.sectionStack = []
    return this.map(child => child.compile(compileSettings)).filter(i => i).join("\n") + this.clearSectionStack()
  }
  sectionStack = []
  clearSectionStack() {
   const result = this.sectionStack.join("")
   this.sectionStack = []
   return result
  }
  get hakonParser() {
    if (this.isNodeJs())
      return require("scrollsdk/products/hakon.nodejs.js")
    return hakonParser
  }
  alreadyRequired = new Set()
  compileEmbeddedVersion(compileSettings) {
   this.sectionStack = []
   return this.map(child => (child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))
     .filter(i => i)
     .join("\n")
     .trim() + this.clearSectionStack()
  }
  get footnotes() {
   if (this._footnotes === undefined) this._footnotes = this.filter(node => node.isFootnote)
   return this._footnotes
  }
  file = {}
  get permalink() {
   return this.get("permalink") || this.file.permalink || ""
  }
 example
  # Hello world
  ## This is Scroll
  * It compiles to HTML.
  
  code
   // You can add code as well.
   print("Hello world")
scriptLineParser
 catchAllCellType scriptAnyCell
 catchAllParser scriptLineParser
stampFileParser
 catchAllCellType stringCell
 description Create a file.
 javascript
  build(parentDir) {
   const fs = require("fs")
   const path = require("path")
   const fullPath = path.join(parentDir, this.getLine())
   this.root.file.log(`Creating file ${fullPath}`)
   fs.mkdirSync(path.dirname(fullPath), {recursive: true})
   const content = this.childrenToString()
   fs.writeFileSync(fullPath, content, "utf8")
   const isExecutable = content.startsWith("#!")
   if (isExecutable) fs.chmodSync(fullPath, "755")
  }
stampFolderParser
 catchAllCellType stringCell
 description Create a folder.
 inScope stampFolderParser
 catchAllParser stampFileParser
 pattern \/$
 javascript
  build(parentDir) {
   const fs = require("fs")
   const path = require("path")
   const newPath = path.join(parentDir, this.getLine())
   this.root.file.log(`Creating folder ${newPath}`)
   fs.mkdirSync(newPath, {recursive: true})
   this.forEach(node => node.build(newPath))
  }
rowParser
 catchAllCellType stringCell
 javascript
  toRow(columns, delimiter) {
   const words = this.getLine().split(delimiter)
   let str = ""
   let column = 0
   const columnCount = columns.length
   while (column < columnCount) {
    const col = columns[column]
    column++
    const content = (columnCount === column ? words.slice(columnCount - 1).join(" ") : words[column - 1]) ?? ""
    if (col.isLink) continue
    let tagged = content
    const link = words[col.linkIndex]
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    else if (content.match(/^https?\:[^ ]+$/)) tagged = `<a href="${content}">${content}</a>`
    str += `<td>${tagged}</td>\n`
   }
   return str
  }
plainTextLineParser
 catchAllCellType stringCell
 catchAllParser plainTextLineParser
treeRowContentParser
 description Any blob content in a cell.
 cells stringCell
 catchAllCellType stringCell
treeRowColumnParser
 catchAllParser treeRowContentParser
 description A columnName value pair, or just a columnName if the value is a text blob.
 cells anyCell
 catchAllCellType stringCell
treeRowParser
 cells anyCell
 description The root node of a row.
 catchAllParser treeRowColumnParser
 javascript
  toRow(columns) {
   let str = ""
   columns.forEach(col => {
    const node = this.getNode(col.name)
    if (col.isLink) return
    if (!node) {
     str += "<td></td>\n"
     return
    }
    const content = (node.length ? node.childrenToString() : node.content) ?? ""
    let tagged = ""
    const link = this.get(col.name + "Link")
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    else if (node.length) tagged = `<pre>${content}</pre>`
    else tagged = content
    str += `<td>${tagged}</td>\n`
   })
   return str
  }