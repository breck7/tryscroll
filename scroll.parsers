buildCommandWordCell
 extends commandWordCell
 description Give build command words their own color.
 paint constant
blankCell
anyCell
enumCell
 paint constant.language
booleanCell
 enum true false
 extends enumCell
stringCell
 paint string
wordCell
 paint string
 description A non-empty single word string.
 regex .+
columnNameCell
 extends stringCell
semanticVersionCell
 paint string
 description A 3 part sem version string like 1.2.1
dateCell
 paint string
numberCell
 paint constant.numeric
integerCell
 extends numberCell
 paint constant.numeric.integer
floatCell
 extends numberCell
 paint constant.numeric.float
percentCell
 paint constant.numeric.float
 extends stringCell
 // todo: this currently extends from stringCell b/c scrollsdk needs to be fixed. seems like if extending from number then the hard coded number typescript regex takes precedence over a custom regex
countCell
 extends integerCell
yearCell
 extends integerCell
commandWordCell
 description A word that indicates a certain parser to use.
 paint keyword
preBuildCommandWordCell
 extends commandWordCell
 description Give build command words their own color.
 paint constant.character.escape
commentCell
 paint comment
delimiterCell
 description String to use as a delimiter.
 paint string
codeCell
 paint comment
bulletPointCell
 description Any token used as a bullet point such as "-" or "1." or ">"
 paint keyword
comparisonCell
 enum < > <= >= = != includes doesNotInclude empty notEmpty
 paint constant
personNameCell
 extends stringCell
urlCell
 paint constant.language
absoluteUrlCell
 paint constant.language
 regex (ftp|https?)://.+
emailAddressCell
 extends stringCell
permalinkCell
 paint string
 description A string that doesn't contain characters that might interfere with most filesystems. No slashes, for instance.
filePathCell
 extends stringCell
tagOrUrlCell
 description An HTML tag or a url.
 paint constant.language
htmlAttributesCell
 paint comment
htmlTagCell
 paint constant.language
 enum div span p a img ul ol li h1 h2 h3 h4 h5 h6 header nav section article aside main footer input button form label select option textarea table tr td th tbody thead tfoot br hr meta link script style title code
classNameCell
 paint constant
htmlIdCell
 extends anyCell
cssAnyCell
 extends anyCell
htmlAnyCell
 extends stringCell
inlineMarkupNameCell
 description Options to turn on some inline markups.
 enum bold italics code katex none
measureNameCell
 extends commandWordCell
 // A regex for column names for max compatibility with a broad range of data science tools:
 regex [a-zA-Z][a-zA-Z0-9]*
javascriptCell
 extends stringCell
metaCommandWordCell
 extends commandWordCell
 description Give meta command words their own color.
 paint constant.numeric
 // Obviously this is not numeric. But I like the green color for now.
   We need a better design to replace this "paint" concept
   https://github.com/breck7/scrollsdk/issues/186
scriptAnyCell
 extends anyCell
tagCell
 extends permalinkCell
tagWithOptionalFolderCell
 description A group name optionally combined with a folder path. Only used when referencing tags, not in posts.
 extends stringCell
abstractScrollParser
 cells commandWordCell
 javascript
  compileEmbeddedVersion(compileSettings) {
   return this.compile(compileSettings)
  }
  compileTxt() {
    return ""
  }
  getHtmlRequirements(compileSettings) {
    const {requireOnce} = this
    if (!requireOnce)
      return ""
    const set = compileSettings?.alreadyRequired || this.root.alreadyRequired
    if (set.has(requireOnce))
      return ""
    
    set.add(requireOnce)
    return requireOnce + "\n\n"
  }
abstractAftertextParser
 description Text followed by markup commands.
 extends abstractScrollParser
 inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser aftertextTagParser commentParser
 javascript
  get markupInserts() {
   const { originalTextPostLinkify } = this
   return this.filter(particle => particle.isMarkup)
    .map(particle => particle.getInserts(originalTextPostLinkify))
    .filter(i => i)
    .flat()
  }
  get originalText() {
   return this.content ?? ""
  }
  get originalTextPostLinkify() {
   const { originalText } = this
   const shouldLinkify = this.get("linkify") === "false" || originalText.includes("<a ") ? false : true
   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText
  }
  replaceNotes(originalText) {
   // Skip the replacements if there are no footnotes or the text has none.
   if (!this.root.footnotes.length || !originalText.includes("^")) return originalText
   this.root.footnotes.forEach((note, index) => {
    const needle = note.firstWord
    const {linkBack} = note
    if (originalText.includes(needle)) originalText = originalText.replace(new RegExp("\\" + needle + "\\b"), `<a href="#${note.anchorId}" class="scrollNoteLink" id="${linkBack}"><sup>${note.label}</sup></a>`)
   })
   return originalText
  }
  get text() {
   const { originalTextPostLinkify, markupInserts } = this
   let adjustment = 0
   let newText = originalTextPostLinkify
   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.
   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))
   markupInserts.forEach(insertion => {
    insertion.index += adjustment
    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0
    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0
    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)
    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters
   })
   return newText
  }
  tag = "p"
  get className() {
   if (this.get("classes"))
     return this.get("classes")
   const classLine = this.getParticle("class")
   if (classLine && classLine.applyToParentElement) return classLine.content
   return this.defaultClassName
  }
  defaultClassName = "scrollParagraph"
  get isHidden() {
    return this.has("hidden")
  }
  compile(compileSettings) {
   if (this.isHidden) return ""
   this.compileSettings = compileSettings
   const { className } = this
   const classAttr = className ? `class="${this.className}"` : ""
   const tag = this.get("tag") || this.tag
   if (tag === "none") // Allow no tag for aftertext in tables
     return this.text
   return this.getHtmlRequirements(compileSettings) + `<${tag} ${this.divAttributes}${classAttr}>${this.text}</${tag}>`
  }
  get divAttributes() {
   const attrs = this.filter(particle => particle.isAttribute)
   return attrs.length ? attrs.map(particle => particle.divAttributes).join(" ") + " " : ""
  }
paragraphParser
 // todo Perhaps rewrite this from scratch and move out of aftertext.
 extends abstractAftertextParser
 catchAllCellType stringCell
 description A paragraph.
 boolean suggestInAutocomplete false
 cruxFromId
 javascript
  compile(compileSettings) {
   if (this.isHidden) return ""
   // Hacky, I know.
   const newLine = this.has("inlineMarkupsOn") ? undefined : this.appendLine("inlineMarkupsOn")
   const compiled = super.compile(compileSettings)
   if (newLine)
    newLine.destroy()
   return compiled
  }
  compileTxt() {
    const children = this.filter(particle => particle.compileTxt).map(particle => particle.compileTxt()).filter(i => i).join("\n")
    const dateline = this.getParticle("dateline")
    return (dateline ? dateline.day + "\n\n" : "") + (this.originalText || "") + (children ? "\n " + children.replace(/\n/g, "\n ") : "")
  }
authorsParser
 popularity 0.007379
 // multiple authors delimited by " and "
 boolean isPopular true
 extends paragraphParser
 description Set author(s) name(s).
 example
  authors Breck Yunits
   https://breckyunits.com Breck Yunits
 // note: once we have mixins in Parsers, lets mixin the below from abstractTopLevelSingleMetaParser
 cells metaCommandWordCell
 javascript
  isTopMatter = true
  isSetterParser = true
  compileHtmlForPrint() {
    // hacky. todo: cleanup
    const originalContent = this.content
    this.setContent(`by ${originalContent}`)
    const html = super.compile()
    this.setContent(originalContent)
    return html
  }
  compileTxtForPrint() {
    return 'by ' + super.compileTxt()
  }
  compile() {
   return ""
  }
  compileTxt() {
    return ""
  }
  defaultClassName = "scrollByLine"
blinkParser
 description Just for fun.
 extends paragraphParser
 example
  blink Carpe diem!
 crux blink
 javascript
  compile() {
   return `<span class="scrollBlink">${super.compile()}</span>
    <script>setInterval(()=>{ Array.from(document.getElementsByClassName("scrollBlink")).forEach(el => el.style.visibility = el.style.visibility === "hidden" ? "visible" : "hidden") }, 500)</script>`
  }
scrollButtonParser
 extends paragraphParser
 crux button
 description A button.
 example
  button Click me
 javascript
  defaultClassName = "scrollButton"
  tag = "button"
catchAllParagraphParser
 popularity 0.115562
 description A paragraph.
 extends paragraphParser
 boolean suggestInAutocomplete false
 boolean isPopular true
 cells stringCell
 javascript
  getErrors() {
    const errors = super.getErrors() || []
    return this.parent.has("testStrict") ? errors.concat(this.makeError(`catchAllParagraphParser should not have any matches when testing with testStrict.`)) : errors
  }
  get originalText() {
   return this.getLine() || ""
  }
scrollCenterParser
 popularity 0.006415
 crux center
 description A centered section.
 extends paragraphParser
 example
  center
  This paragraph is centered.
 javascript
  compile() {
   this.parent.sectionStack.push("</center>")
   return `<center>${super.compile()}`
  }
  compileTxt() {
    return this.content
  }
abstractIndentableParagraphParser
 extends paragraphParser
 inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser abstractIndentableParagraphParser
 javascript
  compileChildren() {
    return this.map(particle => particle.compile())
     .join("\n")
     .trim()
  }
  compile() {
   return super.compile() + this.compileChildren()
  }
  compileTxt() {
    return this.getWord(0) + " " + super.compileTxt()
  }
checklistTodoParser
 popularity 0.000193
 extends abstractIndentableParagraphParser
 example
  [] Get milk
 description A task todo.
 crux []
 string checked 
 javascript
  get text() {
   return `<div style="text-indent:${(this.getIndentLevel() - 1) * 20}px;"><input type="checkbox" ${this.checked} id="${this.id}"><label for="${this.id}">` + super.text + `</label></div>`
  }
  get id() {
   return this.get("id") || "item" + this._getUid()
  }
checklistDoneParser
 popularity 0.000072
 extends checklistTodoParser
 description A completed task.
 string checked checked
 crux [x]
 example
  [x] get milk
listAftertextParser
 popularity 0.014325
 extends abstractIndentableParagraphParser
 example
  - I had a _new_ thought.
 description A list item.
 crux -
 javascript
  defaultClassName = ""
  compile() {
   const index = this.getIndex()
   const parent = this.parent
   const particleClass = this.constructor
   const isStartOfList = index === 0 || !(parent.particleAt(index - 1) instanceof particleClass)
   const isEndOfList = parent.length === index + 1 || !(parent.particleAt(index + 1) instanceof particleClass)
   const { listType } = this
   return (isStartOfList ? `<${listType} ${this.attributes}>` : "") + `${super.compile()}` + (isEndOfList ? `</${listType}>` : "")
  }
  get attributes() {
    return ""
  }
  tag = "li"
  listType = "ul"
abstractCustomListItemParser
 extends listAftertextParser
 javascript
  get requireOnce() {
    return `<style>\n.${this.constructor.name} li::marker {content: "${this.firstWord} ";}\n</style>`
  }
  get attributes() {
    return `class="${this.constructor.name}"`
  }
orderedListAftertextParser
 popularity 0.004485
 extends listAftertextParser
 description A list item.
 example
  1. Hello world
 pattern ^\d+\. 
 javascript
  listType = "ol"
  get attributes() { return ` start="${this.getWord(0)}"`}
quickQuoteParser
 popularity 0.000482
 crux >
 example
  > The only thing we have to fear is fear itself. - FDR
 boolean isPopular true
 extends abstractIndentableParagraphParser
 description A quote.
 javascript
  defaultClassName = "scrollQuote"
  tag = "blockquote"
scrollCounterParser
 description Just for fun.
 extends paragraphParser
 crux counter
 example
  counter 4.5 Babies Born
 cells commandWordCell numberCell
 javascript
  compile() {
   const line = this.getLine()
   const words = line.split(" ")
   words.shift() // drop the counter word
   const perSecond = parseFloat(words.shift()) // get number
   const increment = perSecond/10
   const id = this._getUid()
   this.setLine(`* <span id="counter${id}" title="0">0</span><script>setInterval(()=>{ const el = document.getElementById('counter${id}'); el.title = parseFloat(el.title) + ${increment}; el.textContent = Math.ceil(parseFloat(el.title)).toLocaleString()}, 100)</script> ` + words.join(" "))
   const html = super.compile()
   this.setLine(line)
   return html
  }
expanderParser
 popularity 0.000072
 cruxFromId
 description An collapsible HTML details tag.
 extends paragraphParser
 example
  expander Knock Knock
  Who's there?
 javascript
  compile() {
   this.parent.sectionStack.push("</details>")
   return `<details>${super.compile()}`
  }
  compileTxt() {
    return this.content
  }
  tag = "summary"
  defaultClassName = ""
footnoteDefinitionParser
 popularity 0.001953
 description A footnote. Can also be used as section notes.
 extends paragraphParser
 boolean isFootnote true
 pattern ^\^.+$
 // We need to quickLinks back in scope because there is currently a bug in ScrollSDK/parsers where if a parser extending a parent class has a child parser defined, then any regex parsers in the parent class will not be tested unless explicitly included in scope again.
 inScope quickLinkParser
 labelParser
  description If you want to show a custom label for a footnote. Default label is the note definition index.
  cruxFromId
  cells commandWordCell
  catchAllCellType stringCell
 javascript
  get divAttributes() {
   return super.divAttributes + ` id="${this.anchorId}"`
  }
  get anchorId() {
   return `note${this.noteDefinitionIndex}`
  }
  get label() {
   // In the future we could allow common practices like author name
   return this.get("label") || `[${this.noteDefinitionIndex}]`
  }
  get linkBack() {
   return `noteUsage${this.noteDefinitionIndex}`
  }
  get text() {
   return `<a class="scrollFootNoteUsageLink" href="#noteUsage${this.noteDefinitionIndex}">${this.label}</a> ${super.text}`
  }
  get noteDefinitionIndex() {
   return this.parent.footnotes.indexOf(this) + 1
  }
  compileTxt() {
    return this.getWord(0) + ": " + super.compileTxt()
  }
abstractHeaderParser
 extends paragraphParser
 example
  # Hello world
 javascript
  compile(compileSettings) {
   if (this.isHidden) return ""
   if (this.parent.sectionStack)
    this.parent.sectionStack.push("</div>")
   return `<div class="scrollSection">` + super.compile(compileSettings)
  }
  compileTxt() {
    const line = super.compileTxt()
    return line + "\n" + "=".repeat(line.length)
  }
  isHeader = true
h1Parser
 popularity 0.017918
 description An html h1 tag.
 extends abstractHeaderParser
 crux #
 boolean isPopular true
 javascript
  tag = "h1"
h2Parser
 popularity 0.005257
 description An html h2 tag.
 extends abstractHeaderParser
 crux ##
 boolean isPopular true
 javascript
  tag = "h2"
h3Parser
 popularity 0.001085
 description An html h3 tag.
 extends abstractHeaderParser
 crux ###
 javascript
  tag = "h3"
h4Parser
 popularity 0.000289
 description An html h4 tag.
 extends abstractHeaderParser
 crux ####
 javascript
  tag = "h4"
scrollQuestionParser
 popularity 0.004244
 description A question.
 extends h4Parser
 crux ?
 example
  ? Why is the sky blue?
 javascript
  defaultClassName = "scrollQuestion"
h5Parser
 description An html h5 tag.
 extends abstractHeaderParser
 crux #####
 javascript
  tag = "h5"
printTitleParser
 popularity 0.007572
 description Print title.
 extends abstractHeaderParser
 boolean isPopular true
 example
  title Eureka
  printTitle
 cruxFromId
 javascript
  compile(compileSettings) {
   // Hacky, I know.
   const {content} = this
   if (content === undefined)
    this.setContent(this.root.title)
   const { permalink } = this.root
   if (!permalink) {
    this.setContent(content) // Restore it as it was.
    return super.compile(compileSettings)
   }
   const newLine = this.appendLine(`link ${permalink}`)
   const compiled = super.compile(compileSettings)
   newLine.destroy()
   this.setContent(content) // Restore it as it was.
   return compiled
  }
  get originalText() {
   return this.content ?? this.root.title ?? ""
  }
  defaultClassName = "scrollTitle"
  tag = "h1"
captionAftertextParser
 popularity 0.003207
 description An image caption.
 crux caption
 extends paragraphParser
 boolean isPopular true
abstractMediaParser
 extends paragraphParser
 inScope scrollMediaLoopParser scrollAutoplayParser
 javascript
  compileTxt() {
    return ""
  }
  get filename() {
    return this.getWord(1)
  }
  getAsHtmlAttribute(attr) {
    if (!this.has(attr)) return ""
    const value = this.get(attr)
    return value ? `${attr}="${value}"` : attr
  }
  getAsHtmlAttributes(list) {
    return list.map(word => this.getAsHtmlAttribute(word)).filter(i => i).join(" ")
  }
  compile() {
    return `<${this.tag} src="${this.filename}" controls ${this.getAsHtmlAttributes("width height loop autoplay".split(" "))}></${this.tag}>`
  }
scrollSoundParser
 popularity 0.000024
 extends abstractMediaParser
 crux music
 description Play sound files.
 example
  music sipOfCoffee.m4a
 javascript
  compile() {
    return `<audio controls ${this.getAsHtmlAttributes("loop autoplay".split(" "))}><source src="${this.filename}" type="audio/mpeg"></audio>`
  }
scrollVideoParser
 popularity 0.000024
 extends abstractMediaParser
 crux video
 example
  video spirit.mp4
 description Play video files.
 widthParser
  cruxFromId
  cells commandWordCell
 heightParser
  cruxFromId
  cells commandWordCell
 javascript
  tag = "video"
quickParagraphParser
 popularity 0.001881
 crux *
 extends paragraphParser
 description A paragraph.
 example
  * I had a _new_ idea.
thinColumnsParser
 popularity 0.003690
 extends abstractAftertextParser
 cruxFromId
 catchAllCellType integerCell
 description Thin columns.
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  columnWidth = 35
  columnGap = 20
  compile() {
   const {columnWidth, columnGap, maxColumns} = this
   const maxTotalWidth = maxColumns * columnWidth + (maxColumns - 1) * columnGap
   const stackContents = this.parent.clearSectionStack() // Starting columns always first clears the section stack.
   if (this.singleColumn) this.parent.sectionStack.push("</div>") // Single columns are self-closing after section break.
   return stackContents + `<div class="scrollColumns" style="column-width:${columnWidth}ch;column-count:${maxColumns};max-width:${maxTotalWidth}ch;">`
  }
  get maxColumns() {
    return this.singleColumn ? 1 : parseInt(this.getWord(1) ?? 10)
  }
wideColumnsParser
 popularity 0.000386
 extends thinColumnsParser
 description Wide columns.
 javascript
  columnWidth = 90
wideColumnParser
 popularity 0.003376
 extends wideColumnsParser
 description A wide column section.
 boolean singleColumn true
mediumColumnsParser
 popularity 0.003376
 extends thinColumnsParser
 description Medium width columns.
 javascript
  columnWidth = 65
mediumColumnParser
 popularity 0.003376
 extends mediumColumnsParser
 description A medium column section.
 boolean singleColumn true
thinColumnParser
 popularity 0.003376
 extends thinColumnsParser
 description A thin column section.
 boolean singleColumn true
endColumnsParser
 popularity 0.007789
 extends abstractAftertextParser
 cruxFromId
 description End columns.
 javascript
  compile() {
   return "</div>"
  }
  compileEmbeddedVersion() {
   return ""
  }
abstractDinkusParser
 extends abstractAftertextParser
 boolean isDinkus true
 javascript
  compile() {
   return `<div class="${this.defaultClass}"><span>${this.dinkus}</span></div>`
  }
  defaultClass = "dinkus"
  compileTxt() {
    return this.dinkus
  }
  get dinkus() {
    return this.content || this.getLine()
  }
horizontalRuleParser
 popularity 0.000362
 crux ---
 description A horizontal rule.
 extends abstractDinkusParser
 javascript
  compile() {
   return `<hr>`
  }
scrollDinkusParser
 popularity 0.010828
 crux ***
 description A dinkus. Breaks section.
 boolean isPopular true
 extends abstractDinkusParser
 javascript
  dinkus = "*"
customDinkusParser
 crux dinkus
 description A custom dinkus.
 extends abstractDinkusParser
endOfPostDinkusParser
 popularity 0.005740
 extends abstractDinkusParser
 description End of post dinkus.
 boolean isPopular true
 crux ****
 javascript
  dinkus = "⁂"
abstractIconButtonParser
 extends abstractAftertextParser
 cruxFromId
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
    return `<style>.abstractIconButtonParser {position:absolute;top:0.25rem; }.abstractIconButtonParser svg {fill: rgba(204,204,204,.8);width:1.875rem;height:1.875rem; padding: 0 7px;} .abstractIconButtonParser:hover svg{fill: #333;}</style><a href="${this.link}" class="doNotPrint abstractIconButtonParser" style="${this.style}">${this.svg}</a>`
  }
downloadButtonParser
 popularity 0.006294
 description Link to download/WWS page.
 extends abstractIconButtonParser
 catchAllCellType urlCell
 string style position:relative;
 string svg <svg fill="#000000" xmlns="http://www.w3.org/2000/svg" width="800px" height="800px" viewBox="0 0 52 52" enable-background="new 0 0 52 52" xml:space="preserve"><path d="M38.6,20.4c-1-6.5-6.7-11.5-13.5-11.5c-7.6,0-13.7,6.1-13.7,13.7c0,0.3,0,0.7,0.1,1c-5,0.4-8.9,4.6-8.9,9.6 c0,5.4,4.3,9.7,9.7,9.7h11.5c-0.8-0.8-8.1-8.1-8.1-8.1c-0.4-0.4-0.4-0.9,0-1.3l1.3-1.3c0.4-0.4,0.9-0.4,1.3,0l3.5,3.5 c0.4,0.4,1.1,0.1,1.1-0.4V21.8c0-0.4,0.5-0.9,1-0.9h1.9c0.5,0,0.9,0.4,0.9,0.9v13.4c0,0.6,0.8,0.8,1.1,0.4l3.5-3.5 c0.4-0.4,0.9-0.4,1.3,0l1.3,1.3c0.4,0.4,0.4,0.9,0,1.3L26,42.9h12.3v0c6.1-0.1,11-5.1,11-11.3C49.4,25.5,44.6,20.6,38.6,20.4z"/></svg><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->
 javascript
  get link() {
    return this.content
  }
emailButtonParser
 popularity 0.006294
 description Email button.
 extends abstractIconButtonParser
 catchAllCellType emailAddressCell
 // todo: should just be "optionalCellType"
 string style position:relative;
 string svg <svg viewBox="3 5 24 20" width="24" height="20" xmlns="http://www.w3.org/2000/svg"><g transform="matrix(1, 0, 0, 1, 0, -289.0625)"><path style="opacity:1;stroke:none;stroke-width:0.49999997;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1" d="M 5 5 C 4.2955948 5 3.6803238 5.3628126 3.3242188 5.9101562 L 14.292969 16.878906 C 14.696939 17.282876 15.303061 17.282876 15.707031 16.878906 L 26.675781 5.9101562 C 26.319676 5.3628126 25.704405 5 25 5 L 5 5 z M 3 8.4140625 L 3 23 C 3 24.108 3.892 25 5 25 L 25 25 C 26.108 25 27 24.108 27 23 L 27 8.4140625 L 17.121094 18.292969 C 15.958108 19.455959 14.041892 19.455959 12.878906 18.292969 L 3 8.4140625 z " transform="translate(0,289.0625)" id="rect4592"/></g></svg>
 javascript
  get link() {
    const email = this.content || this.parent.get("email")
    return email ? `mailto:${email}` : ""
  }
homeButtonParser
 popularity 0.006391
 description Home button.
 extends abstractIconButtonParser
 catchAllCellType urlCell
 string style left:2rem;
 string svg <svg role="img" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path d="M12.7166 3.79541C12.2835 3.49716 11.7165 3.49716 11.2834 3.79541L4.14336 8.7121C3.81027 8.94146 3.60747 9.31108 3.59247 9.70797C3.54064 11.0799 3.4857 13.4824 3.63658 15.1877C3.7504 16.4742 4.05336 18.1747 4.29944 19.4256C4.41371 20.0066 4.91937 20.4284 5.52037 20.4284H8.84433C8.98594 20.4284 9.10074 20.3111 9.10074 20.1665V15.9754C9.10074 14.9627 9.90433 14.1417 10.8956 14.1417H13.4091C14.4004 14.1417 15.204 14.9627 15.204 15.9754V20.1665C15.204 20.3111 15.3188 20.4284 15.4604 20.4284H18.4796C19.0806 20.4284 19.5863 20.0066 19.7006 19.4256C19.9466 18.1747 20.2496 16.4742 20.3634 15.1877C20.5143 13.4824 20.4594 11.0799 20.4075 9.70797C20.3925 9.31108 20.1897 8.94146 19.8566 8.7121L12.7166 3.79541ZM10.4235 2.49217C11.3764 1.83602 12.6236 1.83602 13.5765 2.49217L20.7165 7.40886C21.4457 7.91098 21.9104 8.73651 21.9448 9.64736C21.9966 11.0178 22.0564 13.5119 21.8956 15.3292C21.7738 16.7067 21.4561 18.4786 21.2089 19.7353C20.9461 21.0711 19.7924 22.0001 18.4796 22.0001H15.4604C14.4691 22.0001 13.6655 21.1791 13.6655 20.1665V15.9754C13.6655 15.8307 13.5507 15.7134 13.4091 15.7134H10.8956C10.754 15.7134 10.6392 15.8307 10.6392 15.9754V20.1665C10.6392 21.1791 9.83561 22.0001 8.84433 22.0001H5.52037C4.20761 22.0001 3.05389 21.0711 2.79113 19.7353C2.54392 18.4786 2.22624 16.7067 2.10437 15.3292C1.94358 13.5119 2.00338 11.0178 2.05515 9.64736C2.08957 8.73652 2.55427 7.91098 3.28346 7.40886L10.4235 2.49217Z"/></svg>
 javascript
  get link() {
    return this.content || this.get("link") || "index.html"
  }
viewSourceButtonParser
 popularity 0.013963
 description Print badge top right.
 extends abstractIconButtonParser
 string svg <svg xmlns="http://www.w3.org/2000/svg" width="92pt" height="92pt" viewBox="0 0 92 92"><path d="M90.156 41.965 50.036 1.848a5.913 5.913 0 0 0-8.368 0l-8.332 8.332 10.566 10.566a7.03 7.03 0 0 1 7.23 1.684 7.043 7.043 0 0 1 1.673 7.277l10.183 10.184a7.026 7.026 0 0 1 7.278 1.672 7.04 7.04 0 0 1 0 9.957 7.045 7.045 0 0 1-9.961 0 7.038 7.038 0 0 1-1.532-7.66l-9.5-9.497V59.36a7.04 7.04 0 0 1 1.86 11.29 7.04 7.04 0 0 1-9.957 0 7.04 7.04 0 0 1 0-9.958 7.034 7.034 0 0 1 2.308-1.539V33.926a7.001 7.001 0 0 1-2.308-1.535 7.049 7.049 0 0 1-1.516-7.7L29.242 14.273 1.734 41.777a5.918 5.918 0 0 0 0 8.371L41.855 90.27a5.92 5.92 0 0 0 8.368 0l39.933-39.934a5.925 5.925 0 0 0 0-8.371"/></svg>
 javascript
  get link() {
    return this.parent.file?.viewSourceUrl || ""
  }
  get style() {
    return this.parent.findParticles("viewSourceButton")[0] === this ? "right:2rem;": "position:relative;"
  }
classicFormParser
 crux classicForm
 popularity 0.006391
 description Generate input form for ScrollSet.
 extends abstractAftertextParser
 string style
  <style> .scrollFormParser {
      font-family: "Gill Sans", "Bitstream Vera Sans", sans-serif;
    }
  .scrollFormParser input , .scrollFormParser textarea{
  padding: 10px;
  margin-bottom: 10px;
  width: 100%;
  box-sizing: border-box;
  } .scrollFormParser label {
    display: block;
    margin-bottom: 5px;
  }
  </style>
 javascript
  get inputs() {
    const {measures} = this.parent.file
    return measures.filter(measure => !measure.IsComputed).map((measure, index) => {
      const {Name, Question, IsRequired, Type} = measure
      const type = Type || "text"
      const placeholder = Question
      const ucFirst = Name.substr(0, 1).toUpperCase() + Name.substr(1)
      // ${index ? "" : "autofocus"}
      let tag = ""
      if (Type === "textarea")
        tag = `<textarea placeholder="${placeholder}" id="${Name}" name="${Name}" ${IsRequired ? "required" : ""}></textarea>`
      else
        tag = `<input placeholder="${placeholder}" type="${type}" id="${Name}" name="${Name}" ${IsRequired ? "required" : ""}>`
      return `<div><label for="${Name}" title="${IsRequired ? "Required" : ""}">${ucFirst}${IsRequired ? "*" : ""}:</label>${tag}</div>`
    }).join("\n")
  }
  compile() {
    return `${this.style}<form class="scrollFormParser" method="get" action="${this.action}">${this.inputs}<button class="scrollButton" type="submit">Submit</button></form>`
  }
  get action() {
    return this.getWord(1) || ""
  }
scrollFormParser
 extends classicFormParser
 crux scrollForm
 description Generate a Scroll Form.
 string copyFromExternal codeMirror.css scrollLibs.js
 string requireOnce
  <link rel="stylesheet" href="codeMirror.css">
  <script src="scrollLibs.js"></script>
 javascript
  get inputs() {
    const placeholder = ""
    const Name = "scroll"
    return `<textarea rows="${this.parent.file.measures.length * 2}" placeholder="${placeholder}" id="${Name}" name="${Name}"></textarea>
    <script id="${Name}Parsers" type="text/plain">${this.parent.file.parsersBundle}</script>
    <script>{
    let {width, height} = document.getElementById('${Name}').getBoundingClientRect();
    const scrollParser = new HandParsersProgram(document.getElementById("${Name}Parsers").textContent).compileAndReturnRootParser()
    const codeMirrorInstance = new ParsersCodeMirrorMode("custom", () => scrollParser, undefined, CodeMirror).register().fromTextAreaWithAutocomplete(document.getElementById("${Name}"), {
      lineWrapping: false,
      lineNumbers: false
    })
    codeMirrorInstance.setSize(width, height) }</script>`
  }
  compile(compileSettings) {
    return this.getHtmlRequirements(compileSettings) + super.compile()
  }
loopParser
 popularity 0.000024
 extends abstractAftertextParser
 cells commandWordCell
 description Iterate over files+ to make HTML.
 cruxFromId
 inScope abstractItemsProviderParser
 joinParser
  extends abstractLoopConfigParser
  description HTML to use to join the items.
 limitParser
  extends abstractLoopConfigParser
  description HTML to use to join the items.
 javascriptParser
  extends abstractLoopConfigParser
  description Javascript to execute for each file in the loop.
 javascript
  compile() {
   const code = this.get("javascript")
   const joinWith = this.get("join") ?? ""
   try {
    const limit = this.get("limit")
    let items = this.items
    if (limit) items = items.slice(0, parseInt(limit))
    return items.map((item, index) => eval(code)).join(joinWith)
   } catch (err) {
    console.error(err)
    return ""
   } finally {
    this.teardown()
   }
  }
  get items() {
   const provider = this.getChildInstancesOfParserId("abstractItemsProviderParser")[0]
   return provider ? provider.items : []
  }
  teardown() {}
loremIpsumParser
 extends abstractAftertextParser
 cruxFromId
 description Generate dummy text.
 catchAllCellType integerCell
 javascript
  text = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`
  compile() {
   return this.text.repeat(this.howMany)
  }
  get howMany() {
    return this.getWord(1) ? parseInt(this.getWord(1)) : 1
  }
nickelbackIpsumParser
 extends loremIpsumParser
 javascript
  text = `And one day, I’ll be at the door. And lose your wings to fall in love? To the bottom of every bottle. I’m on the ledge of the eighteenth story. Why must the blind always lead the blind?`
abstractTextLinkParser
 extends abstractAftertextParser
 cruxFromId
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compileTxt() {
    return this.text
  }
  compile() {
   return `<a class="abstractTextLinkParser" href="${this.link}">${this.text}</a>`
  }
scrollVersionLinkParser
 popularity 0.006294
 extends abstractTextLinkParser
 string link https://scroll.pub
 description Print Scroll version.
 javascript
  get text() {
    return `Built with Scroll v${this.parent.file?.SCROLL_VERSION || ""}`
  }
viewSourceLinkParser
 popularity 0.001206
 extends abstractTextLinkParser
 description Print "View source" link.
 string text View source
 javascript
  get link() {
    return this.parent.file?.viewSourceUrl || ""
  }
printSnippetsParser
 popularity 0.000338
 // todo: why are we extending AT here and not loops? Is it for class/id etc?
 extends abstractAftertextParser
 cruxFromId
 cells commandWordCell
 catchAllCellType tagWithOptionalFolderCell
 description Prints snippets matching tag(s).
 example
  printSnippets index
 javascript
  makeSnippet(file, compileSettings) {
    const {scrollProgram, endSnippetIndex} = file
    if (endSnippetIndex === -1) return scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml
    const linkRelativeToCompileTarget = compileSettings.relativePath + file.permalink
    const joinChar = "\n"
    const html = scrollProgram
        .map((child, index) => (index >= endSnippetIndex ? "" : child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))
        .filter(i => i)
        .join(joinChar)
        .trim() +
      `<a class="scrollContinueReadingLink" href="${linkRelativeToCompileTarget}">Continue reading...</a>`
    return html
  }
  get files() {
   const thisFile = this.parent.file
   const files = this.parent.file.getFilesWithTagsForEmbedding(this.getWordsFrom(1), this.has("limit") ? parseInt(this.get("limit")) : undefined).filter(file => file.file !== thisFile)
   // allow sortBy lastCommit Time
   if (this.get("sortBy") === "commitTime") {
     return require("lodash").sortBy(files, file => file.file.lastCommitTime).reverse()
   }
   return files
  }
  compile() {
   const alreadyRequired = this.root.alreadyRequired
   const snippets = this.files.map(file => {
    const compileSettings = {relativePath: file.relativePath, alreadyRequired }
    return `<div class="scrollSnippetContainer">${this.makeSnippet(file.file, compileSettings)}</div>`
    }).join("\n\n")
   return `<div class="scrollColumns" style="column-width:35ch;">${snippets}</div>`
  }
  compileTxt() {
   return this.files.map(file =>  {
    const title = file.file.title
    const ruler = "=".repeat(title.length)
    // Note: I tried to print the description here but the description generating code needs work.
    return `${title}\n${ruler}\n${file.file.date}\n${file.file.absoluteLink}`
   }).join("\n\n")
  }
printFullSnippetsParser
 popularity 0.000048
 extends printSnippetsParser
 cruxFromId
 description Print full pages in group(s).
 javascript
  makeSnippet(file, compileSettings) {
   return file.scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml
  }
printRelatedParser
 popularity 0.001182
 description Print links to related posts.
 extends printSnippetsParser
 cruxFromId
 javascript
  compile() {
   const alreadyRequired = this.root.alreadyRequired
   const list = this.files.map(fileWrapper => {
    const {relativePath, file} = fileWrapper
    const {title, permalink, year} = file
    return `- ${title}${year ? " (" + year + ")" : ""}\n link ${relativePath + permalink}`
    }).join("\n")
    const items = this.parent.concat(list)
    const html = items.map(item => item.compile()).join("\n")
    items.forEach(item => item.destroy())
   return html
  }
printSourceStackParser
 // useful for debugging
 description Print compilation steps.
 extends abstractAftertextParser
 cruxFromId
 example
  printOriginalSource
 javascript
  get sources() {
    const {file} = this.root
    const passNames = ["codeAtStart", "codeAfterImportPass", "codeAfterMacroPass"]
    let lastCode = ""
    return passNames.map(name => {
      let code = file[name]
      if (lastCode === code)
        code = "[Unchanged]"
      lastCode = file[name]
      return {
      name,
      code
    }})
  }
  compile() {
   return `<code class="scrollCodeBlock">${this.compileTxt().replace(/\</g, "&lt;")}</code>`
  }
  compileTxt() {
   return this.sources.map((pass, index) => `Pass ${index + 1} - ${pass.name}\n========\n${pass.code}`).join("\n\n\n")
  }
abstractPrintMetaParser
 extends abstractScrollParser
 cruxFromId
printAuthorsParser
 popularity 0.001664
 description Prints author(s) byline.
 boolean isPopular true
 extends abstractPrintMetaParser
 // todo: we need pattern matching added to sdk to support having no params or a url and personNameCell
 catchAllCellType anyCell
 example
  authors Breck Yunits
   https://breckyunits.com
  printAuthors
 javascript
  compile() {
   return this.parent.getParticle("authors")?.compileHtmlForPrint()
  }
  compileTxt() {
    return this.parent.getParticle("authors")?.compileTxtForPrint()
  }
printDateParser
 popularity 0.000434
 extends abstractPrintMetaParser
 // If not present computes the date from the file's ctime.
 description Print published date.
 boolean isPopular true
 javascript
  compile() {
   return `<div style="text-align: center;" class="scrollDateline">${this.day}</div>`
  }
  get day() {
   let day = this.content || this.root.get("date") || this.root.file?.date
   if (!day) return ""
   try {
    const dayjs = require("dayjs")
    return dayjs(day).format(`MMMM D, YYYY`)
   } catch (err) {
    console.error(err)
   }
   return day || ""
  }
  compileTxt() {
    return this.day
  }
printFormatLinksParser
 description Prints links to other formats.
 extends abstractPrintMetaParser
 example
  printFormatLinks
 javascript
  compile() {
   const permalink = this.root.file.permalink.replace(".html", "")
   // hacky
   const particle = this.appendSibling(`HTML | TXT`, `class scrollDateline\nlink ${permalink}.html HTML\nlink ${permalink}.txt TXT\nstyle text-align:center;`)
   const html = particle.compile()
   particle.destroy()
   return html
  }
  compileTxt() {
    const permalink = this.root.file.permalink.replace(".html", "")
    return `HTML | TXT\n link ${permalink}.html HTML\n link ${permalink}.txt TXT`
  }
abstractBuildCommandParser
 extends abstractScrollParser
 cruxFromId
 cells buildCommandWordCell
 catchAllCellType filePathCell
 inScope slashCommentParser
 javascript
  isTopMatter = true
  compile() {
   return ""
  }
loadConceptsParser
 // todo: clean this up. just add smarter imports with globs?
 // this currently removes any "import" statements.
 description Import all concepts in a folder.
 extends abstractBuildCommandParser
 cruxFromId
 cells preBuildCommandWordCell filePathCell
 javascript
  build() {
   const { Disk } = require("scrollsdk/products/Disk.node.js")
   const path = require("path")
   const {file} = this.parent
   const folder = path.join(file.folderPath, this.getWord(1))
   const ONE_BIG_FILE = Disk.getFiles(folder).filter(file => file.endsWith(".scroll")).map(Disk.read).filter(str => /^id /mg.test(str)).join("\n\n").replace(/import .+/g, "")
    this.parent.concat(ONE_BIG_FILE)
   //console.log(ONE_BIG_FILE)
  }
  compile() {
    return ""
  }
buildConceptsParser
 popularity 0.000024
 cruxFromId
 description Write concepts to csv+ files.
 extends abstractBuildCommandParser
 sortByParser
  cruxFromId
  cells commandWordCell anyCell
buildCssParser
 popularity 0.000048
 description Compile to CSS file.
 extends abstractBuildCommandParser
buildCsvParser
 popularity 0.000096
 description Compile to CSV file.
 extends abstractBuildCommandParser
fetchParser
 description Download URL to disk.
 extends abstractBuildCommandParser
 cruxFromId
 cells preBuildCommandWordCell urlCell
 example
  fetch https://breckyunits.com/posts.csv
  fetch https://breckyunits.com/posts.csv renamed.csv
 javascript
  get url() {
    return this.getWord(1)
  }
  get filename() {
    return this.getWord(2) || new URL(this.url).pathname.split('/').pop()
  }
  get fullDiskPath() {
    return require("path").join(this.parent.file.folderPath, this.filename)
  }
  get exists() {
    return this.isNodeJs() ? require("fs").existsSync(this.fullDiskPath) : localStorage.getItem(this.filename)
  }
  async downloadToDisk() {
    const { writeFile } = require('fs').promises
    const response = await fetch(this.url)
    const fileBuffer = await response.arrayBuffer()
    await writeFile(this.fullDiskPath, Buffer.from(fileBuffer))
  }
  async downloadToLocalStorage() {
    const response = await fetch(this.url)
    const blob = await response.blob()
    localStorage.setItem(this.filename, await blob.text())
  }
  async build() {
   if (this.exists) return "" // do not fetch if already have a copy
    await this.isNodeJs() ? this.downloadToDisk() : this.downloadToLocalStorage()
  }
  compile() {
    return ""
  }
buildHtmlParser
 popularity 0.007645
 description Compile to HTML file.
 extends abstractBuildCommandParser
 boolean isPopular true
buildMeasuresParser
 popularity 0.000024
 cruxFromId
 description Write measures to csv+ files.
 extends abstractBuildCommandParser
 sortByParser
  cruxFromId
  cells commandWordCell anyCell
buildPdfParser
 popularity 0.000096
 description Compile to PDF file.
 extends abstractBuildCommandParser
buildRssParser
 popularity 0.000048
 description Write RSS file.
 extends abstractBuildCommandParser
buildJsParser
 description Compile to JS file.
 extends abstractBuildCommandParser
buildTxtParser
 popularity 0.007596
 description Compile to TXT file.
 extends abstractBuildCommandParser
 boolean isPopular true
chatParser
 popularity 0.000362
 description A faux text chat conversation.
 catchAllParser chatLineParser
 cruxFromId
 extends abstractScrollParser
 example
  chat
   Hi
   👋
 javascript
  compile() {
   return this.map((line, index) => line.asString ? `<div style="text-align: ${index % 2 ? "right" : "left"};" class="scrollChat ${index % 2 ? "scrollChatRight" : "scrollChatLeft"}"><span>${line.asString}</span></div>` : "").join("")
  }
  compileTxt() {
    return this.childrenToString()
  }
codeParser
 popularity 0.001929
 description A code block.
 catchAllParser lineOfCodeParser
 extends abstractScrollParser
 boolean isPopular true
 example
  code
   two = 1 + 1
 javascript
  compile() {
   return `<code class="scrollCodeBlock">${this.childrenToString().replace(/\</g, "&lt;")}</code>`
  }
  compileTxt() {
    return this.childrenToString()
  }
 cruxFromId
codeWithHeaderParser
 popularity 0.000169
 cruxFromId
 catchAllCellType stringCell
 extends codeParser
 example
  codeWithHeader math.py
   two = 1 + 1
 javascript
  compile() {
   return `<div class="codeWithHeader"><div class="codeHeader">${this.content}</div>${super.compile()}</div>`
  }
codeWithLanguageParser
 popularity 0.000458
 description Use this to specify the language of the code block, such as csvCode or rustCode.
 extends codeParser
 pattern ^[a-zA-Z0-9_]+Code$
abstractScrollWithRequirementsParser
 extends abstractScrollParser
 cruxFromId
 javascript
  compile(compileSettings) {
    return this.getHtmlRequirements(compileSettings) + this.compileInstance()
  }
copyButtonsParser
 popularity 0.001471
 extends abstractScrollWithRequirementsParser
 description Copy code widget.
 javascript
  compileInstance() {
   return ""
  }
 string requireOnce
  <script>
  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollCodeBlock").forEach(block =>
   {
    if (!navigator.clipboard) return
    const button = document.createElement("span")
    button.classList.add("scrollCopyButton")
    block.appendChild(button)
    button.addEventListener("click", async () => {
      await navigator.clipboard.writeText(block.innerText)
      button.classList.add("scrollCopiedButton")
    })
   }
  ))
  </script>
abstractTableVisualizationParser
 extends abstractScrollWithRequirementsParser
 boolean isTableVisualization true
 javascript
  get columnNames() {
    return this.parent.columnNames
  }
heatrixParser
 cruxFromId
 example
  heatrix
   '2007 '2008 '2009 '2010 '2011 '2012 '2013 '2014 '2015 '2016 '2017 '2018 '2019 '2020 '2021 '2022 '2023 '2024
   4 11 23 37 3 14 12 0 0 0 5 1 2 11 15 10 12 56
 description A heatmap matrix data visualization.
 catchAllParser heatrixCatchAllParser
 extends abstractTableVisualizationParser
 javascript
  compile() {
   // A hacky but simple way to do this for now.
   const advanced = new Particle("heatrixAdvanced")
   advanced.appendLineAndChildren("table", "\n " + this.tableData.replace(/\n/g, "\n "))
   const particle = this.appendSibling("heatrixAdvanced", advanced.childrenToString())
   const html = particle.compile()
   particle.destroy()
   return html
  }
  get tableData() {
    const {coreTable} = this.parent
    if (!coreTable)
      return this.childrenToString()
    let table = new Particle(coreTable).asSsv
    if (this.parent.firstWord === "transpose") {
      // drop first line after transpose
      const lines = table.split("\n")
      lines.shift()
      table = lines.join("\n")
    }
    // detect years and make strings
    const lines = table.split("\n")
    const yearLine = / \d{4}(\s+\d{4})+$/
    if (yearLine.test(lines[0])) {
      lines[0] = lines[0].replace(/ /g, " '")
      table = lines.join("\n")
    }
    return table
  }
heatrixAdvancedParser
 popularity 0.000048
 cruxFromId
 catchAllParser heatrixCatchAllParser
 extends abstractTableVisualizationParser
 description Advanced heatrix.
 example
  heatrix
   table
     
    %h10; '2007 '2008 '2009
     12 4 323
   scale
    #ebedf0 0
    #c7e9c0 100
    #a1d99b 400
    #74c476 1600
 javascript
  compile() {
  class Heatrix {
    static HeatrixId = 0
    uid = Heatrix.HeatrixId++
    constructor(program) {
      const isDirective = word => /^(f|l|w|h)\d+$/.test(word) || word === "right" || word === "left" || word.startsWith("http://") || word.startsWith("https://") || word.endsWith(".html")
      const particle = new Particle(program)
      this.program = particle
      const generateColorBinningString = (data, colors) => {
       const sortedData = [...data].sort((a, b) => a - b);
       const n = sortedData.length;
       const numBins = colors.length;
       // Calculate the indices for each quantile
       const indices = [];
       for (let i = 1; i < numBins; i++) {
         indices.push(Math.floor((i / numBins) * n));
       }
       // Get the quantile values and round them
       const thresholds = indices.map(index => Math.round(sortedData[index]));
       // Generate the string
       let result = '';
       colors.forEach((color, index) => {
         const threshold = index === colors.length - 1 ? thresholds[index - 1] * 2 : thresholds[index];
         result += `${color} ${threshold}\n`;
       });
       return result.trim();
      }
      const buildScale = (table) => {
        const numbers = table.split("\n").map(line => line.split(" ")).flat().filter(word => !isDirective(word)).map(word => parseFloat(word)).filter(number => !isNaN(number))
        const colors = ['#ebedf0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#005a32'];
        numbers.unshift(0)
        return generateColorBinningString(numbers, colors);
      }
      const table = particle.getParticle("table").childrenToString()
      const scale = particle.getParticle("scale")?.childrenToString() || buildScale(table)
      const thresholds = []
      const colors = []
      scale.split("\n").map((line) => {
        const parts = line.split(" ")
        thresholds.push(parseFloat(parts[1]))
        colors.push(parts[0])
      })
      const colorCount = colors.length
      const colorFunction = (value) => {
        if (isNaN(value)) return "" // #ebedf0
        for (let index = 0; index < colorCount; index++) {
          const threshold = thresholds[index]
          if (value <= threshold) return colors[index]
        }
        return colors[colorCount - 1]
      }
      const directiveDelimiter = ";"
      const getSize = (directives, letter) =>
        directives
          .filter((directive) => directive.startsWith(letter))
          .map((dir) => dir.replace(letter, "") + "px")[0] ?? ""
      this.table = table.split("\n").map((line) =>
        line
          .trimEnd()
          .split(" ")
          .map((cell) => {
            const words = cell.split(directiveDelimiter).filter((word) => !isDirective(word)).join("")
            const directivesInThisCell = cell
              .split(directiveDelimiter)
              .filter(isDirective)
            const value = parseFloat(words)
            const label = words.includes("'") ? words.split("'")[1] : words
            const alignment = directivesInThisCell.includes("right")
              ? "right"
              : directivesInThisCell.includes("left")
              ? "left"
              : ""
            const color = colorFunction(value)
            const width = getSize(directivesInThisCell, "w")
            const height = getSize(directivesInThisCell, "h")
            const fontSize = getSize(directivesInThisCell, "f")
            const lineHeight = getSize(directivesInThisCell, "l") || height
            const link = directivesInThisCell.filter(i => i.startsWith("http") || i.endsWith(".html"))[0]
            const style = {
              "background-color": color,
              width,
              height,
              "font-size": fontSize,
              "line-height": lineHeight,
              "text-align": alignment,
            }
            Object.keys(style).filter(key => !style[key]).forEach((key) => delete style[key])
            return {
              value,
              label,
              style,
              link,
            }
          })
      )
    }
    get html() {
      const { program } = this
      const cssId = `#heatrix${this.uid}`
      const defaultWidth = "40px"
      const defaultHeight = "40px"
      const fontSize = "10px"
      const lineHeight = defaultHeight
      const style = `<style>
      .heatrixContainer {
        margin: auto;
      }.heatrixRow {white-space: nowrap;}
  ${cssId} .heatrixCell {
    font-family: arial;
    border-radius: 2px;
    border: 1px solid transparent;
    display: inline-block;
    margin: 1px;
    text-align: center;
    vertical-align: middle;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .heatrixCell a {
    color: black;
  }
  ${cssId} .heatrixCell{
   width: ${defaultWidth};
   height: ${defaultHeight};
   font-size: ${fontSize};
   line-height: ${lineHeight};
  }
  </style>`
      const firstRow = this.table[0]
      return (
        `<div class="heatrixContainer" id="heatrix${this.uid}">${style}` +
        this.table
          .map((row, rowIndex) => {
            if (!rowIndex) return ""
            const rowStyle = row[0].style
            return `<div class="heatrixRow heatrixRow${rowIndex}">${row
              .map((cell, columnIndex) => {
                if (!columnIndex) return ""
                const columnStyle = firstRow[columnIndex]?.style || {}
                let { value, label, style, link } = cell
                const extendedStyle = Object.assign(
                  {},
                  rowStyle,
                  columnStyle,
                  style
                )
                const inlineStyle = Object.keys(extendedStyle)
                  .map((key) => `${key}:${extendedStyle[key]};`)
                  .join("")
                let valueClass = value ? " valueCell" : ""
                const href = link ? ` href="${link}"` : ""
                return `<div class="heatrixCell heatrixColumn${columnIndex}${valueClass}" style="${inlineStyle}"><a title="${label}" ${href}>${label}</a></div>`
              })
              .join("")}</div>`
          })
          .join("\n") +
        "</div>"
      ).replace(/\n/g, "")
    }
  }
    return new Heatrix(this.childrenToString().trim()).html
  }
abstractPlotParser
 // Observablehq
 extends abstractTableVisualizationParser
 string copyFromExternal d3.js plot.js
 string requireOnce
  <script src="d3.js"></script>
  <script src="plot.js"></script>
 example
  plot
 inScope abstractColumnNameParser
 javascript
  compileInstance() {
   const id = "plot" + this._getUid()
   return `<div id="${id}"></div><script>
   {
    let loadChart = async () => {
    const data = ${this.dataCode}
    const get = (col, index ) => col !== "undefined" ? col : (index === undefined ? undefined : Object.keys(data[0])[index])
    document.querySelector("#${id}").append(Plot.plot(${this.plotOptions}))
    }
    loadChart()
    }
    </script>`
  }
  get marks() {
    // just for testing purposes
    return `Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: d3.randomNormal()}))`
  }
  get dataCode() {
    const {coreTable} = this.parent
    return `d3.csvParse(\`${new Particle(coreTable).asCsv}\`, d3.autoType)`
  }
  get plotOptions() {
    return `{
      title: "${this.get("title") || ""}",
      subtitle: "${this.get("subtitle") || ""}",
      caption: "${this.get("caption") || ""}",
      symbol: {legend: ${this.has("symbol")}},
      color: {legend: ${this.has("fill")}},
      grid: ${this.get("grid") !== "false"},
      marks: [${this.marks}],
    }`
  }
scatterplotParser
 extends abstractPlotParser
 description Scatterplot Widget.
 // todo: make copyFromExternal work with inheritance
 string copyFromExternal d3.js plot.js
 javascript
  get marks() {
    const x = this.get("x")
    const y = this.get("y")
    const text = this.get("label")
    return `Plot.dot(data, {
      x: get("${x}", 0),
      y: get("${y}", 1),
      r: get("${this.get("radius")}"),
      fill: get("${this.get("fill")}"),
      tip: true,
      symbol: get("${this.get("symbol")}")} ), Plot.text(data, {x: get("${x}",0), y: get("${y}", 1), text: "${text}", dy: -6, lineAnchor: "bottom"})`
  }
sparklineParser
 popularity 0.000024
 description Sparkline widget.
 extends abstractTableVisualizationParser
 example
  sparkline 1 2 3 4 5
 string copyFromExternal sparkline.js
 string requireOnce <script src="sparkline.js"></script>
 catchAllCellType numberCell
 // we need pattern matching
 inScope scrollYParser
 javascript
  compileInstance() {
   const id = "spark" + this._getUid()
   const {columnValues} = this
   const start = this.has("start") ? parseInt(this.get("start")) : 0
   const width = this.get("width") || 100
   const height = this.get("height") || 30
   const lineColor = this.get("color") || "black"
   return `<span id="${id}"></span><script>new Sparkline(document.getElementById("${id}"), {dotRadius: 0, width: ${width}, height: ${height}, lineColor: "${lineColor}", tooltip: (value,index) => ${start} + index + ": " + value}).draw(${JSON.stringify(columnValues)})</script>`
  }
  get columnValues() {
    if (this.content)
      return this.content.split(" ").map(str => parseFloat(str))
    const {coreTable} = this.parent
    if (coreTable) {
      const columnName = this.get("y") || Object.keys(coreTable[0]).find(key => typeof coreTable[0][key] === 'number')
      return coreTable.map(row => row[columnName])
    }
  }
printTableParser
 popularity 0.001085
 cruxFromId
 description Print table.
 extends abstractTableVisualizationParser
 javascript
  get tableHeader() {
   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\n`)
  }
  get columnNames() {
   return this.parent.columnNames
  }
  get columns() {
   const {columnNames} = this
   return columnNames.map((name, index) => {
    const isLink = name.endsWith("Link")
    const linkIndex = columnNames.indexOf(name + "Link")
    return {
     name,
     isLink,
     linkIndex
    }
   })
  }
  toRow(row) {
    const {columns} = this
    const words = columns.map(col => row[col.name])
   let str = ""
   let column = 0
   const columnCount = columns.length
   while (column < columnCount) {
    const col = columns[column]
    column++
    const content = ((columnCount === column ? words.slice(columnCount - 1).join(" ") : words[column - 1]) ?? "").toString()
    if (col.isLink) continue
    let tagged = content
    const link = words[col.linkIndex]
    const isUrl = content.match(/^https?\:[^ ]+$/)
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    else if (col.name.endsWith("Url") && isUrl) tagged = `<a href="${content}">${col.name.replace("Url", "")}</a>`
    else if (isUrl) tagged = `<a href="${content}">${content}</a>`
    str += `<td>${tagged}</td>\n`
   }
   return str
  }
  get tableBody() {
   return this.parent.coreTable
    .map(row => `<tr>${this.toRow(row)}</tr>`)
    .join("\n")
  }
  compile() {
   return `<table id="table${this._getUid()}" class="scrollTable">
   <thead><tr>${this.tableHeader.join("\n")}</tr></thead>
   <tbody>${this.tableBody}</tbody>
   </table>
   <script>
   document.querySelector('#table${this._getUid()}').addEventListener('click', e => {
    if (window.getSelection().toString() || e.target.closest('a') || !e.target.closest('tbody')) return;
    e.currentTarget.classList.toggle('expandedTable');
   });
   </script>`
  }
  compileTxt() {
    return this.parent.delimitedData || new Particle(this.parent.coreTable).asCsv
  }
katexParser
 popularity 0.001592
 extends abstractScrollWithRequirementsParser
 catchAllCellType codeCell
 catchAllParser lineOfCodeParser
 example
  katex
   \text{E} = \text{T} / \text{A}!
 description KaTex widget for typeset math.
 string copyFromExternal katex.min.css katex.min.js
 string requireOnce
  <link rel="stylesheet" href="katex.min.css">
  <script defer src="katex.min.js"></script>
  <script>
  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollKatex").forEach(el =>
   {
    katex.render(el.innerText, el, {
        throwOnError: false
    });
   }
  ))
  </script>
 javascript
  compileInstance() {
   const id = this._getUid()
   const content = this.content === undefined ? "" : this.content
   return `<div class="scrollKatex" id="${id}">${content + this.childrenToString()}</div>`
  }
  compileTxt() {
    return ( this.content ? this.content : "" )+ this.childrenToString()
  }
mapParser
 inScope latParser longParser
 zoomParser
  cells commandWordCell integerCell
  cruxFromId
  single
 heightParser
  cells commandWordCell floatCell
  cruxFromId
  single
 pointParser
  cells commandWordCell
  inScope latParser longParser
  cruxFromId
  titleParser
   extends abstractPointConfigParser
  descriptionParser
   extends abstractPointConfigParser
 extends abstractScrollWithRequirementsParser
 description Map widget.
 string copyFromExternal leaflet.css leaflet.js
 string requireOnce
  <link rel="stylesheet" href="leaflet.css">
  <script src="leaflet.js"></script>
 javascript
  compileInstance() {
   const height = 500
   const id = this._getUid()
   return `<div id="map${id}" style="height: ${height}px;"></div>
  <script>
   {
    const lat = ${this.get("lat") ?? 37.8}
    const long = ${this.get("long") ?? 4}
    const zoomLevel = ${this.get("zoom") ?? 4}
    const points = ${JSON.stringify(this.findParticles("point").map(particle => particle.toObject()))}
    const map = L.map("map${id}").setView([lat, long], zoomLevel)
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
     attribution: '<a href="https://www.openstreetmap.org/">OpenStreetMap</a>',
     maxZoom: 18
    }).addTo(map)
    points.forEach(point => {
     L.marker([point.lat, point.long])
      .addTo(map)
      .bindPopup("<b>" +point.title + "</b><br />" + point.description)
    })
   }
  </script>`
  }
helpfulNotFoundParser
 popularity 0.000048
 extends abstractScrollWithRequirementsParser
 catchAllCellType filePathCell
 string copyFromExternal helpfulNotFound.js
 description Helpful not found widget.
 javascript
  compileInstance() {
   return `<style>#helpfulNotFound{margin: 100px 0;}</style><h1 id="helpfulNotFound"></h1><script defer src="/helpfulNotFound.js"></script><script>document.addEventListener("DOMContentLoaded", () => new NotFoundApp('${this.content}'))</script>`
  }
slideshowParser
 // Left and right arrows navigate.
 description Slideshow widget. *** delimits slides.
 extends abstractScrollWithRequirementsParser
 string copyFromExternal jquery-3.7.1.min.js slideshow.js
 example
  slideshow
  Why did the cow cross the road?
  ***
  Because it wanted to go to the MOOOO-vies.
  ***
  THE END
  ****
 javascript
  compile() {
   return `<style>html {font-size: var(--base-font-size, 28px);} body {margin: auto; width: 500px;}.slideshowNav{text-align: center; margin-bottom:20px; font-size: 24px;color: rgba(204,204,204,.8);} a{text-decoration: none; color: rgba(204,204,204,.8);}</style><script defer src="jquery-3.7.1.min.js"></script><div class="slideshowNav"></div><script defer src="slideshow.js"></script>`
  }
tableSearchParser
 popularity 0.000072
 extends abstractScrollWithRequirementsParser
 string copyFromExternal jquery-3.7.1.min.js datatables.css datatables.min.js tableSearch.js
 string requireOnce
  <script defer src="jquery-3.7.1.min.js"></script>
  <style>.dt-search{font-family: "SF Pro", "Helvetica Neue", "Segoe UI", "Arial";}</style>
  <link rel="stylesheet" href="datatables.css">
  <script defer src="datatables.min.js"></script>
  <script defer src="tableSearch.js"></script>
 // adds to all tables on page
 description Table search and sort widget.
 javascript
  compileInstance() {
   return ""
  }
abstractCommentParser
 description Prints nothing.
 catchAllCellType commentCell
 cells commentCell
 extends abstractScrollParser
 baseParser blobParser
 javascript
  compile() {
   return ``
  }
 catchAllParser commentLineParser
commentParser
 popularity 0.000193
 extends abstractCommentParser
 cruxFromId
slashCommentParser
 popularity 0.005643
 extends commentParser
 crux //
 boolean isPopular true
 description A comment. Prints nothing.
counterpointParser
 description A counterpoint. Prints nothing.
 extends commentParser
 crux !
thanksToParser
 description Acknowledge reviewers. Prints nothing.
 extends abstractCommentParser
 cruxFromId
cssParser
 popularity 0.007211
 extends abstractScrollParser
 description A style tag.
 cruxFromId
 catchAllParser cssLineParser
 catchAllCellType cssAnyCell
 javascript
  compile() {
   return `<style>${this.css}</style>`
  }
  get css() {
    return this.content ?? this.childrenToString()
  }
  compileCss() {
    return this.css
  }
abstractPostLoopParser
 description Do something with all posts. Takes an optional list of folder/group names.
 extends abstractScrollParser
 cruxFromId
 cells commandWordCell
 catchAllCellType tagWithOptionalFolderCell
 javascript
  get files() {
   return this.root.file.getFilesWithTagsForEmbedding(this.getWordsFrom(1))
  }
printFeedParser
 popularity 0.000048
 description Print group to RSS.
 extends abstractPostLoopParser
 example
  printFeed index
  printFeed cars/index
  buildRss feed.xml
 javascript
  compile() {
   const dayjs = require("dayjs")
   const file = this.root.file
   const files = this.files.map(file => file.file)
   const { title, baseUrl, description } = file
   return `<?xml version="1.0" encoding="ISO-8859-1" ?>
  <rss version="2.0">
  <channel>
   <title>${title}</title>
   <link>${baseUrl}</link>
   <description>${description}</description>
   <lastBuildDate>${dayjs().format("ddd, DD MMM YYYY HH:mm:ss ZZ")}</lastBuildDate>
   <language>en-us</language>
  ${files.map(file => file.toRss()).join("\n")}
  </channel>
  </rss>`
  }
  compileTxt() {
    return this.compile()
  }
printCsvParser
 popularity 0.000024
 description Print group metadata to CSV.
 extends printFeedParser
 example
  printCsv index
  buildTxt posts.csv
 javascript
  compile() {
   const file = this.root.file
   const files = file.getFilesWithTagsForEmbedding(this.getWordsFrom(1)).map(file => file.file)
   const header = file.csvFields
   return `${header.join(",")}\n${files.map(file => file.toCsv()).join("\n")}`
  }
  compileCsv() {
    return this.compile()
  }
printSourceParser
 popularity 0.000024
 description Print source for files in group(s).
 extends printFeedParser
 example
  printSource index
  buildTxt source.txt
 javascript
  compile() {
   const file = this.root.file
   const files = file.getFilesWithTagsForEmbedding(this.getWordsFrom(1)).map(file => file.file)
   return `${files.map(file => file.filePath + "\n " + file.codeAtStart.replace(/\n/g, "\n ") ).join("\n")}`
  }
printSearchTableParser
 popularity 0.000024
 description Prints files to HTML table.
 extends abstractPostLoopParser
 example
  printSearchTable
  tableSearch
 javascript
  compile() {
   const file = this.root.file
   const files = this.files
   const data = files.map(file => file.file.toSearchTsvRow(file.relativePath)).join("\n")
   // A hacky but simple way to do this for now.
     const particle = this.appendSibling("table")
    particle.appendLine("delimiter 	")
    particle.appendLine("printTable")
    const dataParticle = particle.appendLine("data")
    dataParticle.setChildren("title titleLink text date wordCount minutes".replace(/ /g, "\t") + "\n" + data)
   const html = particle.compile()
   particle.destroy()
   return html
  }
printSiteMapParser
 popularity 0.000072
 extends abstractPostLoopParser
 description Print text sitemap.
 example
  baseUrl http://test.com
  printSiteMap
 javascript
  compile() {
   const file = this.root.file
   const { baseUrl } = file
   return this.files.map(file => baseUrl + file.relativePath + file.file.permalink).join("\n")
  }
  compileTxt() {
    return this.compile()
  }
scrollDashboardParser
 popularity 0.000145
 description Key stats in large font.
 catchAllParser lineOfCodeParser
 crux dashboard
 extends abstractScrollParser
 example
  dashboard
   #2 Popularity
   30 Years Old
   $456 Revenue
 javascript
  get tableBody() {
   const items = this.topDownArray
   let str = ""
   for (let i = 0; i < items.length; i = i + 3) {
    str += this.makeRow(items.slice(i, i + 3))
   }
   return str
  }
  makeRow(items) {
   return `<tr>` + items.map(particle => `<td>${particle.firstWord}<span>${particle.content}</span></td>`).join("\n") + `</tr>\n`
  }
  compile() {
   return `<table class="scrollDashboard">${this.tableBody}</table>`
  }
  compileTxt() {
    return this.childrenToString()
  }
abstractTopLevelSingleMetaParser
 description Use these keywords once per file.
 extends abstractScrollParser
 inScope slashCommentParser
 cruxFromId
 cells metaCommandWordCell
 javascript
  isTopMatter = true
  isSetterParser = true
  compile() {
   return ""
  }
dateParser
 popularity 0.006680
 catchAllCellType dateCell
 description Set published date.
 extends abstractTopLevelSingleMetaParser
 boolean isPopular true
 example
  date 1/11/2019
  printDate
  Hello world
   dateline
siteOwnerEmailParser
 popularity 0.001302
 description Set email address for site contact.
 extends abstractTopLevelSingleMetaParser
 crux email
 cells metaCommandWordCell emailAddressCell
importOnlyParser
 popularity 0.033569
 // This line will be not be imported into the importing file.
 description Don't build this file.
 cruxFromId
 cells preBuildCommandWordCell
 extends abstractTopLevelSingleMetaParser
 javascript
  compile() {
   return ""
  }
inlineMarkupsParser
 popularity 0.000024
 description Set global inline markups.
 extends abstractTopLevelSingleMetaParser
 cruxFromId
 example
  inlineMarkups
   * 
    // Disable * for bold
   _ u
    // Make _ underline
abstractUrlSettingParser
 extends abstractTopLevelSingleMetaParser
 cells metaCommandWordCell urlCell
 cruxFromId
canonicalUrlParser
 description Override canonical URL.
 extends abstractUrlSettingParser
openGraphImageParser
 popularity 0.000796
 // https://ogp.me/
 // If not defined, Scroll will try to generate it's own using the first image tag on your page.
 description Override Open Graph Image.
 extends abstractUrlSettingParser
baseUrlParser
 popularity 0.009188
 description Required for RSS and OpenGraph.
 extends abstractUrlSettingParser
rssFeedUrlParser
 popularity 0.008850
 description Set RSS feed URL.
 extends abstractUrlSettingParser
viewSourceBaseUrlParser
 popularity 0.007838
 description Override source link baseUrl.
 extends abstractUrlSettingParser
htmlLangParser
 cells metaCommandWordCell stringCell
 // for the <html lang=""> tag. If not specified will be "en". See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang
 description Override HTML lang attribute.
 extends abstractTopLevelSingleMetaParser
openGraphDescriptionParser
 popularity 0.001688
 catchAllCellType stringCell
 crux description
 description Meta tag description.
 extends abstractTopLevelSingleMetaParser
permalinkParser
 popularity 0.000265
 description Override output filename.
 extends abstractTopLevelSingleMetaParser
 cells metaCommandWordCell permalinkCell
scrollTagsParser
 popularity 0.006801
 crux tags
 description Set tags.
 example
  tags All
 extends abstractTopLevelSingleMetaParser
 catchAllCellType tagCell
testStrictParser
 description Make catchAllParagraphParser = error.
 extends abstractTopLevelSingleMetaParser
pageTitleParser
 popularity 0.007524
 catchAllCellType personNameCell
 crux title
 description Set title.
 example
  title Eureka
  printTitle
 extends abstractTopLevelSingleMetaParser
 boolean isPopular true
viewSourceUrlParser
 catchAllCellType urlCell
 description Override source link.
 extends abstractTopLevelSingleMetaParser
belowAsCodeParser
 popularity 0.000651
 description Print code below.
 extends abstractScrollParser
 catchAllCellType integerCell
 cruxFromId
 javascript
  method = "next"
  get code() {
   const { method } = this
   let code = ""
   
   let particles = []
   let next = this[method]
   let {howMany} = this
   while (howMany) {
    particles.push(next)
    next = next[method]
    howMany--
   }
   if (this.reverse) particles.reverse()
   return particles.map(particle => particle.asString).join("\n")
  }
  reverse = false
  compile() {
   return `<code class="scrollCodeBlock">${this.code.replace(/\</g, "&lt;")}</code>`
  }
  get howMany() {
    let howMany = parseInt(this.getWord(1))
   if (!howMany || isNaN(howMany)) howMany = 1
   return howMany
  }
belowAsCodeUntilParser
 description Print code above until match.
 extends belowAsCodeParser
 catchAllCellType anyCell
 example
  belowAsCode
  counter 1 second
 javascript
  get howMany() {
    let howMany = 1
    const query = this.content
    let particle = this.next
    while (particle !== this) {
      if (particle.getLine().startsWith(query))
        return howMany
      particle = particle.next
      howMany++
    }
    return howMany
  }
aboveAsCodeParser
 popularity 0.000482
 description Print code above.
 example
  counter 1 second
  aboveAsCode
 extends belowAsCodeParser
 javascript
  method = "previous"
  reverse = true
abstractThemeCssParser
 description Extend this to create a Scroll CSS theme.
 extends abstractScrollParser
 inScope themeTagsParser
 cruxFromId
 catchAllCellType stringCell
 string scrollStyles
  figure
   margin 0
   padding 0
  .dropcap:first-letter
   font-size 3rem
   line-height .9em
   margin-right .125rem
   display block
   float left
  .dinkus
   text-align center
   padding 1rem
   span
    vertical-align sub
  details
   margin-top 10px
  summary
   font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"
   cursor pointer
  .scrollCaptionedFigure
   display block
   break-inside avoid
   max-width 100%
   text-align center
   img
    max-width 100%
    height auto
    margin-top .1875rem
   figcaption
    font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"
    font-size .8rem
    .scrollParagraph
     margin-top 0
  .scrollCodeBlock
   overflow auto
   font-size .8rem
   hyphens none
   white-space pre
   break-inside avoid
   display block
   margin .5rem 0
   padding .5rem
   border-radius 0
   position relative
  .codeWithHeader
   break-inside avoid-column
   margin 10px 0
  .codeHeader
   font-size 80%
   text-align center
   background rgba(224, 224, 224, 0.4)
   border 1px solid rgba(204, 204, 204, 0.8)
   border-bottom 0
   margin-bottom -7px
   padding 4px 2px
   border-top-left-radius 3px
   border-top-right-radius 3px
  .scrollCodeBlock:hover
   .scrollCopyButton
    opacity .5
   .scrollCopyButton:hover
    opacity .8
   .scrollCopyButton:active
    opacity 1
  .scrollCopyButton
   position absolute
   top .125rem
   right .125rem
   font-size .875rem
   cursor pointer
   opacity 0
  .scrollCopyButton::after
   content "[ ]"
  .scrollCopiedButton::after
   content "[✓]"
 javascript
  compile() {
   return `<style>\n${this.css}\n</style>`
  }
  compileTxt() {
    return ""
  }
  compileCss() {
    return this.css
  }
  compileEmbeddedVersion() {
   return ""
  }
  get scrollCss() {
    const hakonParser = this.root.hakonParser
    return new hakonParser(this.scrollStyles).compile()
  }
gazetteCssParser
 // todo: does modern CSS have all the SCSS-esque features  we need to drop Hakon here?
 popularity 0.001375
 description Default Scroll theme CSS.
 extends abstractThemeCssParser
 javascript
  get css() {
    if (this.constructor._cachedCss)
      return this.constructor._cachedCss
    const hakonParser = this.root.hakonParser
    this.constructor._cachedCss = this.scrollCss + new hakonParser([this.hakonReset, this.hakonStandardStyles].join("\n")).compile()
    return this.constructor._cachedCss
  }
 // CSS Reset
 string hakonReset
  html,body,div,span,p,ol,ul,li,table,figure
   margin 0
   padding 0
   border 0
   vertical-align baseline
   border-spacing 0
  ol,ul
   padding-left 1rem
  li
   margin-top .4rem
   line-height 1.4
  a
   text-decoration-color transparent
   color #36c
  a:hover
   text-decoration-color initial
  .scrollButton
   background-color rgba(10,92,202,0.8)
   border-radius 6px
   color white
   padding 10px 20px
   display inline-block
   border 0
   cursor pointer
   a
    color white
   &:hover
    background-color rgb(10,92,202,0.9)
   &:active
    background-color rgb(10,92,202,1)
  sup,sub
   vertical-align baseline
   position relative
   top -.375rem
  sub
   top .375rem
  html
   padding .25rem
   background-color rgb(244,244,244)
   font-family Exchange,Georgia,serif
   color #000
   font-size var(--base-font-size, 16px)
   hyphens auto
  p
   margin-top .4rem
   line-height 1.4rem
  .scrollQuote
   break-inside avoid
   display block
   margin .5rem 0
   padding .5rem
   background rgba(204,204,204,.5)
   white-space pre-line
   border-left .5rem solid rgba(204,204,204,.8)
  code
   font-size .9rem
   background-color rgba(204,204,204,.5)
   padding .125rem .25rem
   border-radius .25rem
 // Styles for Scroll standard tags
 string hakonStandardStyles
  comment Main body of both pages is similar
  .scrollParagraph
   text-align justify
  center
   .scrollParagraph
    text-align center
  .scrollColumns
   column-count auto
   column-fill balance
   column-width 35ch
   column-gap 1.5rem
   padding-left 1.25rem
   padding-right 1.25rem
   margin auto
  comment On group pages add some spacing around files
  .scrollSnippetContainer
   padding 1ch 0
   break-inside avoid
   text-align justify
  h1,h2,h3,h4
   margin .625rem 0
  h1
   font-size 1.25rem
  h2
   font-size 1.125rem
  h3,h4
   font-size 1rem
  h1.scrollTitle
   text-align center
   margin auto
   margin-bottom .15625rem
   margin-top 0
   font-size 1.75rem
   comment On narrow browsers like phones make sure the title doesn't overlap with the icons buttons in top left and right.
   max-width calc(100vw - 2 * (1.5625rem + 1.875rem))
   a
    color #000
  .scrollDateline
   font-style italic
   line-height 1.4rem
   comment Decrease font size to deemphasize dateline but keep the line height the same to not cause different line spacing.
   font-size .75rem
  .scrollSection
   break-inside avoid
   h1,h2,h3,h4
    text-align center
  h4.scrollQuestion
   text-align left
   margin 1.4rem 0 0 0
  .scrollSection:first-child
   h1,h2,h3,h4
    margin-top 0
   h4.scrollQuestion
    margin-top 0
  .scrollNoteLink
   opacity .4
   text-decoration none
   &:hover
    opacity 1
  .scrollFootNoteUsageLink
   opacity .7
   text-decoration none
   &:hover
    opacity 1
  
  .scrollHoverNote
   text-decoration underline dashed 1px rgba(0,0,0,.1)
   cursor default
  
  .scrollCodeBlock
   border-left .5rem solid rgba(204,204,204,.8)
  
  .scrollTable
   table-layout fixed
   font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"
   margin .5rem 0
   overflow hidden
   font-size .8rem
   width 100%
   hyphens none
   border 1px solid rgba(224,224,224,.8)
   td,th
    padding .1875rem
    overflow hidden
    white-space nowrap
   th
    text-transform capitalize
    border-bottom 2px solid rgba(0,0,0,.6)
    text-align left
   td
    cursor zoom-in
   tr:nth-child(even)
    background rgba(224,224,224,.6)
  .scrollTable
   pre
    white-space nowrap
    overflow hidden
    margin 0
  .scrollTable.expandedTable
   pre
    white-space unset
    overflow unset
   table-layout unset
   background white
   position relative
   z-index 10
   overflow unset
   td,th
    overflow unset
    white-space unset
   td
    cursor zoom-out
  
  .scrollByLine
   font-size .875rem
   font-style italic
   margin .25rem 0
   text-align center
  
  comment Subtle "Article Source" link
  a.abstractTextLinkParser
   text-align center
   display block
   margin .5em auto
   font-family Verdana
   font-weight 100
   color rgba(204,204,204,.5)
   &:hover
    color #333
  
  .scrollContinueReadingLink
   display block
   text-align center
  
  .scrollDashboard
   width 100%
   font-size 1.875rem
   text-align center
   font-weight bold
   break-inside avoid
   margin-top .5rem
   margin-bottom .5rem
   td
    width 33.3%
    border 1px solid #e8e8e8
   span
    font-size 1.25rem
    display block
  .scrollChat
   span
    font-family Verdana
    margin-top .3125rem
    padding .3125rem 1.25rem
    border-radius .9375rem
    display inline-block
  .scrollChatLeft
   span
    background rgba(204,204,204, .5)
  .scrollChatRight
   span
    color white
    background rgb(0,132,255)
  .scrollYouTubeHolder
   position relative
   width 100%
   height 0
   padding-bottom 56.25%
  .scrollYouTubeEmbed
   position absolute
   top 0
   left 0
   width 100%
   height 100%
tufteCssParser
 popularity 0.000024
 // https://github.com/edwardtufte/tufte-css
 description Theme from Tufte CSS.
 extends abstractThemeCssParser
 javascript
  get css() {
    return this.scrollCss + this.tufteCss
  }
  tufteCss = `html {
     font-size: 15px;
  }
   body {
       width: 87.5%;
       margin-left: auto;
       margin-right: auto;
       padding-left: 12.5%;
       font-family: Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
       background-color: #fffff8;
       color: #111;
       max-width: 1400px;
       counter-reset: sidenote-counter;
  }
  /* Adds dark mode */
   @media (prefers-color-scheme: dark) {
       body {
           background-color: #151515;
           color: #ddd;
      }
  }
   h1 {
       font-weight: 400;
       margin-top: 3rem;
       margin-bottom: 1.5rem;
       font-size: 2.4rem;
       line-height: 1;
  }
  .scrollTitle a { text-decoration: none; font-size: 3.2rem;}
  .scrollParagraph { text-align: justify; hyphens: auto;}
  a.scrollNoteLink { text-decoration: none;}
   h2 {
       font-style: italic;
       font-weight: 400;
       margin-top: 2.1rem;
       margin-bottom: 1.4rem;
       font-size: 2.2rem;
       line-height: 1;
  }
   h3 {
       font-style: italic;
       font-weight: 400;
       font-size: 1.7rem;
       margin-top: 2rem;
       margin-bottom: 1.4rem;
       line-height: 1;
  }
   hr {
       display: block;
       height: 1px;
       width: 55%;
       border: 0;
       border-top: 1px solid #ccc;
       margin: 1em 0;
       padding: 0;
  }
   p.subtitle {
       font-style: italic;
       margin-top: 1rem;
       margin-bottom: 1rem;
       font-size: 1.8rem;
       display: block;
       line-height: 1;
  }
   .numeral {
       font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }
   .danger {
       color: red;
  }
   article {
       padding: 5rem 0rem;
  }
   section {
       padding-top: 1rem;
       padding-bottom: 1rem;
  }
   p, dl, ol, ul {
       font-size: 1.4rem;
       line-height: 2rem;
  }
   p {
       margin-top: 1.4rem;
       margin-bottom: 1.4rem;
       padding-right: 0;
       vertical-align: baseline;
  }
  /* Chapter Epigraphs */
   div.epigraph {
       margin: 5em 0;
  }
   div.epigraph > blockquote {
       margin-top: 3em;
       margin-bottom: 3em;
  }
   div.epigraph > blockquote, div.epigraph > blockquote > p {
       font-style: italic;
  }
   div.epigraph > blockquote > footer {
       font-style: normal;
  }
   div.epigraph > blockquote > footer > cite {
       font-style: italic;
  }
  /* end chapter epigraphs styles */
   blockquote {
       font-size: 1.4rem;
  }
   blockquote p {
       width: 55%;
       margin-right: 40px;
  }
   blockquote footer {
       width: 55%;
       font-size: 1.1rem;
       text-align: right;
  }
   section > p, section > footer, section > table {
       width: 55%;
  }
  /* 50 + 5 == 55, to be the same width as paragraph */
   section > dl, section > ol, section > ul {
       width: 50%;
       -webkit-padding-start: 5%;
  }
   dt:not(:first-child), li:not(:first-child) {
       margin-top: 0.25rem;
  }
  /* Links: replicate underline that clears descenders */
   a:link, a:visited {
       color: inherit;
  }
  /* Sidenotes, margin notes, figures, captions */
   img {
       max-width: 100%;
  }
   .sidenote, .marginnote {
       float: right;
       clear: right;
       margin-right: -60%;
       width: 50%;
       margin-top: 0.3rem;
       margin-bottom: 0;
       font-size: 1.1rem;
       line-height: 1.3;
       vertical-align: baseline;
       position: relative;
  }
   .sidenote-number {
       counter-increment: sidenote-counter;
  }
   .sidenote-number:after, .sidenote:before {
       font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
       position: relative;
       vertical-align: baseline;
  }
   .sidenote-number:after {
       content: counter(sidenote-counter);
       font-size: 1rem;
       top: -0.5rem;
       left: 0.1rem;
  }
   .sidenote:before {
       content: counter(sidenote-counter) " ";
       font-size: 1rem;
       top: -0.5rem;
  }
   blockquote .sidenote, blockquote .marginnote {
       margin-right: -82%;
       min-width: 59%;
       text-align: left;
  }
   div.fullwidth, table.fullwidth {
       width: 100%;
  }
   div.table-wrapper {
       overflow-x: auto;
       font-family: "Trebuchet MS", "Gill Sans", "Gill Sans MT", sans-serif;
  }
   .sans {
       font-family: "Gill Sans", "Gill Sans MT", Calibri, sans-serif;
       letter-spacing: 0.03em;
  }
   code, pre > code {
       font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
       font-size: 1rem;
       line-height: 1.42;
       -webkit-text-size-adjust: 100%;
      /* Prevent adjustments of font size after orientation changes in iOS. See https://github.com/edwardtufte/tufte-css/issues/81#issuecomment-261953409 */
  }
   .sans > code {
       font-size: 1.2rem;
  }
   h1 > code, h2 > code, h3 > code {
       font-size: 0.8em;
  }
   .marginnote > code, .sidenote > code {
       font-size: 1rem;
  }
   pre > code {
       font-size: 0.9rem;
       width: 52.5%;
       margin-left: 2.5%;
       overflow-x: auto;
       display: block;
  }
   pre.fullwidth > code {
       width: 90%;
  }
   .fullwidth {
       max-width: 90%;
       clear: both;
  }
   span.newthought {
       font-variant: small-caps;
       font-size: 1.2em;
  }
   input.margin-toggle {
       display: none;
  }
   label.sidenote-number {
       display: inline-block;
       max-height: 2rem;
      /* should be less than or equal to paragraph line-height */
  }
   label.margin-toggle:not(.sidenote-number) {
       display: none;
  }
   .iframe-wrapper {
       position: relative;
       padding-bottom: 56.25%;
      /* 16:9 */
       padding-top: 25px;
       height: 0;
  }
   .iframe-wrapper iframe {
       position: absolute;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
  }
   @media (max-width: 760px) {
       body {
           width: 84%;
           padding-left: 8%;
           padding-right: 8%;
      }
       hr, section > p, section > footer, section > table {
           width: 100%;
      }
       pre > code {
           width: 97%;
      }
       section > dl, section > ol, section > ul {
           width: 90%;
      }
       blockquote {
           margin-left: 1.5em;
           margin-right: 0em;
      }
       blockquote p, blockquote footer {
           width: 100%;
      }
       label.margin-toggle:not(.sidenote-number) {
           display: inline;
      }
       .sidenote, .marginnote {
           display: none;
      }
       .margin-toggle:checked + .sidenote, .margin-toggle:checked + .marginnote {
           display: block;
           float: left;
           left: 1rem;
           clear: both;
           width: 95%;
           margin: 1rem 2.5%;
           vertical-align: baseline;
           position: relative;
      }
       label {
           cursor: pointer;
      }
       div.table-wrapper, table {
           width: 85%;
      }
       img {
           width: 100%;
      }
  }`
abstractHtmlParser
 extends abstractScrollParser
 catchAllParser htmlLineParser
 catchAllCellType htmlAnyCell
 javascript
  compile() {
   return `${this.content ?? ""}${this.childrenToString()}`
  }
  compileTxt() {
    return ""
  }
htmlParser
 popularity 0.000048
 extends abstractHtmlParser
 description HTML one liners or blocks.
 cruxFromId
htmlInlineParser
 popularity 0.005788
 extends abstractHtmlParser
 cells htmlAnyCell
 pattern ^<
 description Inline HTML.
 boolean isPopular true
 javascript
  compile() {
   return `${this.getLine() ?? ""}${this.childrenToString()}`
  }
scrollBrParser
 popularity 0.000096
 crux br
 description A break.
 extends abstractScrollParser
 catchAllCellType integerCell
 javascript
  compile() {
   return `<br>`.repeat(parseInt(this.getWord(1) || 1))
  }
stumpParser
 cruxFromId
 extends abstractScrollParser
 description Compile Stump to HTML.
 catchAllParser stumpContentParser
 javascript
  compile() {
   const file = this.parent.file
   return file.compileStumpCode(this.childrenToString())
  }
stumpNoSnippetParser
 popularity 0.010177
 // todo: make noSnippets an aftertext directive?
 extends stumpParser
 description Compile Stump unless snippet.
 cruxFromId
 javascript
  compileEmbeddedVersion() {
   return ""
  }
abstractCaptionedParser
 extends abstractScrollParser
 cells commandWordCell urlCell
 inScope captionAftertextParser slashCommentParser
 cruxFromId
 javascript
  compile(compileSettings) {
   const caption = this.getParticle("caption")
   const captionFig = caption ? `<figcaption>${caption.compile()}</figcaption>` : ""
   const {figureWidth} = this
   const widthStyle = figureWidth ? `width:${figureWidth}px; margin: auto;` : ""
   const float = this.has("float") ? `margin: 20px; float: ${this.get("float")};` : ""
   return `<figure class="scrollCaptionedFigure" style="${widthStyle + float}">${this.getFigureContent(compileSettings)}${captionFig}</figure>`
  }
  get figureWidth() {
    return this.get("width")
  }
imageParser
 popularity 0.005908
 description An img tag.
 boolean isPopular true
 extends abstractCaptionedParser
 example
  image screenshot.png
   caption A caption.
 inScope classMarkupParser aftertextIdParser linkParser linkTargetParser
 openGraphParser
  description Add this line to make this the open graph image.
  cruxFromId
  cells commandWordCell
 javascript
  get dimensions() {
    const width = this.get("width")
    const height = this.get("height")
    if (width || height)
      return {width, height}
    if (!this.isNodeJs())
      return {}
    const src = this.filename
    // If its a local image, get the dimensions and put them in the HTML
    // to avoid flicker
   if (src.startsWith("http:") || src.startsWith("https:")) return {}
   const file = this.root.file
    if (this._dimensions)
      return this._dimensions
    try {
     const sizeOf = require("image-size")
     const path = require("path")
     const fullImagePath = path.join(file.folderPath, src)
     this._dimensions = sizeOf(fullImagePath)
     return this._dimensions
    } catch (err) {
     console.error(err)
    }
    return {}
  }
  get figureWidth() {
    return this.dimensions.width
  }
  get filename() {
    return this.getWord(1)
  }
  getFigureContent(compileSettings) {
   const file = this.root.file
   const linkRelativeToCompileTarget = (compileSettings ? (compileSettings.relativePath ?? "") : "") + this.filename
   const {width, height} = this.dimensions
   let dimensionAttributes = width || height  ? `width="${width}" height="${height}" ` : ""
   // Todo: can we reuse more code from aftertext?
   const className = this.has("class") ? ` class="${this.get("class")}" ` : ""
   const id = this.has("id") ? ` id="${this.get("id")}" ` : ""
   const clickLink = this.get("link") || linkRelativeToCompileTarget
   const target = this.has("target") ? this.get("target") : (this.has("link") ? "" : "_blank")
   return `<a href="${clickLink}" target="${target}" ${className} ${id}><img src="${linkRelativeToCompileTarget}" ${dimensionAttributes}loading="lazy"></a>`
  }
  compileTxt() {
    const children = this.filter(particle => particle.compileTxt).map(particle => particle.compileTxt()).filter(i => i).join("\n")
    return  "[Image Omitted]" + (children ? "\n " + children.replace(/\n/g, "\n ") : "")
  }
youtubeParser
 popularity 0.000121
 extends abstractCaptionedParser
 // Include the YouTube embed URL such as https://www.youtube.com/embed/CYPYZnVQoLg
 description A YouTube video widget.
 example
  youtube https://www.youtube.com/watch?v=lO8blNtYYBA
 javascript
  getFigureContent() {
   const url = this.getWord(1).replace("youtube.com/watch?v=", "youtube.com/embed/")
   return `<div class="scrollYouTubeHolder"><iframe class="scrollYouTubeEmbed" src="${url}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>`
  }
youTubeParser
 extends youtubeParser
 tags deprecate
 // Deprecated. You youtube all lowercase.
importParser
 description Import a file.
 cruxFromId
 boolean isPopular true
 cells preBuildCommandWordCell
 extends abstractScrollParser
 catchAllCellType filePathCell
 javascript
  compile() {
   return ""
  }
 example
  import header.scroll
scrollLeftRightButtonsParser
 popularity 0.006342
 crux leftRightButtons
 description Previous and next nav buttons.
 extends abstractScrollParser
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
    const file = this.parent.file
    const { linkToPrevious, linkToNext } = file
    if (!linkToPrevious) return ""
    const style = `a.keyboardNav {display:block;position:absolute;top:0.25rem; color: rgba(204,204,204,.8); font-size: 1.875rem; line-height: 1.7rem;}a.keyboardNav:hover{color: #333;text-decoration: none;}`
    return `<style>${style}</style><a class="keyboardNav doNotPrint" style="left:.5rem;" href="${linkToPrevious}">&lt;</a><a class="keyboardNav doNotPrint" style="right:.5rem;" href="${linkToPrevious}">&gt;</a>`
  }
keyboardNavParser
 popularity 0.007476
 description Make left and right navigate files.
 extends abstractScrollParser
 cruxFromId
 catchAllCellType urlCell
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const file = this.root.file
   const linkToPrevious = this.getWord(1) ?? file.linkToPrevious
   const linkToNext = this.getWord(2) ?? file.linkToNext
   const script = `<script>document.addEventListener('keydown', function(event) {
    if (document.activeElement !== document.body) return
    if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) return // dont interfere with keyboard back button shortcut
    const getLinks = () => document.getElementsByClassName("scrollKeyboardNav")[0].getElementsByTagName("a")
    if (event.key === "ArrowLeft")
      getLinks()[0].click()
    else if (event.key === "ArrowRight")
      getLinks()[1].click()
   });</script>`
   return `<div class="scrollKeyboardNav" style="display:none;"><a href="${linkToPrevious}">${linkToPrevious}</a> · ${file.permalink} · <a href="${linkToNext}">${linkToNext}</a>${script}</div>`
  }
printUsageStatsParser
 popularity 0.000096
 // todo: if we include the word "Parser" in a crux, bad things seem to happen.
 description Parser usage stats for folder.
 extends abstractScrollParser
 cruxFromId
 javascript
  get stats() {
   const input = this.root.file.allScrollFiles.map(file => file.parserIds.join("\n")).join("\n")
   const result = input.split('\n').reduce((acc, word) => (acc[word] = (acc[word] || 0) + 1, acc), {})
   const rows = Object.entries(result).map(([word, count]) => { return {word, count}})
   const sorted = this.lodash.sortBy(rows, "count").reverse()
   return "parserId uses\n" + sorted.map(row => `${row.word} ${row.count}`).join('\n')
  }
  get lodash() {
    return this.isNodeJs() ? require("lodash") : lodash
  }
  compile() {
    // A hacky but simple way to do this for now.
   const particle = this.appendSibling("table")
   particle.appendLine("delimiter  ")
   particle.appendLine("printTable")
   const dataParticle = particle.appendLine("data")
    dataParticle.setChildren(this.stats)
   const html = particle.compile()
   particle.destroy()
   return html
  }
  compileTxt() {
    return this.stats
  }
  compileCsv() {
    return this.stats.replace(/ /g, ",")
  }
printScrollLeetSheetParser
 popularity 0.000024
 description Print Scroll parser leet sheet.
 extends abstractScrollParser
 cruxFromId
 javascript
  get parsersToDocument() {
    const clone = this.root.clone()
    clone.setChildren("")
    const words = clone.getAutocompleteResultsAt(0,0).matches.map(a => a.text)
    words.push("blankline") // manually add blank line
    words.push("Catch All Paragraph.") // manually add catch all paragraph
    words.push("<h></h>") // manually add html
    words.sort()
    clone.setChildren(words.join("\n").replace(/blankline/, "")) // insert blank line in right spot
    return clone
  }
  sortDocs(docs) {
    return docs.map(particle => {
      const {definition} = particle
      const {id, description, isPopular, examples, popularity} = definition
      const tags = definition.get("tags") || ""
      if (tags.includes("deprecate") || tags.includes("experimental"))
        return null
      const category = this.getCategory(tags)
      const note = this.getNote(category)
      return {id: definition.cruxIfAny || id, description, isPopular, examples, note, popularity: Math.ceil(parseFloat(popularity) * 100000)}
     }).filter(i => i).sort((a, b) => a.id.localeCompare(b.id))
  }
  makeLink(examples, crux) {
    // if (!examples.length) console.log(crux) // find particles that need docs
    const example = examples.length ? examples[0].childrenToString() : crux
    const base = `https://try.scroll.pub/`
    const particle = new Particle()
    particle.appendLineAndChildren("scroll", "gazetteCss\n" + example)
    return base + "#" + encodeURIComponent(particle.asString)
  }
  docToHtml(doc) {
   const css = `#scrollLeetSheet {color: grey;} #scrollLeetSheet a {color: #3498db; }`
   return `<style>${css}</style><div id="scrollLeetSheet">` + doc.map(obj => `<div class="${obj.category}"><a href="${this.makeLink(obj.examples, obj.id)}">${obj.isPopular ? "<b>" : ""}${obj.id}</a> ${obj.description}${obj.isPopular ? "</b>" : ""}${obj.note}</div>`).join("\n") + "</div>"
  }
  compile() {
    return this.docToHtml(this.sortDocs(this.parsersToDocument))
  }
  compileTxt() {
   return this.sortDocs(this.parsersToDocument).map(obj => `${obj.id} - ${obj.description}`).join("\n")
  }
  get lodash() {
    return require("lodash")
  }
  getCategory(input) {
    return ""
  }
  getNote() {
    return ""
  }
  compileCsv() {
    const rows = this.sortDocs(this.parsersToDocument).map(obj => {
      const {id, isPopular, description, popularity, category} = obj
      return {
        id,
        isPopular,
        description,
        popularity,
        category
      }
    })
    return new Particle(this.lodash.sortBy(rows, "isPopular")).asCsv
  }
printparsersLeetSheetParser
 popularity 0.000024
 // todo: fix parse bug when word Parser appears in parserId
 extends printScrollLeetSheetParser
 description Parsers leetsheet.
 javascript
  compile() {
    return "<p><b>Parser Definition Parsers</b> define parsers that acquire, analyze and act on code.</p>" + this.docToHtml(this.sortDocs(this.parsersToDocument)) + "<p><b>Cell Definition Parsers</b> analyze the words in a line.</p>" + this.docToHtml(this.sortDocs(this.cellParsersToDocument))
  }
  makeLink() {
    return ""
  }
  categories = "assemblePhase acquirePhase analyzePhase actPhase".split(" ")
  getCategory(tags) {
    return tags.split(" ").filter(w => w.endsWith("Phase"))[0]
  }
  getNote(category) {
    return ` <span class="note">A${category.replace("Phase", "").substr(1)}Time.</span>`
  }
  get cellParsersToDocument() {
    const parsersParser = require("scrollsdk/products/parsers.nodejs.js")
    const clone = new parsersParser("anyCell\n ").clone()
    const parserParticle = clone.getParticle("anyCell")
    const words = clone.getAutocompleteResultsAt(1,1).matches.map(a => a.text)
    words.sort()
    parserParticle.setChildren(words.join("\n"))
    return parserParticle
  }
  get parsersToDocument() {
    const parsersParser = require("scrollsdk/products/parsers.nodejs.js")
    const clone = new parsersParser("latinParser\n ").clone()
    const parserParticle = clone.getParticle("latinParser")
    const words = clone.getAutocompleteResultsAt(1,1).matches.map(a => a.text)
    words.sort()
    parserParticle.setChildren(words.join("\n"))
    clone.appendLine("myParser")
    clone.appendLine("myCell")
    return parserParticle
  }
abstractMeasureParser
 cells measureNameCell
 cruxFromId
 boolean isMeasure true
 float sortIndex 1.9
 boolean isComputed false
 string typeForWebForms text
 extends abstractScrollParser
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   return ""
  }
  get measureValue() {
    return this.content ?? ""
  }
  get measureName() {
    return this.getFirstWordPath().replace(/ /g, "_")
  }
abstractWordMeasureParser
 description A measure that contains a single word.
 cells measureNameCell wordCell
 extends abstractMeasureParser
abstractEmailMeasureParser
 string typeForWebForms email
 cells measureNameCell emailAddressCell
 extends abstractWordMeasureParser
abstractUrlMeasureParser
 string typeForWebForms url
 cells measureNameCell urlCell
 extends abstractWordMeasureParser
abstractStringMeasureParser
 catchAllCellType stringCell
 extends abstractMeasureParser
abstractIdParser
 crux id
 description What is the ID of this concept?
 extends abstractStringMeasureParser
 float sortIndex 1
 boolean isMeasureRequired true
 boolean isConceptDelimiter true
 javascript
  getErrors() {
    const errors = super.getErrors()
    let requiredMeasureNames = this.parent.file.measures.filter(measure => measure.isMeasureRequired).map(measure => measure.Name).filter(name => name !== "id")
    if (!requiredMeasureNames.length) return errors
    let next = this.next
    while (requiredMeasureNames.length && next.firstWord !== "id" && next.getIndex() !== 0) {
      requiredMeasureNames = requiredMeasureNames.filter(i => i !== next.firstWord)
      next = next.next
    }
    requiredMeasureNames.forEach(name =>
      errors.push(this.makeError(`Concept "${this.content}" is missing required measure "${name}".`))
    )
    return errors
  }
abstractTextareaMeasureParser
 string typeForWebForms textarea
 extends abstractMeasureParser
 baseParser blobParser
 javascript
  get measureValue() {
    return this.childrenToString().replace(/\n/g, "\\n")
  }
abstractNumericMeasureParser
 string typeForWebForms number
 extends abstractMeasureParser
 javascript
  get measureValue() {
    const {content} = this
    return content === undefined ? "" : parseFloat(content)
  }
abstractIntegerMeasureParser
 cells measureNameCell integerCell
 extends abstractNumericMeasureParser
abstractFloatMeasureParser
 cells measureNameCell floatCell
 extends abstractNumericMeasureParser
abstractPercentageMeasureParser
 cells measureNameCell percentCell
 extends abstractNumericMeasureParser
 javascript
  get measureValue() {
    const {content} = this
    return content === undefined ? "" : parseFloat(content)
  }
abstractEnumMeasureParser
 cells measureNameCell enumCell
 extends abstractMeasureParser
abstractBooleanMeasureParser
 cells measureNameCell booleanCell
 extends abstractMeasureParser
 javascript
  get measureValue() {
    const {content} = this
    return content === undefined ? "" : content == "true"
  }
metaTagsParser
 popularity 0.007693
 cruxFromId
 extends abstractScrollParser
 description Print meta tags including title.
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const { title, description, openGraphImage, SCROLL_VERSION, canonicalUrl, gitRepo } = this.parent.file
   const rssFeedUrl = this.parent.get("rssFeedUrl")
   const rssTag = rssFeedUrl ? `<link rel="alternate" type="application/rss+xml" title="${title}" href="${rssFeedUrl}">` : ""
   const gitTag = gitRepo ? `<link rel="source" type="application/git" title="Source Code Repository" href="${gitRepo}">` : ""
   return `<head>
   <meta charset="utf-8">
   <title>${title}</title>
   <script>/* This HTML was generated by 📜 Scroll v${SCROLL_VERSION}. https://scroll.pub */</script>
   <style>@media print {.doNotPrint {display: none !important;}}</style>
   <link rel="canonical" href="${canonicalUrl}">
   <meta name="viewport" content="width=device-width,initial-scale=1">
   <meta name="description" content="${description}">
   <meta name="generator" content="Scroll v${SCROLL_VERSION}">
   <meta property="og:title" content="${title}">
   <meta property="og:description" content="${description}">
   <meta property="og:image" content="${openGraphImage}">
   ${gitTag}
   ${rssTag}
   <meta name="twitter:card" content="summary_large_image">
  </head>
  <body>`
  }
scrollParserDefinitionParser
 popularity 0.000096
 extends abstractScrollParser
 // todo Figure out best pattern for merging Scroll and Parsers?
 pattern ^[a-zA-Z0-9_]+Parser$
 description Define your own Parsers.
 baseParser blobParser
 javascript
  compile() {
   return ""
  }
quoteParser
 popularity 0.001471
 cruxFromId
 description A quote.
 catchAllParser quoteLineParser
 extends abstractScrollParser
 javascript
  compile() {
   return `<blockquote class="scrollQuote">${this.childrenToString()}</blockquote>`
  }
  compileTxt() {
    return this.childrenToString()
  }
redirectToParser
 popularity 0.000072
 description HTML redirect tag.
 extends abstractScrollParser
 cells commandWordCell urlCell
 cruxFromId
 example
  redirectTo https://scroll.pub/releaseNotes.html
 javascript
  compile() {
   return `<meta http-equiv="Refresh" content="0; url='${this.getWord(1)}'" />`
  }
abstractVariableParser
 extends abstractScrollParser
 catchAllCellType stringCell
 cells preBuildCommandWordCell
 cruxFromId
 javascript
  isTopMatter = true
  compile() {
   return ""
  }
replaceParser
 description Replace this with that.
 extends abstractVariableParser
 baseParser blobParser
 example
  replace YEAR 2022
replaceJsParser
 description Replace this with evaled JS.
 extends replaceParser
 catchAllCellType javascriptCell
 example
  replaceJs SUM 1+1
  * 1+1 = SUM
replaceNodejsParser
 description Replace with evaled Node.JS.
 extends abstractVariableParser
 catchAllCellType javascriptCell
 baseParser blobParser
 example
  replaceNodejs
   module.exports = {SCORE : 1 + 2}
  * The score is SCORE
scriptParser
 extends abstractScrollParser
 description Print script tag.
 cruxFromId
 catchAllParser scriptLineParser
 catchAllCellType scriptAnyCell
 javascript
  compile() {
   return `<script>${this.scriptContent}</script>`
  }
  get scriptContent() {
    return this.content ?? this.childrenToString()
  }
  compileJs() {
    return this.scriptContent
  }
endSnippetParser
 popularity 0.004293
 description Cut for snippet here.
 extends abstractScrollParser
 cruxFromId
 javascript
  compile() {
   return ""
  }
stampParser
 description Expand project template to disk.
 extends abstractScrollParser
 inScope stampFolderParser
 catchAllParser stampFileParser
 example
  stamp
   .gitignore
    *.html
   readme.scroll
    # Hello world
    <script src="scripts/nested/hello.js"></script>
   scripts/
    nested/
     hello.js
      console.log("Hello world")
 cruxFromId
 cells preBuildCommandWordCell
 javascript
  build() {
    const dir = this.root.file.folderPath
    this.forEach(particle => particle.build(dir))
  }
scrollTableParser
 popularity 0.001133
 description A table.
 crux table
 example
  table
   printTable
   data
    year,count
    1900,10
    2000,122
    2020,23
 extends abstractScrollParser
 catchAllCellType filePathCell
 inScope scrollTableDataParser scrollTableDelimiterParser abstractTableVisualizationParser abstractTableTransformParser h1Parser h2Parser scrollQuestionParser
 javascript
  get visualizations() {
    return this.topDownArray.filter(particle => particle.isTableVisualization || particle.isHeader)
  }
  compile(compileSettings) {
   return this.visualizations.map(particle => particle.compile(compileSettings))
     .join("\n")
     .trim()
  }
  compileTxt() {
    return this.visualizations.map(particle => particle.compileTxt())
     .join("\n")
     .trim()
  }
  get delimiter() {
    const {filename} = this
    let delimiter = ""
    if (filename) {
      const extension = filename.split(".").pop()
      if (extension === "json") delimiter = "json"
      if (extension === "particles") delimiter = "particles"
      if (extension === "csv") delimiter = ","
      if (extension === "tsv") delimiter = "\t"
    }
    if (this.get("delimiter"))
      delimiter = this.get("delimiter")
    else {
      const header = this.delimitedData.split("\n")[0]
      if (header.includes("\t"))
        delimiter = "\t"
      else if (header.includes(","))
       delimiter = ","
      else
       delimiter = " "
    }
    return delimiter
  }
  get filename() {
    return this.content
  }
  get fileFromDisk() {
    const path = require("path")
    const fs = require("fs")
    return fs.readFileSync(path.join(this.parent.file.folderPath, this.filename), "utf8")
  }
  get fileFromLocalStorage() {
    return localStorage.getItem(this.filename) || ""
  }
  get fileContent() {
    return this.isNodeJs() ? this.fileFromDisk : this.fileFromLocalStorage
  }
  get delimitedData() {
    // json csv tsv
    if (this.filename)
      return this.fileContent
    const dataParticle = this.getParticle("data")
    if (dataParticle)
      return dataParticle.childrenToString()
    // if not dataparticle and no filename, check [permalink].csv
    if (this.isNodeJs()) {
      const path = require("path")
      const fs = require("fs")
      const filename = this.root.permalink.replace(".html", "") + ".csv"
      const fullPath = path.join(this.parent.file.folderPath, filename)
      if (fs.existsSync(fullPath))
        return fs.readFileSync(fullPath, "utf8")
    }
    return  ""
  }
  _coreTable
  get coreTable() {
    if (this._coreTable) return this._coreTable
    const {delimiter, delimitedData} = this
    if (delimiter === "json")
       this._coreTable = JSON.parse(delimitedData)
    else if (delimiter === "particles") {
       const d3lib = typeof d3 === "undefined" ? require('d3') : d3
       this._coreTable = d3lib.dsvFormat(",").parse(new Particle(delimitedData).asCsv, d3lib.autoType)
    } else {
      const d3lib = typeof d3 === "undefined" ? require('d3') : d3
      this._coreTable = d3lib.dsvFormat(delimiter).parse(delimitedData, d3lib.autoType)
    }
    this._columnNames = this._coreTable.columns
    delete this._coreTable.columns
    return this._coreTable
  }
  get columnNames() {
    // init coreTable to set columns
    const coreTable = this.coreTable
    return this._columnNames
  }
plainTextParser
 description Plain text oneliner or block.
 cruxFromId
 extends abstractScrollParser
 catchAllParser plainTextLineParser
 catchAllCellType stringCell
 javascript
  compile() {
   return this.compileTxt()
  }
  compileTxt() {
    return `${this.content ?? ""}${this.childrenToString()}`
  }
plainTextOnlyParser
 popularity 0.000072
 extends plainTextParser
 description Only print for buildTxt.
 javascript
  compile() {
   return ""
  }
abstractAftertextAttributeParser
 cells commandWordCell
 boolean isAttribute true
 javascript
  get divAttributes() {
   return `${this.firstWord}="${this.content}"`
  }
  compile() {
   return ""
  }
aftertextIdParser
 popularity 0.000145
 crux id
 description Provide an ID to be output in the generated HTML tag.
 extends abstractAftertextAttributeParser
 cells commandWordCell htmlIdCell
 single
aftertextStyleParser
 popularity 0.000217
 crux style
 description Provide code for the generated HTML tag's "style" attribute.
 extends abstractAftertextAttributeParser
 cells commandWordCell
 catchAllCellType cssAnyCell
aftertextHiddenParser
 crux hidden
 cells commandWordCell
 description Do not compile this particle to HTML.
 extends abstractAftertextAttributeParser
 single
aftertextTagParser
 cells commandWordCell htmlTagCell
 description Override the HTML tag that the compiled particle will use.
 crux tag
 javascript
  compile() {
   return ""
  }
abstractAftertextDirectiveParser
 cells commandWordCell
 catchAllCellType stringCell
 javascript
  isMarkup = true
  compile() {
   return ""
  }
  getErrors() {
    const errors = super.getErrors()
    if (!this.isMarkup || this.matchWholeLine) return errors
    const inserts = this.getInserts(this.parent.originalTextPostLinkify)
    // todo: make AbstractParticleError class exported by sdk to allow Parsers to define their own error types.
    // todo: also need to be able to map lines back to their line in source (pre-imports)
    if (!inserts.length)
     errors.push(this.makeError(`No match found for "${this.getLine()}".`))
    return errors
  }
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get shouldMatchAll() {
   return this.has("matchAll")
  }
  getMatches(text) {
   const { pattern } = this
   const escapedPattern = pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   return [...text.matchAll(new RegExp(escapedPattern, "g"))].map(match => {
    const { index } = match
    const endIndex = index + pattern.length
    return [
     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },
     { index: endIndex, endIndex, string: `</${this.closeTag}>` }
    ]
   })
  }
  getInserts(text) {
   const matches = this.getMatches(text)
   if (!matches.length) return false
   if (this.shouldMatchAll) return matches.flat()
   const match = this.getParticle("match")
   if (match)
    return match.indexes
     .map(index => matches[index])
     .filter(i => i)
     .flat()
   return matches[0]
  }
  get allAttributes() {
   const attr = this.attributes.join(" ")
   return attr ? " " + attr : ""
  }
  get attributes() {
   return []
  }
  get openTag() {
   return this.tag
  }
  get closeTag() {
   return this.tag
  }
abstractMarkupParser
 extends abstractAftertextDirectiveParser
 inScope abstractMarkupParameterParser
 javascript
  get matchWholeLine() {
    return this.getWordsFrom(this.patternStartsAtWord).length === 0
  }
  get pattern() {
   return this.matchWholeLine ? this.parent.originalText : this.getWordsFrom(this.patternStartsAtWord).join(" ")
  }
  patternStartsAtWord = 1
boldParser
 popularity 0.000096
 cruxFromId
 description Bold matching text.
 extends abstractMarkupParser
 javascript
  tag = "b"
italicsParser
 popularity 0.000241
 cruxFromId
 description Italicize matching text.
 extends abstractMarkupParser
 javascript
  tag = "i"
underlineParser
 popularity 0.000024
 description Underline matching text.
 cruxFromId
 extends abstractMarkupParser
 javascript
  tag = "u"
afterTextCenterParser
 popularity 0.000193
 description Center paragraph.
 crux center
 extends abstractMarkupParser
 javascript
  tag = "center"
aftertextCodeParser
 popularity 0.000145
 description Wrap matching text in code span.
 crux code
 extends abstractMarkupParser
 javascript
  tag = "code"
aftertextStrikeParser
 popularity 0.000048
 description Wrap matching text in s span.
 crux strike
 extends abstractMarkupParser
 javascript
  tag = "s"
classMarkupParser
 popularity 0.000772
 description Add a custom class to the parent element instead. If matching text provided, a span with the class will be added around the matching text.
 extends abstractMarkupParser
 cells commandWordCell classNameCell
 crux class
 javascript
  tag = "span"
  get applyToParentElement() {
   return this.words.length === 2
  }
  getInserts(text) {
   // If no select text is added, set the class on the parent element.
   if (this.applyToParentElement) return []
   return super.getInserts(text)
  }
  get className() {
   return this.getWord(1)
  }
  get attributes() {
   return [`class="${this.className}"`]
  }
  get matchWholeLine() {
    return this.applyToParentElement
  }
  get pattern() {
   return this.matchWholeLine ? this.parent.content : this.getWordsFrom(2).join(" ")
  }
classesMarkupParser
 extends classMarkupParser
 crux classes
 javascript
  applyToParentElement = true
  get className() {
   return this.content
  }
hoverNoteParser
 popularity 0.000265
 description Add a caveat viewable on hover on matching text. When you want to be sure you've thoroughly addressed obvious concerns but ones that don't warrant to distract from the main argument of the text.
 cruxFromId
 extends classMarkupParser
 catchAllParser lineOfTextParser
 cells commandWordCell
 javascript
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get attributes() {
   return [`class="scrollHoverNote"`, `title="${this.hoverNoteText}"`]
  }
  get hoverNoteText() {
   return this.childrenToString().replace(/\n/g, " ")
  }
linkParser
 popularity 0.008706
 extends abstractMarkupParser
 description Put the matching text in an <a> tag.
 cells commandWordCell urlCell
 inScope linkTitleParser linkTargetParser commentParser
 programParser
  description Anything here will be URI encoded and then appended to the link.
  cruxFromId
  cells commandWordCell
  catchAllParser programLinkParser
  javascript
   get encoded() {
    return encodeURIComponent(this.childrenToString())
   }
 cruxFromId
 javascript
  tag = "a"
  compileTxt() {
    return this.root.file.ensureAbsoluteLink(this.link) + " " + this.pattern
  }
  get link() {
   const {baseLink} = this
   if (this.has("program"))
     return baseLink + this.getParticle("program").encoded
   return baseLink
  }
  get baseLink() {
   const link = this.getWord(1)
   const isAbsoluteLink = link.includes("://")
   if (isAbsoluteLink) return link
   const relativePath = this.parent.compileSettings?.relativePath || ""
   return relativePath + link
  }
  get attributes() {
   const attrs = [`href="${this.link}"`]
   const options = ["title", "target"]
   options.forEach(option => {
    const particle = this.getParticle(option)
    if (particle) attrs.push(`${option}="${particle.content}"`)
   })
   return attrs
  }
  patternStartsAtWord = 2
emailLinkParser
 popularity 0.000048
 description A mailto link
 crux email
 extends linkParser
 javascript
  get attributes() {
   return [`href="mailto:${this.link}"`]
  }
quickLinkParser
 popularity 0.029228
 pattern ^https?\:
 extends linkParser
 cells urlCell
 javascript
  get link() {
   return this.firstWord
  }
  patternStartsAtWord = 1
datelineParser
 popularity 0.006005
 cruxFromId
 description Gives your paragraph a dateline like "December 15, 2021 — The..."
 extends abstractAftertextDirectiveParser
 javascript
  getInserts() {
   const {day} = this
   if (!day) return false
   return [{ index: 0, string: `<span class="scrollDateline">${day} — </span>` }]
  }
  matchWholeLine = true
  get day() {
   let day = this.content || this.root.get("date") || this.root.file?.date
   if (!day) return ""
   try {
    const dayjs = require("dayjs")
    return dayjs(day).format(`MMMM D, YYYY`)
   } catch (err) {
    console.error(err)
   }
   return day || ""
  }
dayjsParser
 description Advanced directive that evals some Javascript code in an environment including "dayjs".
 cruxFromId
 extends abstractAftertextDirectiveParser
 javascript
  getInserts() {
   const dayjs = require("dayjs")
   const days = eval(this.content)
   const index = this.parent.originalTextPostLinkify.indexOf("days")
   return [{ index, string: `${days} ` }]
  }
inlineMarkupsOnParser
 popularity 0.000024
 cruxFromId
 description Enable these inline markups only.
 example
  Hello *world*!
   inlineMarkupsOn bold
 extends abstractAftertextDirectiveParser
 catchAllCellType inlineMarkupNameCell
 javascript
  get shouldMatchAll() {
   return true
  }
  get markups() {
    const {root} = this
    let markups = [{delimiter: "`", tag: "code", exclusive: true, name: "code"},{delimiter: "*", tag: "strong", name: "bold"}, {delimiter: "_", tag: "em", name: "italics"}]
    // only add katex markup if the root doc has katex.
    if (root.has("katex"))
      markups.unshift({delimiter: "$", tag: "span", attributes: ' class="scrollKatex"', exclusive: true, name: "katex"})
    if (this.content)
      return markups.filter(markup => this.content.includes(markup.name))
    if (root.has("inlineMarkups")) {
      root.getParticle("inlineMarkups").forEach(markup => {
        const delimiter = markup.getWord(0)
        const tag = markup.getWord(1)
        // todo: add support for providing custom functions for inline markups?
        // for example, !2+2! could run eval, or :about: could search a link map.
        const attributes = markup.getWordsFrom(2).join(" ")
        markups = markups.filter(mu => mu.delimiter !== delimiter) // Remove any overridden markups
        if (tag)
          markups.push({delimiter, tag, attributes})
      })
    }
    return markups
  }
  matchWholeLine = true
  getMatches(text) {
   const exclusives = []
   return this.markups.map(markup => this.applyMarkup(text, markup, exclusives)).filter(i => i).flat()
  }
  applyMarkup(text, markup, exclusives = []) {
   const {delimiter, tag, attributes} = markup
   const escapedDelimiter = delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, "g")
   const delimiterLength = delimiter.length
   return [...text.matchAll(pattern)].map(match => {
    const { index } = match
    const endIndex = index + match[0].length
    // I'm too lazy to clean up sdk to write a proper inline markup parser so doing this for now.
    // The exclusive idea is to not try and apply bold or italic styles inside a TeX or code inline style.
    // Note that the way this is currently implemented any TeX in an inline code will get rendered, but code
    // inline of TeX will not. Seems like an okay tradeoff until a proper refactor and cleanup can be done.
    if (exclusives.some(exclusive => index >= exclusive[0] && index <= exclusive[1]))
      return undefined
    if (markup.exclusive)
      exclusives.push([index, endIndex])
    return [
     { index, string: `<${tag + (attributes ? " " + attributes : "")}>`, endIndex, consumeStartCharacters: delimiterLength },
     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }
    ]
   }).filter(i => i)
  }
inlineMarkupParser
 popularity 0.000169
 cruxFromId
 cells commandWordCell delimiterCell tagOrUrlCell
 catchAllCellType htmlAttributesCell
 extends inlineMarkupsOnParser
 description Custom inline markup. for
 example
  @This@ will be in italics.
   inlineMarkup @ em
 javascript
  getMatches(text) {
   try {
    const delimiter = this.getWord(1)
    const tag = this.getWord(2)
    const attributes = this.getWordsFrom(3).join(" ")
    return this.applyMarkup(text, {delimiter, tag, attributes})
   } catch (err) {
    console.error(err)
    return []
   }
   // Note: doubling up doesn't work because of the consumption characters.
  }
linkifyParser
 description Use this to disable linkify on the text.
 extends abstractAftertextDirectiveParser
 cruxFromId
 cells commandWordCell booleanCell
abstractMarkupParameterParser
 cells commandWordCell
 cruxFromId
matchAllParser
 popularity 0.000024
 description Use this to match all occurrences of the text.
 extends abstractMarkupParameterParser
matchParser
 popularity 0.000048
 catchAllCellType integerCell
 description Use this to specify which index(es) to match.
 javascript
  get indexes() {
   return this.getWordsFrom(1).map(num => parseInt(num))
  }
 example
  aftertext
   hello ello ello
   bold ello
    match 0 2
 extends abstractMarkupParameterParser
abstractHtmlAttributeParser
 javascript
  compile() {
   return ""
  }
linkTargetParser
 popularity 0.000024
 extends abstractHtmlAttributeParser
 description If you want to set the target of the link. To "_blank", for example.
 crux target
 cells commandWordCell anyCell
blankLineParser
 popularity 0.308149
 description Print nothing. Break section.
 cells blankCell
 boolean isPopular true
 javascript
  compile() {
   return this.parent.clearSectionStack()
  }
 pattern ^$
 tags doNotSynthesize
chatLineParser
 popularity 0.009887
 catchAllCellType anyCell
 catchAllParser chatLineParser
lineOfCodeParser
 popularity 0.018665
 catchAllCellType codeCell
 catchAllParser lineOfCodeParser
commentLineParser
 catchAllCellType commentCell
cssLineParser
 popularity 0.002870
 catchAllCellType cssAnyCell
 catchAllParser cssLineParser
errorParser
 baseParser errorParser
abstractTableTransformParser
 cells commandWordCell
 inScope abstractTableVisualizationParser abstractTableTransformParser h1Parser h2Parser scrollQuestionParser
 javascript
  get coreTable() {
    return this.parent.coreTable
  }
  get columnNames() {
    return this.parent.columnNames
  }
  getRunTimeEnumOptions(cell) {
   if (cell.cellTypeId === "columnNameCell")
      return this.parent.columnNames
   return super.getRunTimeEnumOptions(cell)
  }
  getRunTimeEnumOptionsForValidation(cell) {
    if (cell.cellTypeId === "columnNameCell")
      return this.parent.columnNames.concat(this.parent.columnNames.map(c => "-" + c)) // Add reverse names
   return super.getRunTimeEnumOptions(cell)
  }
scrollGroupByParser
 catchAllCellType columnNameCell
 extends abstractTableTransformParser
 description Combine rows with matching values into groups.
 example
  tables posts.csv
   groupBy year
    printTable
 crux groupBy
 javascript
  get coreTable() {
    if (this._coreTable) return this._coreTable
   const groupByColNames = this.getWordsFrom(1)
   const {coreTable} = this.parent
   if (!groupByColNames.length) return coreTable
   const newCols = [].map(reduceParticle => {
    return {
     source: reduceParticle.getWord(1),
     reduction: reduceParticle.getWord(2),
     name: reduceParticle.getWord(3) || reduceParticle.getWordsFrom(1).join("_")
    }
   })
   // Pivot is shorthand for group and reduce?
   const makePivotTable = (rows, groupByColumnNames, inputColumnNames, newCols) => {
     const colMap = {}
     inputColumnNames.forEach((col) => (colMap[col] = true))
     const groupByCols = groupByColumnNames.filter((col) => colMap[col])
     return new PivotTable(rows, inputColumnNames.map(c => {return {name: c}}), newCols).getNewRows(groupByCols)
   }
   class PivotTable {
     constructor(rows, inputColumns, outputColumns) {
       this._columns = {}
       this._rows = rows
       inputColumns.forEach((col) => (this._columns[col.name] = col))
       outputColumns.forEach((col) => (this._columns[col.name] = col))
     }
     _getGroups(allRows, groupByColNames) {
       const rowsInGroups = new Map()
       allRows.forEach((row) => {
         const groupKey = groupByColNames.map((col) => row[col]?.toString().replace(/ /g, "") || "").join(" ")
         if (!rowsInGroups.has(groupKey)) rowsInGroups.set(groupKey, [])
         rowsInGroups.get(groupKey).push(row)
       })
       return rowsInGroups
     }
     getNewRows(groupByCols) {
       // make new particles
       const rowsInGroups = this._getGroups(this._rows, groupByCols)
       // Any column in the group should be reused by the children
       const columns = [
         {
           name: "count",
           type: "number",
           min: 0,
         },
       ]
       groupByCols.forEach((colName) => columns.push(this._columns[colName]))
       const colsToReduce = Object.values(this._columns).filter((col) => !!col.reduction)
       colsToReduce.forEach((col) => columns.push(col))
       // for each group
       const rows = []
       const totalGroups = rowsInGroups.size
       for (let [groupId, group] of rowsInGroups) {
         const firstRow = group[0]
         const newRow = {}
         groupByCols.forEach((col) =>
           newRow[col] = firstRow ? firstRow[col] : 0
         )
         newRow.count = group.length
         // todo: add more reductions? count, stddev, median, variance.
         colsToReduce.forEach((col) => {
           const sourceColName = col.source
           const values = group.map((row) => row[sourceColName]).filter((val) => typeof val === "number" && !isNaN(val))
           const reduction = col.reduction
           let reducedValue = firstRow[sourceColName]
           if (reduction === "sum") reducedValue = values.reduce((prev, current) => prev + current, 0)
           if (reduction === "max") reducedValue = Math.max(...values)
           if (reduction === "min") reducedValue = Math.min(...values)
           if (reduction === "mean") reducedValue = values.reduce((prev, current) => prev + current, 0) / values.length
           newRow[col.name] = reducedValue
         })
         rows.push(newRow)
       }
       // todo: add tests. figure out this api better.
       Object.values(columns).forEach((col) => {
         // For pivot columns, remove the source and reduction info for now. Treat things as immutable.
         delete col.source
         delete col.reduction
       })
       return {
         rows,
         columns,
       }
     }
   }
   const pivotTable = makePivotTable(coreTable, groupByColNames, this.parent.columnNames, newCols)
   this._coreTable = pivotTable.rows
   this._columnNames = pivotTable.columns.map(col => col.name)
   return pivotTable.rows
  }
  get columnNames() {
    const {coreTable} = this
    return this._columnNames || this.parent.columnNames
  }
scrollWhereParser
 extends abstractTableTransformParser
 description Filter rows by condition.
 crux where
 cells commandWordCell columnNameCell comparisonCell wordCell
 example
  table iris.csv
   where Species = setosa
 javascript
  get coreTable() {
   // todo: use cells here.
   const columnName = this.getWord(1)
   const operator = this.getWord(2)
   let untypedScalarValue = this.getWord(3)
   const typedValue = isNaN(parseFloat(untypedScalarValue)) ? untypedScalarValue : parseFloat(untypedScalarValue)
   const coreTable = this.parent.coreTable
   if (!columnName || !operator || untypedScalarValue === undefined) return coreTable
    const filterFn = row => {
      const cell = row[columnName]
      const typedCell = cell
      if (operator === "=") return typedValue === typedCell
      else if (operator === "!=") return typedValue !== typedCell
      else if (operator === "includes") return typedCell !== undefined && typedCell.includes(typedValue)
      else if (operator === "doesNotInclude") return typedCell === undefined || !typedCell.includes(typedValue)
      else if (operator === ">") return typedCell > typedValue
      else if (operator === "<") return typedCell < typedValue
      else if (operator === ">=") return typedCell >= typedValue
      else if (operator === "<=") return typedCell <= typedValue
      else if (operator === "empty") return cell === "" || cell === undefined
      else if (operator === "notEmpty") return !(cell === "" || cell === undefined)
    }
   return coreTable.filter(filterFn)
  }
scrollSelectParser
 catchAllCellType columnNameCell
 extends abstractTableTransformParser
 description Drop all columns except these.
 example
  tables
   data
    name,year,count
    index,2022,2
    about,2023,4
   select name year
    printTable
 crux select
 javascript
  get coreTable() {
   const {coreTable} = this.parent
   const {columnNames} = this
   if (!columnNames.length) return coreTable
   return coreTable.map(row => Object.fromEntries(columnNames.map(colName => [colName, row[colName]])))
  }
  get columnNames() {
    return this.getWordsFrom(1)
  }
scrollReverseParser
 extends abstractTableTransformParser
 description Reverse rows.
 crux reverse
 javascript
  get coreTable() {
   return this.parent.coreTable.slice().reverse()
  }
scrollTransposeParser
 extends abstractTableTransformParser
 description Tranpose table.
 crux transpose
 javascript
  get coreTable() {
   // todo: we need to switch to column based coreTable, instead of row based
   const transpose = arr => Object.keys(arr[0]).map(key => [key, ...arr.map(row => row[key])]);
   return transpose(this.parent.coreTable)
  }
scrollImputeParser
 extends abstractTableTransformParser
 description Impute missing values of a columm.
 cells commandWordCell columnNameCell
 crux impute
 javascript
  get coreTable() {
   const {lodash, columnName} = this
   const sorted = lodash.orderBy(this.parent.coreTable.slice(), columnName)
   // ascending
   const imputed = []
   let lastInserted = sorted[0][columnName]
   sorted.forEach(row => {
    const measuredTime = row[columnName]
    while (measuredTime > lastInserted + 1) {
      lastInserted++
      // synthesize rows
      const imputedRow = {}
      imputedRow[columnName] = lastInserted
      imputedRow.count = 0
      imputed.push(imputedRow)
    }
    lastInserted = measuredTime
    imputed.push(row)
   })
   return imputed
  }
  get columnName() {
    return this.getWord(1)
  }
  get lodash() {
    return this.isNodeJs() ? require("lodash") : lodash
  }
scrollOrderByParser
 extends abstractTableTransformParser
 description Sort rows by column(s).
 catchAllCellType columnNameCell
 crux orderBy
 javascript
  get coreTable() {
    const makeLodashOrderByParams = str => {
    const part1 = str.split(" ")
    const part2 = part1.map(col => (col.startsWith("-") ? "desc" : "asc"))
    return [part1.map(col => col.replace(/^\-/, "")), part2]
   }
   const orderBy = makeLodashOrderByParams(this.content)
   return this.lodash.orderBy(this.parent.coreTable.slice(), orderBy[0], orderBy[1])
  }
  get lodash() {
    return this.isNodeJs() ? require("lodash") : lodash
  }
scrollRenameParser
 // todo: add support in Parsers for tuple catch alls
  catchAllCellType columnNameCell wordCell
 catchAllCellType wordCell
 extends abstractTableTransformParser
 description Rename columns.
 example
  tables
   data
    name,year,count
    index,2022,2
   rename name Name year Year
    printTable
 crux rename
 javascript
  get coreTable() {
   const {coreTable} = this.parent
   const {renameMap} = this
   if (!Object.keys(renameMap).length) return coreTable
   return coreTable.map(row => {
      const newRow = {}
      Object.keys(row).forEach(key => {
        const name = renameMap[key] || key
        newRow[name] = row[key]
      })
      return newRow
   })
  }
  get renameMap() {
    const map = {}
    const pairs = this.getWordsFrom(1)
    let oldName
    while (oldName = pairs.shift()) {
      map[oldName] = pairs.shift()
    }
    return map
  }
  _renamed
  get columnNames() {
   if (this._renamed)
     return this._renamed
    const {renameMap} = this
    this._renamed = this.parent.columnNames.map(name => renameMap[name] || name )
    return this._renamed
  }
heatrixCatchAllParser
 popularity 0.000193
 // todo Fill this out
 catchAllCellType stringCell
lineOfTextParser
 popularity 0.000289
 catchAllCellType stringCell
 boolean isTextParser true
htmlLineParser
 popularity 0.005209
 catchAllCellType htmlAnyCell
 catchAllParser htmlLineParser
stumpContentParser
 popularity 0.102322
 catchAllCellType anyCell
linkTitleParser
 popularity 0.000048
 description If you want to set the title of the link.
 crux title
 cells commandWordCell
 catchAllCellType anyCell
 example
  * This report showed the treatment had a big impact.
   https://example.com/report This report.
    title The average growth in the treatment group was 14.2x higher than the control group.
programLinkParser
 popularity 0.000531
 catchAllCellType codeCell
abstractLoopConfigParser
 cells commandWordCell
 cruxFromId
 catchAllCellType stringCell
abstractItemsProviderParser
 cells commandWordCell
loopLinesParser
 crux lines
 extends abstractItemsProviderParser
 description Iterate over the provided lines.
 catchAllParser loopLineParser
 loopLineParser
  catchAllCellType stringCell
 javascript
  get items() {
   return this.map(particle => particle.asString)
  }
loopWordsParser
 popularity 0.000024
 crux words
 extends abstractItemsProviderParser
 catchAllCellType stringCell
 description Iterate over the provided words.
 javascript
  get items() {
   return this.getWordsFrom(1)
  }
loopTagsParser
 crux tags
 extends abstractItemsProviderParser
 catchAllCellType tagWithOptionalFolderCell
 description Set this to iterate over scroll files in a folder. Provide both the folder and group name like this: [folder]/[tag]
 javascript
  get items() {
   return this.root.file.getFilesWithTagsForEmbedding(this.getWordsFrom(1))
  }
abstractPointConfigParser
 // todo: scoped parsers should support abstract types
 cruxFromId
 cells commandWordCell
 catchAllCellType stringCell
 single
latParser
 cells commandWordCell floatCell
 cruxFromId
 single
longParser
 cells commandWordCell floatCell
 cruxFromId
 single
scrollMediaLoopParser
 popularity 0.000048
 crux loop
 cells commandWordCell
scrollAutoplayParser
 crux autoplay
 cells commandWordCell
abstractColumnNameParser
 cells commandWordCell columnNameCell
 javascript
  getRunTimeEnumOptions(cell) {
   if (cell.cellTypeId === "columnNameCell")
      return this.parent.columnNames
   return super.getRunTimeEnumOptions(cell)
  }
scrollRadiusParser
 crux radius
 extends abstractColumnNameParser
scrollSymbolParser
 crux symbol
 extends abstractColumnNameParser
scrollFillParser
 crux fill
 extends abstractColumnNameParser
scrollLabelParser
 crux label
 extends abstractColumnNameParser
scrollXParser
 crux x
 extends abstractColumnNameParser
scrollYParser
 crux y
 extends abstractColumnNameParser
quoteLineParser
 popularity 0.004172
 catchAllCellType anyCell
 catchAllParser quoteLineParser
scrollParser
 extensions scroll
 description Scroll is a language for scientists of all ages. Refine, share and collaborate on ideas.
 root
 inScope abstractScrollParser blankLineParser
 catchAllParser catchAllParagraphParser
 compilesTo html
 javascript
  setFile(file) {
   this.file = file
   return this
  }
  compile(compileSettings) {
    this.sectionStack = []
    return this.map(child => child.compile(compileSettings)).filter(i => i).join("\n") + this.clearSectionStack()
  }
  sectionStack = []
  clearSectionStack() {
   const result = this.sectionStack.join("")
   this.sectionStack = []
   return result
  }
  get hakonParser() {
    if (this.isNodeJs())
      return require("scrollsdk/products/hakon.nodejs.js")
    return hakonParser
  }
  alreadyRequired = new Set()
  compileEmbeddedVersion(compileSettings) {
   this.sectionStack = []
   return this.map(child => (child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))
     .filter(i => i)
     .join("\n")
     .trim() + this.clearSectionStack()
  }
  get footnotes() {
   if (this._footnotes === undefined) this._footnotes = this.filter(particle => particle.isFootnote)
   return this._footnotes
  }
  file = {}
  get title() {
    return this.file.title || this.get("title")
  }
  get permalink() {
   return this.get("permalink") || this.file.permalink || ""
  }
 example
  # Hello world
  ## This is Scroll
  * It compiles to HTML.
  
  code
   // You can add code as well.
   print("Hello world")
scriptLineParser
 catchAllCellType scriptAnyCell
 catchAllParser scriptLineParser
stampFileParser
 catchAllCellType stringCell
 description Create a file.
 javascript
  build(parentDir) {
   const fs = require("fs")
   const path = require("path")
   const fullPath = path.join(parentDir, this.getLine())
   this.root.file.log(`Creating file ${fullPath}`)
   fs.mkdirSync(path.dirname(fullPath), {recursive: true})
   const content = this.childrenToString()
   fs.writeFileSync(fullPath, content, "utf8")
   const isExecutable = content.startsWith("#!")
   if (isExecutable) fs.chmodSync(fullPath, "755")
  }
stampFolderParser
 catchAllCellType stringCell
 description Create a folder.
 inScope stampFolderParser
 catchAllParser stampFileParser
 pattern \/$
 javascript
  build(parentDir) {
   const fs = require("fs")
   const path = require("path")
   const newPath = path.join(parentDir, this.getLine())
   this.root.file.log(`Creating folder ${newPath}`)
   fs.mkdirSync(newPath, {recursive: true})
   this.forEach(particle => particle.build(newPath))
  }
scrollTableDataParser
 popularity 0.001061
 crux data
 description Table from inline delimited data.
 catchAllCellType anyCell
 baseParser blobParser
scrollTableDelimiterParser
 popularity 0.001037
 description Set the delimiter.
 crux delimiter
 cells commandWordCell stringCell
 javascript
  compile() {
    return ""
  }
plainTextLineParser
 popularity 0.000121
 catchAllCellType stringCell
 catchAllParser plainTextLineParser