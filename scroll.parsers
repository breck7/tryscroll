wrapNameCell
 description Options to turn on some wraps.
 enum bold italics code katex none
buildCommandWordCell
 extends commandWordCell
 description Give build command words their own color.
 highlightScope constant
blankCell
anyCell
enumCell
 highlightScope constant.language
booleanCell
 enum true false
 extends enumCell
stringCell
 highlightScope string
wordCell
 highlightScope string
 description A non-empty single word string.
 regex .+
semanticVersionCell
 highlightScope string
 description A 3 part sem version string like 1.2.1
dateCell
 highlightScope string
numberCell
 highlightScope constant.numeric
integerCell
 extends numberCell
 highlightScope constant.numeric.integer
floatCell
 extends numberCell
 highlightScope constant.numeric.float
percentCell
 highlightScope constant.numeric.float
 extends stringCell
 // todo: this currently extends from stringCell b/c scrollsdk needs to be fixed. seems like if extending from number then the hard coded number typescript regex takes precedence over a custom regex
countCell
 extends integerCell
yearCell
 extends integerCell
commandWordCell
 description A word that indicates a certain parser to use.
 highlightScope keyword
preBuildCommandWordCell
 extends commandWordCell
 description Give build command words their own color.
 highlightScope constant.character.escape
commentCell
 highlightScope comment
delimiterCell
 description String to use as a delimiter.
 highlightScope string
codeCell
 highlightScope comment
bulletPointCell
 description Any token used as a bullet point such as "-" or "1." or ">"
 highlightScope keyword
personNameCell
 extends stringCell
urlCell
 highlightScope constant.language
absoluteUrlCell
 highlightScope constant.language
 regex (ftp|https?)://.+
emailAddressCell
 extends stringCell
permalinkCell
 highlightScope string
 description A string that doesn't contain characters that might interfere with most filesystems. No slashes, for instance.
filePathCell
 extends stringCell
tagOrUrlCell
 description An HTML tag or a url.
 highlightScope constant.language
htmlAttributesCell
 highlightScope comment
htmlTagCell
 highlightScope constant.language
 enum div span p a img ul ol li h1 h2 h3 h4 h5 h6 header nav section article aside main footer input button form label select option textarea table tr td th tbody thead tfoot br hr meta link script style title code
classNameCell
 highlightScope constant
htmlIdCell
 extends anyCell
cssAnyCell
 extends anyCell
htmlAnyCell
 extends stringCell
measureNameCell
 extends commandWordCell
 // A regex for column names for max compatibility with a broad range of data science tools:
 regex [a-zA-Z][a-zA-Z0-9]*
javascriptCell
 extends stringCell
metaCommandWordCell
 extends commandWordCell
 description Give meta command words their own color.
 highlightScope constant.numeric
 // Obviously this is not numeric. But I like the green color for now.
   We need a better design to replace this "highlightScope" concept
   https://github.com/breck7/scrollsdk/issues/186
scriptAnyCell
 extends anyCell
tagCell
 extends permalinkCell
tagWithOptionalFolderCell
 description A group name optionally combined with a folder path. Only used when referencing tags, not in posts.
 extends stringCell
abstractScrollParser
 cells commandWordCell
 javascript
  compileEmbeddedVersion(compileSettings) {
   return this.compile(compileSettings)
  }
  compileTxt() {
    return ""
  }
  getHtmlRequirements(compileSettings) {
    const {requireOnce} = this
    if (!requireOnce)
      return ""
    const set = compileSettings?.alreadyRequired || this.root.alreadyRequired
    if (set.has(requireOnce))
      return ""
    
    set.add(requireOnce)
    return requireOnce + "\n\n"
  }
abstractAftertextParser
 description Text followed by markup commands.
 extends abstractScrollParser
 inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser aftertextTagParser commentParser
 example
  aftertext
   Hello brave new world
   link home.com new
   bold brave new
   underline new world
   strike wor
 javascript
  get markupInserts() {
   const { originalTextPostLinkify } = this
   return this.filter(node => node.isMarkup)
    .map(node => node.getInserts(originalTextPostLinkify))
    .filter(i => i)
    .flat()
  }
  get originalText() {
   return this.content ?? ""
  }
  get originalTextPostLinkify() {
   const { originalText } = this
   const shouldLinkify = this.get("linkify") === "false" || originalText.includes("<a ") ? false : true
   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText
  }
  replaceNotes(originalText) {
   // Skip the replacements if there are no footnotes or the text has none.
   if (!this.root.footnotes.length || !originalText.includes("^")) return originalText
   this.root.footnotes.forEach((note, index) => {
    const needle = note.firstWord
    const {linkBack} = note
    if (originalText.includes(needle)) originalText = originalText.replace(new RegExp("\\" + needle + "\\b"), `<a href="#${note.anchorId}" class="scrollNoteLink" id="${linkBack}"><sup>${note.label}</sup></a>`)
   })
   return originalText
  }
  get text() {
   const { originalTextPostLinkify, markupInserts } = this
   let adjustment = 0
   let newText = originalTextPostLinkify
   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.
   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))
   markupInserts.forEach(insertion => {
    insertion.index += adjustment
    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0
    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0
    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)
    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters
   })
   return newText
  }
  tag = "p"
  get className() {
   if (this.get("classes"))
     return this.get("classes")
   const classLine = this.getNode("class")
   if (classLine && classLine.applyToParentElement) return classLine.content
   return this.defaultClassName
  }
  defaultClassName = "scrollParagraph"
  get isHidden() {
    return this.has("hidden")
  }
  compile(compileSettings) {
   if (this.isHidden) return ""
   this.compileSettings = compileSettings
   const { className } = this
   const classAttr = className ? `class="${this.className}"` : ""
   const tag = this.get("tag") || this.tag
   if (tag === "none") // Allow no tag for aftertext in tables
     return this.text
   return this.getHtmlRequirements(compileSettings) + `<${tag} ${this.divAttributes}${classAttr}>${this.text}</${tag}>`
  }
  get divAttributes() {
   const attrs = this.filter(node => node.isAttribute)
   return attrs.length ? attrs.map(node => node.divAttributes).join(" ") + " " : ""
  }
paragraphParser
 // todo Perhaps rewrite this from scratch and move out of aftertext.
 extends abstractAftertextParser
 catchAllCellType stringCell
 description A paragraph.
 boolean suggestInAutocomplete false
 cruxFromId
 javascript
  compile(compileSettings) {
   if (this.isHidden) return ""
   // Hacky, I know.
   const newLine = this.has("wrapsOn") ? undefined : this.appendLine("wrapsOn")
   const compiled = super.compile(compileSettings)
   if (newLine)
    newLine.destroy()
   return compiled
  }
  compileTxt() {
    const children = this.filter(node => node.compileTxt).map(node => node.compileTxt()).filter(i => i).join("\n")
    const dateline = this.getNode("dateline")
    return (dateline ? dateline.day + "\n\n" : "") + (this.originalText || "") + (children ? "\n " + children.replace(/\n/g, "\n ") : "")
  }
authorsParser
 // multiple authors delimited by " and "
 boolean isPopular true
 extends paragraphParser
 description Set author(s) name(s).
 example
  authors Breck Yunits
   https://breckyunits.com Breck Yunits
 // note: once we have mixins in Parsers, lets mixin the below from abstractTopLevelSingleMetaParser
 cells metaCommandWordCell
 javascript
  isTopMatter = true
  isSetterParser = true
  compileHtmlForPrint() {
    // hacky. todo: cleanup
    const originalContent = this.content
    this.setContent(`by ${originalContent}`)
    const html = super.compile()
    this.setContent(originalContent)
    return html
  }
  compileTxtForPrint() {
    return 'by ' + super.compileTxt()
  }
  compile() {
   return ""
  }
  compileTxt() {
    return ""
  }
  defaultClassName = "scrollByLine"
blinkParser
 description Just for fun.
 extends paragraphParser
 crux blink
 javascript
  compile() {
   return `<span class="scrollBlink">${super.compile()}</span>
    <script>setInterval(()=>{ Array.from(document.getElementsByClassName("scrollBlink")).forEach(el => el.style.visibility = el.style.visibility === "hidden" ? "visible" : "hidden") }, 2000)</script>`
  }
catchAllParagraphParser
 description A paragraph.
 extends paragraphParser
 boolean suggestInAutocomplete false
 boolean isPopular true
 cells stringCell
 javascript
  getErrors() {
    const errors = super.getErrors() || []
    return this.parent.has("testStrict") ? errors.concat(this.makeError(`catchAllParagraphParser should not have any matches when testing with testStrict.`)) : errors
  }
  get originalText() {
   return this.getLine() || ""
  }
abstractIndentableParagraphParser
 extends paragraphParser
 inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser abstractIndentableParagraphParser
 javascript
  compileChildren() {
    return this.map(node => node.compile())
     .join("\n")
     .trim()
  }
  compile() {
   return super.compile() + this.compileChildren()
  }
  compileTxt() {
    return this.getWord(0) + " " + super.compileTxt()
  }
checklistTodoParser
 extends abstractIndentableParagraphParser
 example
  [] Get milk
 description A task todo.
 crux []
 string checked 
 javascript
  get text() {
   return `<div style="text-indent:${(this.getIndentLevel() - 1) * 20}px;"><input type="checkbox" ${this.checked} id="${this.id}"><label for="${this.id}">` + super.text + `</label></div>`
  }
  get id() {
   return this.get("id") || "item" + this._getUid()
  }
checklistDoneParser
 extends checklistTodoParser
 description A completed task.
 string checked checked
 crux [x]
 example
  [x] get milk
listAftertextParser
 extends abstractIndentableParagraphParser
 example
  - I had a _new_ thought.
 description A list item.
 crux -
 javascript
  defaultClassName = ""
  compile() {
   const index = this.getIndex()
   const parent = this.parent
   const nodeClass = this.constructor
   const isStartOfList = index === 0 || !(parent.nodeAt(index - 1) instanceof nodeClass)
   const isEndOfList = parent.length === index + 1 || !(parent.nodeAt(index + 1) instanceof nodeClass)
   const { listType } = this
   return (isStartOfList ? `<${listType} ${this.attributes}>` : "") + `${super.compile()}` + (isEndOfList ? `</${listType}>` : "")
  }
  get attributes() {
    return ""
  }
  tag = "li"
  listType = "ul"
abstractCustomListItemParser
 extends listAftertextParser
 javascript
  get requireOnce() {
    return `<style>\n.${this.constructor.name} li::marker {content: "${this.firstWord} ";}\n</style>`
  }
  get attributes() {
    return `class="${this.constructor.name}"`
  }
orderedListAftertextParser
 extends listAftertextParser
 description A list item.
 example
  1. Hello world
 pattern ^\d+\. 
 javascript
  listType = "ol"
  get attributes() { return ` start="${this.getWord(0)}"`}
quickQuoteParser
 crux >
 boolean isPopular true
 extends abstractIndentableParagraphParser
 description A quote.
 javascript
  defaultClassName = "scrollQuote"
  tag = "blockquote"
scrollCounterParser
 description Just for fun.
 extends paragraphParser
 crux counter
 cells commandWordCell numberCell
 javascript
  compile() {
   const line = this.getLine()
   const words = line.split(" ")
   words.shift() // drop the counter word
   const perSecond = parseFloat(words.shift()) // get number
   const increment = perSecond/10
   const id = this._getUid()
   this.setLine(`* <span id="counter${id}" title="0">0</span><script>setInterval(()=>{ const el = document.getElementById('counter${id}'); el.title = parseFloat(el.title) + ${increment}; el.textContent = Math.ceil(parseFloat(el.title)).toLocaleString()}, 100)</script> ` + words.join(" "))
   const html = super.compile()
   this.setLine(line)
   return html
  }
expanderParser
 cruxFromId
 description An collapsible HTML details tag.
 extends paragraphParser
 javascript
  compile() {
   this.parent.sectionStack.push("</details>")
   return `<details>${super.compile()}`
  }
  compileTxt() {
    return this.content
  }
  tag = "summary"
  defaultClassName = ""
footnoteDefinitionParser
 description A footnote. Can also be used as section notes.
 extends paragraphParser
 boolean isFootnote true
 pattern ^\^.+$
 // We need to quickLinks back in scope because there is currently a bug in ScrollSDK/parsers where if a parser extending a parent class has a child parser defined, then any regex parsers in the parent class will not be tested unless explicitly included in scope again.
 inScope quickLinkParser
 labelParser
  description If you want to show a custom label for a footnote. Default label is the note definition index.
  cruxFromId
  cells commandWordCell
  catchAllCellType stringCell
 javascript
  get divAttributes() {
   return super.divAttributes + ` id="${this.anchorId}"`
  }
  get anchorId() {
   return `note${this.noteDefinitionIndex}`
  }
  get label() {
   // In the future we could allow common practices like author name
   return this.get("label") || `[${this.noteDefinitionIndex}]`
  }
  get linkBack() {
   return `noteUsage${this.noteDefinitionIndex}`
  }
  get text() {
   return `<a class="scrollFootNoteUsageLink" href="#noteUsage${this.noteDefinitionIndex}">${this.label}</a> ${super.text}`
  }
  get noteDefinitionIndex() {
   return this.parent.footnotes.indexOf(this) + 1
  }
  compileTxt() {
    return this.getWord(0) + ": " + super.compileTxt()
  }
abstractHeaderParser
 extends paragraphParser
 javascript
  compile(compileSettings) {
   if (this.isHidden) return ""
   this.parent.sectionStack.push("</div>")
   return `<div class="scrollSection">` + super.compile(compileSettings)
  }
  compileTxt() {
    const line = super.compileTxt()
    return line + "\n" + "=".repeat(line.length)
  }
h1Parser
 description An html h1 tag.
 extends abstractHeaderParser
 crux #
 boolean isPopular true
 javascript
  tag = "h1"
h2Parser
 description An html h2 tag.
 extends abstractHeaderParser
 crux ##
 boolean isPopular true
 javascript
  tag = "h2"
h3Parser
 description An html h3 tag.
 extends abstractHeaderParser
 crux ###
 javascript
  tag = "h3"
h4Parser
 description An html h4 tag.
 extends abstractHeaderParser
 crux ####
 javascript
  tag = "h4"
questionAftertextParser
 description A question.
 extends h4Parser
 crux ?
 javascript
  defaultClassName = "scrollQuestion"
h5Parser
 description An html h5 tag.
 extends abstractHeaderParser
 crux #####
 javascript
  tag = "h5"
printTitleParser
 description Print title.
 extends abstractHeaderParser
 boolean isPopular true
 cruxFromId
 javascript
  compile(compileSettings) {
   // Hacky, I know.
   const {content} = this
   if (content === undefined)
    this.setContent(this.parent.file.title)
   const { permalink } = this.parent.file
   if (!permalink) {
    this.setContent(content) // Restore it as it was.
    return super.compile(compileSettings)
   }
   const newLine = this.appendLine(`link ${permalink}`)
   const compiled = super.compile(compileSettings)
   newLine.destroy()
   this.setContent(content) // Restore it as it was.
   return compiled
  }
  get originalText() {
   return this.content ?? this.parent.file.title ?? ""
  }
  defaultClassName = "scrollTitle"
  tag = "h1"
captionAftertextParser
 description An image caption.
 crux caption
 extends paragraphParser
 boolean isPopular true
quickParagraphParser
 crux *
 extends paragraphParser
 description A paragraph.
 example
  * I had a _new_ idea.
scrollCenteredParagraphParser
 // todo: does not work with gazette.
 crux center
 extends paragraphParser
 description A centered paragraph.
 example
  center Hello world
 javascript
  compile(compileSettings) {
   return `<div style="text-align:center;">${super.compile(compileSettings)}</div>`
  }
thinColumnsParser
 extends abstractAftertextParser
 cruxFromId
 catchAllCellType integerCell
 description Thin columns.
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  columnWidth = 35
  columnGap = 20
  compile() {
   const {columnWidth, columnGap} = this
   const maxColumns = parseInt(this.getWord(1) ?? 10)
   const maxTotalWidth = maxColumns * columnWidth + (maxColumns - 1) * columnGap
   // Starting the columns always first clears the section stack.
   return this.parent.clearSectionStack() + `<div class="scrollColumns" style="column-width:${columnWidth}ch;column-count:${maxColumns};max-width:${maxTotalWidth}ch;">`
  }
wideColumnsParser
 extends thinColumnsParser
 description Wide columns.
 javascript
  columnWidth = 90
mediumColumnsParser
 extends thinColumnsParser
 description Medium width columns.
 javascript
  columnWidth = 65
endColumnsParser
 extends abstractAftertextParser
 cruxFromId
 description End columns.
 javascript
  compile() {
   return "</div>"
  }
  compileEmbeddedVersion() {
   return ""
  }
abstractDinkusParser
 extends abstractAftertextParser
 string dinkus *
 boolean isDinkus true
 javascript
  compile() {
   return `<div class="dinkus"><span>${this.dinkus}</span></div>`
  }
  compileTxt() {
    return this.getLine()
  }
horizontalRuleParser
 crux ---
 description A horizontal rule.
 extends abstractDinkusParser
 javascript
  compile() {
   return `<hr>`
  }
dinkusParser
 crux ***
 description A dinkus. Breaks section.
 boolean isPopular true
 extends abstractDinkusParser
endOfPostDinkusParser
 extends abstractDinkusParser
 description End of post dinkus.
 boolean isPopular true
 crux ****
 string dinkus ⁂
loopParser
 extends abstractAftertextParser
 cells commandWordCell
 description Iterate over files+ to make HTML.
 cruxFromId
 inScope abstractItemsProviderParser
 joinParser
  extends abstractLoopConfigParser
  description HTML to use to join the items.
 limitParser
  extends abstractLoopConfigParser
  description HTML to use to join the items.
 javascriptParser
  extends abstractLoopConfigParser
  description Javascript to execute for each file in the loop.
 javascript
  compile() {
   const code = this.get("javascript")
   const joinWith = this.get("join") ?? ""
   try {
    const limit = this.get("limit")
    let items = this.items
    if (limit) items = items.slice(0, parseInt(limit))
    return items.map((item, index) => eval(code)).join(joinWith)
   } catch (err) {
    console.error(err)
    return ""
   } finally {
    this.teardown()
   }
  }
  get items() {
   const provider = this.getChildInstancesOfParserId("abstractItemsProviderParser")[0]
   return provider ? provider.items : []
  }
  teardown() {}
loremIpsumParser
 extends abstractAftertextParser
 cruxFromId
 description Generate dummy text.
 catchAllCellType integerCell
 javascript
  compile() {
   const text = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`
   return text.repeat(this.getWord(1) ? parseInt(this.getWord(1)) : 1)
  }
printSnippetsParser
 // todo: why are we extending AT here and not loops? Is it for class/id etc?
 extends abstractAftertextParser
 cruxFromId
 cells commandWordCell
 catchAllCellType tagWithOptionalFolderCell
 description Prints snippets in group(s).
 example
  printSnippets index
 javascript
  makeSnippet(file, compileSettings) {
    const {scrollProgram, endSnippetIndex} = file
    if (endSnippetIndex === -1) return scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml
    const linkRelativeToCompileTarget = compileSettings.relativePath + file.permalink
    const joinChar = "\n"
    const html = scrollProgram
        .map((child, index) => (index >= endSnippetIndex ? "" : child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))
        .filter(i => i)
        .join(joinChar)
        .trim() +
      `<a class="scrollContinueReadingLink" href="${linkRelativeToCompileTarget}">Continue reading...</a>`
    return html
  }
  get files() {
   const thisFile = this.parent.file
   return this.parent.file.getFilesWithTagsForEmbedding(this.getWordsFrom(1), this.has("limit") ? parseInt(this.get("limit")) : undefined).filter(file => file.file !== thisFile)
  }
  compile() {
   const alreadyRequired = this.root.alreadyRequired
   const snippets = this.files.map(file => {
    const compileSettings = {relativePath: file.relativePath, alreadyRequired }
    return `<div class="scrollSnippetContainer">${this.makeSnippet(file.file, compileSettings)}</div>`
    }).join("\n\n")
   return `<div class="scrollColumns" style="column-width:35ch;">${snippets}</div>`
  }
  compileTxt() {
   return this.files.map(file =>  {
    const title = file.file.title
    const ruler = "=".repeat(title.length)
    // Note: I tried to print the description here but the description generating code needs work.
    return `${title}\n${ruler}\n${file.file.date}\n${file.file.absoluteLink}`
   }).join("\n\n")
  }
printFullSnippetsParser
 extends printSnippetsParser
 cruxFromId
 description Print full pages in group(s).
 javascript
  makeSnippet(file, compileSettings) {
   return file.scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml
  }
printRelatedParser
 description Print links to related posts.
 extends printSnippetsParser
 cruxFromId
 javascript
  makeSnippet(file, compileSettings) {
    // get title, permalink, and year
    const {title, permalink, year} = file
    const node = this.appendSibling(`- ${title}${year ? " (" + year + ")" : ""}`, `link ${permalink}`)
    // A hacky but simple way to do this for now.
    const html = node.compile()
    node.destroy()
    return html
  }
printSourceStackParser
 // useful for debugging
 description Print source from each step of compilation.
 extends abstractAftertextParser
 cruxFromId
 example
  printOriginalSource
 javascript
  get sources() {
    const {file} = this.root
    const passNames = ["codeAtStart", "codeAfterImportPass", "codeAfterMacroPass"]
    return passNames.map(name => { return {
      name,
      code: file[name]
    }})
  }
  compile() {
   return `<code class="scrollCodeBlock">${this.compileTxt().replace(/\</g, "&lt;")}</code>`
  }
  compileTxt() {
   return this.sources.map((pass, index) => `Pass ${index + 1} - ${pass.name}\n========\n${pass.code}`).join("\n\n\n")
  }
printViewSourceParser
 description Print "View source" link.
 extends abstractAftertextParser
 cruxFromId
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const file = this.parent.file
   const { viewSourceUrl } = file
   return file.compileStumpCode(`p
   class scrollViewSource doNotPrint
   a View source
    href ${viewSourceUrl}`)
  }
printViewSourceBadgeParser
 description Print badge top right.
 extends abstractAftertextParser
 cruxFromId
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const file = this.parent.file
   const { viewSourceUrl, SVGS } = file
   return file.compileStumpCode(`div
   class scrollViewSourceBadge doNotPrint
   a ${SVGS.git}
    href ${viewSourceUrl}`)
  }
abstractPrintMetaParser
 extends abstractScrollParser
 cruxFromId
printAuthorsParser
 description Prints author(s) byline.
 boolean isPopular true
 extends abstractPrintMetaParser
 // todo: we need pattern matching added to sdk to support having no params or a url and personNameCell
 catchAllCellType anyCell
 example
  // With Link:
  printAuthors Breck Yunits
   https://breckyunits.com
 javascript
  compile() {
   return this.parent.getNode("authors")?.compileHtmlForPrint()
  }
  compileTxt() {
    return this.parent.getNode("authors")?.compileTxtForPrint()
  }
printDateParser
 extends abstractPrintMetaParser
 // If not present computes the date from the file's ctime.
 description Print published date.
 boolean isPopular true
 javascript
  compile() {
   return `<div style="text-align: center;" class="scrollDateline">${this.day}</div>`
  }
  get day() {
   let day = this.content || this.root.get("date") || this.root.file?.date
   if (!day) return ""
   try {
    const dayjs = require("dayjs")
    return dayjs(day).format(`MMMM D, YYYY`)
   } catch (err) {
    console.error(err)
   }
   return day || ""
  }
  compileTxt() {
    return this.day
  }
printFormatLinksParser
 description Prints links to other formats.
 extends abstractPrintMetaParser
 example
  printFormatLinks
 javascript
  compile() {
   const permalink = this.root.file.permalink.replace(".html", "")
   // hacky
   const node = this.appendSibling(`HTML | TXT`, `class scrollDateline\nlink ${permalink}.html HTML\nlink ${permalink}.txt TXT\nstyle text-align:center;`)
   const html = node.compile()
   node.destroy()
   return html
  }
  compileTxt() {
    const permalink = this.root.file.permalink.replace(".html", "")
    return `HTML | TXT\n link ${permalink}.html HTML\n link ${permalink}.txt TXT`
  }
abstractBuildCommandParser
 extends abstractScrollParser
 cruxFromId
 cells buildCommandWordCell
 catchAllCellType filePathCell
 inScope slashCommentParser
 javascript
  isTopMatter = true
  compile() {
   return ""
  }
loadConceptsParser
 // todo: clean this up. just add smarter imports with globs?
 // this currently removes any "import" statements.
 description Import all concepts in a folder.
 extends abstractBuildCommandParser
 cruxFromId
 cells preBuildCommandWordCell filePathCell
 javascript
  build() {
   const { Disk } = require("scrollsdk/products/Disk.node.js")
   const path = require("path")
   const {file} = this.parent
   const folder = path.join(file.folderPath, this.getWord(1))
   const ONE_BIG_FILE = Disk.getFiles(folder).filter(file => file.endsWith(".scroll")).map(Disk.read).filter(str => /^id /mg.test(str)).join("\n\n").replace(/import .+/g, "")
    this.parent.concat(ONE_BIG_FILE)
   //console.log(ONE_BIG_FILE)
  }
  compile() {
    return ""
  }
buildConceptsParser
 cruxFromId
 description Write concepts to csv+ files.
 extends abstractBuildCommandParser
 sortByParser
  cruxFromId
  cells commandWordCell anyCell
buildCssParser
 description Compile to CSS file.
 extends abstractBuildCommandParser
buildHtmlParser
 description Compile to HTML file.
 extends abstractBuildCommandParser
 boolean isPopular true
buildMeasuresParser
 cruxFromId
 description Write measures to csv+ files.
 extends abstractBuildCommandParser
 sortByParser
  cruxFromId
  cells commandWordCell anyCell
buildRssParser
 description Write RSS file.
 extends abstractBuildCommandParser
buildJsParser
 description Compile to JS file.
 extends abstractBuildCommandParser
buildTxtParser
 description Compile to TXT file.
 extends abstractBuildCommandParser
 boolean isPopular true
chatParser
 description A faux text chat conversation.
 catchAllParser chatLineParser
 cruxFromId
 extends abstractScrollParser
 javascript
  compile() {
   return this.map((line, index) => `<div style="text-align: ${index % 2 ? "right" : "left"};" class="scrollChat ${index % 2 ? "scrollChatRight" : "scrollChatLeft"}"><span>${line.asString}</span></div>`).join("")
  }
  compileTxt() {
    return this.childrenToString()
  }
codeParser
 description A code block.
 catchAllParser lineOfCodeParser
 extends abstractScrollParser
 boolean isPopular true
 javascript
  compile() {
   return `<code class="scrollCodeBlock">${this.childrenToString().replace(/\</g, "&lt;")}</code>`
  }
  compileTxt() {
    return this.childrenToString()
  }
 cruxFromId
codeWithHeaderParser
 cruxFromId
 catchAllCellType stringCell
 extends codeParser
 javascript
  compile() {
   return `<div class="codeWithHeader"><div class="codeHeader">${this.content}</div>${super.compile()}</div>`
  }
codeWithLanguageParser
 description Use this to specify the language of the code block, such as csvCode or rustCode.
 extends codeParser
 pattern ^[a-zA-Z0-9_]+Code$
abstractScrollWithRequirementsParser
 extends abstractScrollParser
 cruxFromId
 javascript
  compile(compileSettings) {
    return this.getHtmlRequirements(compileSettings) + this.compileInstance()
  }
copyButtonsParser
 extends abstractScrollWithRequirementsParser
 description Copy code widget.
 javascript
  compileInstance() {
   return ""
  }
 string requireOnce
  <script>
  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollCodeBlock").forEach(block =>
   {
    if (!navigator.clipboard) return
    const button = document.createElement("span")
    button.classList.add("scrollCopyButton")
    block.appendChild(button)
    button.addEventListener("click", async () => {
      await navigator.clipboard.writeText(block.innerText)
      button.classList.add("scrollCopiedButton")
    })
   }
  ))
  </script>
katexParser
 extends abstractScrollWithRequirementsParser
 catchAllCellType codeCell
 catchAllParser lineOfCodeParser
 description KaTex widget for typeset math.
 string copyFromExternal katex.min.css katex.min.js
 string requireOnce
  <link rel="stylesheet" href="katex.min.css">
  <script defer src="katex.min.js"></script>
  <script>
  document.addEventListener("DOMContentLoaded", () => document.querySelectorAll(".scrollKatex").forEach(el =>
   {
    katex.render(el.innerText, el, {
        throwOnError: false
    });
   }
  ))
  </script>
 javascript
  compileInstance() {
   const id = this._getUid()
   const content = this.content === undefined ? "" : this.content
   return `<div class="scrollKatex" id="${id}">${content + this.childrenToString()}</div>`
  }
  compileTxt() {
    return ( this.content ? this.content : "" )+ this.childrenToString()
  }
mapParser
 inScope latParser longParser
 zoomParser
  cells commandWordCell integerCell
  cruxFromId
  single
 heightParser
  cells commandWordCell floatCell
  cruxFromId
  single
 pointParser
  cells commandWordCell
  inScope latParser longParser
  cruxFromId
  titleParser
   extends abstractPointConfigParser
  descriptionParser
   extends abstractPointConfigParser
 extends abstractScrollWithRequirementsParser
 description Map widget.
 string copyFromExternal leaflet.css leaflet.js
 string requireOnce
  <link rel="stylesheet" href="leaflet.css">
  <script src="leaflet.js"></script>
 javascript
  compileInstance() {
   const height = 500
   const id = this._getUid()
   return `<div id="map${id}" style="height: ${height}px;"></div>
  <script>
   {
    const lat = ${this.get("lat") ?? 37.8}
    const long = ${this.get("long") ?? 4}
    const zoomLevel = ${this.get("zoom") ?? 4}
    const points = ${JSON.stringify(this.findNodes("point").map(node => node.toObject()))}
    const map = L.map("map${id}").setView([lat, long], zoomLevel)
    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
     attribution: '<a href="https://www.openstreetmap.org/">OpenStreetMap</a>',
     maxZoom: 18
    }).addTo(map)
    points.forEach(point => {
     L.marker([point.lat, point.long])
      .addTo(map)
      .bindPopup("<b>" +point.title + "</b><br />" + point.description)
    })
   }
  </script>`
  }
helpfulNotFoundParser
 extends abstractScrollWithRequirementsParser
 catchAllCellType filePathCell
 string copyFromExternal helpfulNotFound.js
 description Helpful not found widget.
 javascript
  compileInstance() {
   return `<style>#helpfulNotFound{margin: 100px 0;}</style><h1 id="helpfulNotFound"></h1><script defer src="/helpfulNotFound.js"></script><script>document.addEventListener("DOMContentLoaded", () => new NotFoundApp('${this.content}'))</script>`
  }
abstractPlotParser
 // Observablehq
 extends abstractScrollWithRequirementsParser
 string iris
  sepal_length,sepal_width,petal_length,petal_width,species
  6.1,3,4.9,1.8,virginica
  5.6,2.7,4.2,1.3,versicolor
  5.6,2.8,4.9,2,virginica
  6.2,2.8,4.8,1.8,virginica
  7.7,3.8,6.7,2.2,virginica
  5.3,3.7,1.5,0.2,setosa
  6.2,3.4,5.4,2.3,virginica
  4.9,2.5,4.5,1.7,virginica
  5.1,3.5,1.4,0.2,setosa
  5,3.4,1.5,0.2,setosa
 string copyFromExternal d3.js plot.js
 string requireOnce
  <script src="d3.js"></script>
  <script src="plot.js"></script>
 example
  plot
 javascript
  compileInstance() {
   const id = "plot" + this._getUid()
   return `<div id="${id}"></div><script>
   {
    let loadChart = async () => {
    const data = ${this.dataCode}
    const get = (col, index ) => col !== "undefined" ? col : (index === undefined ? undefined : Object.keys(data[0])[index])
    document.querySelector("#${id}").append(Plot.plot(${this.plotOptions}))
    }
    loadChart()
    }
    </script>`
  }
  get marks() {
    // just for testing purposes
    return `Plot.rectY({length: 10000}, Plot.binX({y: "count"}, {x: d3.randomNormal()}))`
  }
  get dataCode() {
    return '[]'
  }
  get plotOptions() {
    return `{
      title: "${this.get("title") || ""}",
      subtitle: "${this.get("subtitle") || ""}",
      caption: "${this.get("caption") || ""}",
      symbol: {legend: ${this.has("symbol")}},
      color: {legend: ${this.has("fill")}},
      grid: ${this.get("grid") !== "false"},
      marks: [${this.marks}],
    }`
  }
scatterplotParser
 extends abstractPlotParser
 description Scatterplot Widget.
 // todo: make copyFromExternal work with inheritance
 string copyFromExternal d3.js plot.js
 javascript
  get dataCode() {
    let data = this.iris
    const dataset = this.getNode("data")
    const datasetContent = dataset?.content
    const isUrl = !!datasetContent?.match(/^https?:/)
    const fileExtension = datasetContent ? datasetContent.split(".").pop() : "csv"
    if (dataset?.length)
      data = dataset.childrenToString()
    else if (datasetContent && !isUrl) {
      const { Disk } = require("scrollsdk/products/Disk.node.js")
      const path = require("path")
      const {file} = this.parent
      data = Disk.read(path.join(file.folderPath, datasetContent))
    }
    let dataString = `d3.${fileExtension}Parse(\`${data}\`, d3.autoType)`
    if (isUrl)
      dataString = `await d3.${fileExtension}("${datasetContent}")`
    return dataString
  }
  get marks() {
    const x = this.get("x")
    const y = this.get("y")
    const text = this.get("label")
    return `Plot.dot(data, {
      x: get("${x}", 0),
      y: get("${y}", 1),
      r: get("${this.get("radius")}"),
      fill: get("${this.get("fill")}"),
      tip: true,
      symbol: get("${this.get("symbol")}")} ), Plot.text(data, {x: get("${x}",0), y: get("${y}", 1), text: "${text}", dy: -6, lineAnchor: "bottom"})`
  }
slideshowParser
 // Left and right arrows navigate.
 description Slideshow widget. *** delimits slides.
 extends abstractScrollWithRequirementsParser
 string copyFromExternal jquery-3.7.1.min.js slideshow.js
 example
  slideshow
  Why did the cow cross the road?
  ***
  Because it wanted to go to the MOOOO-vies.
  ***
  THE END
  ****
 javascript
  compile() {
   return `<style>html {font-size: var(--base-font-size, 28px);} body {margin: auto; width: 500px;}.slideshowNav{text-align: center; margin-bottom:20px; font-size: 14px;} a{text-decoration: none;</style><script defer src="jquery-3.7.1.min.js"></script><div class="slideshowNav"></div><script defer src="slideshow.js"></script>`
  }
sparklineParser
 description Sparkline widget.
 extends abstractScrollWithRequirementsParser
 example
  sparkline 1 2 3 4 5
 string copyFromExternal sparkline.js
 string requireOnce <script src="sparkline.js"></script>
 catchAllCellType numberCell
 javascript
  compileInstance() {
   const id = "spark" + this._getUid()
   const data = this.content.split(" ").map(str => parseFloat(str))
   const start = this.has("start") ? parseInt(this.get("start")) : 0
   const width = this.get("width") || 100
   const height = this.get("height") || 30
   const lineColor = this.get("color") || "black"
   return `<span id="${id}"></span><script>new Sparkline(document.getElementById("${id}"), {dotRadius: 0, width: ${width}, height: ${height}, lineColor: "${lineColor}", tooltip: (value,index) => ${start} + index + ": " + value}).draw(${JSON.stringify(data)})</script>`
  }
tableSearchParser
 extends abstractScrollWithRequirementsParser
 string copyFromExternal jquery-3.7.1.min.js dataTables.dataTables.min.css dataTables.min.js tableSearch.js
 string requireOnce
  <script defer src="jquery-3.7.1.min.js"></script>
  <style>.dt-search{font-family: "SF Pro", "Helvetica Neue", "Segoe UI", "Arial";}</style>
  <link rel="stylesheet" href="dataTables.dataTables.min.css">
  <script defer src="dataTables.min.js"></script>
  <script defer src="tableSearch.js"></script>
 // adds to all tables on page
 description Table search and sort widget.
 javascript
  compileInstance() {
   return ""
  }
abstractCommentParser
 description Prints nothing.
 catchAllCellType commentCell
 cells commentCell
 extends abstractScrollParser
 baseParser blobParser
 javascript
  compile() {
   return ``
  }
 catchAllParser commentLineParser
commentParser
 extends abstractCommentParser
 cruxFromId
slashCommentParser
 extends commentParser
 crux //
 boolean isPopular true
 description A comment. Prints nothing.
counterpointParser
 description A counterpoint. Prints nothing.
 extends commentParser
 crux !
thanksToParser
 description Acknowledge reviewers. Prints nothing.
 extends abstractCommentParser
 cruxFromId
tabularDataParser
 description Root lines with tabs are parsed as tsv data and printed as tables.
 pattern \t
 extends abstractCommentParser
 javascript
  compileTxt() {
    return ""
  }
  get headerNode() {
    return this.isFirst ? this : this.previous.headerNode
  }
  compile() {
    return ""
  }
  get isFirst() {
    return !this.previous.isTabularData
  }
  get lastNode() {
    if (this.next.isTabularData && this.next.lineNumber)
      return this.next.lastNode
    return this
  }
  applyAftertext(aftertext) {
    const node = this.parent.appendLineAndChildren("* " + this.getLine(), aftertext + "\ntag none")
    const html = node.compile()
    node.destroy()
    return html
  }
  isTabularData = true
 example
  // The below lines will print a table
  printTable
  Index Name
  1 Thermos
printConceptsParser
 description Print concepts to HTML table.
 cruxFromId
 extends abstractScrollParser
 javascript
   compile() {
   // A hacky but simple way to do this for now.
   const node = this.appendSibling("table \t", this.parent.file.compileConcepts("concepts.tsv", this.get("sortBy")))
   const html = node.compile()
   node.destroy()
   return html
   }
cssParser
 extends abstractScrollParser
 description A style tag.
 cruxFromId
 catchAllParser cssLineParser
 catchAllCellType cssAnyCell
 javascript
  compile() {
   return `<style>${this.css}</style>`
  }
  get css() {
    return this.content ?? this.childrenToString()
  }
  compileCss() {
    return this.css
  }
abstractPostLoopParser
 description Do something with all posts. Takes an optional list of folder/group names.
 extends abstractScrollParser
 cruxFromId
 cells commandWordCell
 catchAllCellType tagWithOptionalFolderCell
 javascript
  get files() {
   return this.root.file.getFilesWithTagsForEmbedding(this.getWordsFrom(1))
  }
printFeedParser
 description Print group to RSS.
 extends abstractPostLoopParser
 example
  printFeed index
  printFeed cars/index
  buildRss feed.xml
 javascript
  compile() {
   const dayjs = require("dayjs")
   const file = this.root.file
   const files = this.files.map(file => file.file)
   const { title, baseUrl, description } = file
   return `<?xml version="1.0" encoding="ISO-8859-1" ?>
  <rss version="2.0">
  <channel>
   <title>${title}</title>
   <link>${baseUrl}</link>
   <description>${description}</description>
   <lastBuildDate>${dayjs().format("ddd, DD MMM YYYY HH:mm:ss ZZ")}</lastBuildDate>
   <language>en-us</language>
  ${files.map(file => file.toRss()).join("\n")}
  </channel>
  </rss>`
  }
  compileTxt() {
    return this.compile()
  }
printCsvParser
 description Print group metadata to CSV.
 extends printFeedParser
 example
  printCsv index
  buildTxt posts.csv
 javascript
  compile() {
   const file = this.root.file
   const files = file.getFilesWithTagsForEmbedding(this.getWordsFrom(1)).map(file => file.file)
   const header = file.csvFields
   return `${header.join(",")}\n${files.map(file => file.toCsv()).join("\n")}`
  }
printSourceParser
 description Print source for files in group(s).
 extends printFeedParser
 example
  printSource index
  buildTxt source.txt
 javascript
  compile() {
   const file = this.root.file
   const files = file.getFilesWithTagsForEmbedding(this.getWordsFrom(1)).map(file => file.file)
   return `${files.map(file => file.filePath + "\n " + file.codeAtStart.replace(/\n/g, "\n ") ).join("\n")}`
  }
printSearchTableParser
 description Prints files to HTML table.
 extends abstractPostLoopParser
 example
  printSearchTable
  tableSearch
 javascript
  compile() {
   const file = this.root.file
   const files = this.files
   const data = files.map(file => file.file.toSearchTsvRow(file.relativePath)).join("\n")
   // A hacky but simple way to do this for now.
   const node = this.appendSibling("table \t", "title titleLink text date wordCount minutes".replace(/ /g, "\t") + "\n" + data)
   const html = node.compile()
   node.destroy()
   return html
  }
printSiteMapParser
 extends abstractPostLoopParser
 description Print text sitemap.
 example
  baseUrl http://test.com
  printSiteMap
 javascript
  compile() {
   const file = this.root.file
   const { baseUrl } = file
   return this.files.map(file => baseUrl + file.relativePath + file.file.permalink).join("\n")
  }
  compileTxt() {
    return this.compile()
  }
dashboardParser
 description Key stats in large font.
 catchAllParser rowParser
 cruxFromId
 extends abstractScrollParser
 example
  dashboard
   #2 Popularity
   30 Years Old
   $456 Revenue
 javascript
  get tableBody() {
   const items = this.topDownArray
   let str = ""
   for (let i = 0; i < items.length; i = i + 3) {
    str += this.makeRow(items.slice(i, i + 3))
   }
   return str
  }
  makeRow(items) {
   return `<tr>` + items.map(node => `<td>${node.firstWord}<span>${node.content}</span></td>`).join("\n") + `</tr>\n`
  }
  compile() {
   return `<table class="scrollDashboard">${this.tableBody}</table>`
  }
  compileTxt() {
    return this.childrenToString()
  }
abstractTopLevelSingleMetaParser
 description Use these keywords once per file.
 extends abstractScrollParser
 inScope slashCommentParser
 cruxFromId
 cells metaCommandWordCell
 javascript
  isTopMatter = true
  isSetterParser = true
  compile() {
   return ""
  }
dateParser
 catchAllCellType dateCell
 description Set published date.
 extends abstractTopLevelSingleMetaParser
 boolean isPopular true
siteOwnerEmailParser
 description Set email address for site contact.
 extends abstractTopLevelSingleMetaParser
 crux email
 cells metaCommandWordCell emailAddressCell
importOnlyParser
 // This line will be not be imported into the importing file.
 description Don't build this file.
 cruxFromId
 cells preBuildCommandWordCell
 extends abstractTopLevelSingleMetaParser
 javascript
  compile() {
   return ""
  }
abstractUrlSettingParser
 extends abstractTopLevelSingleMetaParser
 cells metaCommandWordCell urlCell
 cruxFromId
canonicalUrlParser
 description Override canonical URL.
 extends abstractUrlSettingParser
openGraphImageParser
 // https://ogp.me/
 // If not defined, Scroll will try to generate it's own using the first image tag on your page.
 description Override Open Graph Image.
 extends abstractUrlSettingParser
baseUrlParser
 description Required for RSS and OpenGraph.
 extends abstractUrlSettingParser
downloadUrlParser
 description Set link to Download Page.
 extends abstractUrlSettingParser
homeUrlParser
 // default homelink is "index.html"
 description Override home link.
 extends abstractUrlSettingParser
rssFeedUrlParser
 description Set RSS feed URL.
 extends abstractUrlSettingParser
viewSourceBaseUrlParser
 description Override source link baseUrl.
 extends abstractUrlSettingParser
htmlLangParser
 cells metaCommandWordCell stringCell
 // for the <html lang=""> tag. If not specified will be "en". See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang
 description Override HTML lang attribute.
 extends abstractTopLevelSingleMetaParser
openGraphDescriptionParser
 catchAllCellType stringCell
 crux description
 description Override Open Graph Description.
 extends abstractTopLevelSingleMetaParser
permalinkParser
 description Override output filename.
 extends abstractTopLevelSingleMetaParser
 cells metaCommandWordCell permalinkCell
scrollTagsParser
 crux tags
 description Set tags.
 example
  tags All
 extends abstractTopLevelSingleMetaParser
 catchAllCellType tagCell
testStrictParser
 description Make catchAllParagraphParser = error.
 extends abstractTopLevelSingleMetaParser
pageTitleParser
 catchAllCellType personNameCell
 crux title
 description Set title.
 extends abstractTopLevelSingleMetaParser
 boolean isPopular true
viewSourceUrlParser
 catchAllCellType urlCell
 description Override source link.
 extends abstractTopLevelSingleMetaParser
belowAsCodeParser
 description Print code below.
 extends abstractScrollParser
 catchAllCellType integerCell
 cruxFromId
 javascript
  method = "next"
  get code() {
   const { method } = this
   let code = ""
   
   let nodes = []
   let next = this[method]
   let {howMany} = this
   while (howMany) {
    nodes.push(next)
    next = next[method]
    howMany--
   }
   if (this.reverse) nodes.reverse()
   return nodes.map(node => node.asString).join("\n")
  }
  reverse = false
  compile() {
   return `<code class="scrollCodeBlock">${this.code.replace(/\</g, "&lt;")}</code>`
  }
  get howMany() {
    let howMany = parseInt(this.getWord(1))
   if (!howMany || isNaN(howMany)) howMany = 1
   return howMany
  }
belowAsCodeUntilParser
 description Print code above until match.
 extends belowAsCodeParser
 catchAllCellType anyCell
 javascript
  get howMany() {
    let howMany = 1
    const query = this.content
    let node = this.next
    while (node !== this) {
      if (node.getLine().startsWith(query))
        return howMany
      node = node.next
      howMany++
    }
    return howMany
  }
aboveAsCodeParser
 description Print code above.
 extends belowAsCodeParser
 javascript
  method = "previous"
  reverse = true
abstractThemeCssParser
 description Extend this to create a Scroll CSS theme.
 extends abstractScrollParser
 inScope themeTagsParser
 cruxFromId
 catchAllCellType stringCell
 string scrollStyles
  figure
   margin 0
   padding 0
  .dropcap:first-letter
   font-size 3rem
   line-height .9em
   margin-right .125rem
   display block
   float left
  .dinkus
   text-align center
   padding 1rem
   span
    vertical-align sub
  details
   margin-top 10px
  summary
   font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"
   cursor pointer
  .scrollCaptionedFigure
   display block
   break-inside avoid
   max-width 100%
   text-align center
   img
    max-width 100%
    height auto
    margin-top .1875rem
   figcaption
    font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"
    font-size .8rem
    .scrollParagraph
     margin-top 0
  .scrollCodeBlock
   overflow auto
   font-size .8rem
   hyphens none
   white-space pre
   break-inside avoid
   display block
   margin .5rem 0
   padding .5rem
   border-radius 0
   position relative
  .codeWithHeader
   break-inside avoid-column
   margin 10px 0
  .codeHeader
   font-size 80%
   text-align center
   background rgba(224, 224, 224, 0.4)
   border 1px solid rgba(204, 204, 204, 0.8)
   border-bottom 0
   margin-bottom -7px
   padding 4px 2px
   border-top-left-radius 3px
   border-top-right-radius 3px
  .scrollCodeBlock:hover
   .scrollCopyButton
    opacity .5
   .scrollCopyButton:hover
    opacity .8
   .scrollCopyButton:active
    opacity 1
  .scrollCopyButton
   position absolute
   top .125rem
   right .125rem
   font-size .875rem
   cursor pointer
   opacity 0
  .scrollCopyButton::after
   content "[ ]"
  .scrollCopiedButton::after
   content "[✓]"
 javascript
  compile() {
   return `<style>\n${this.css}\n</style>`
  }
  compileTxt() {
    return ""
  }
  compileCss() {
    return this.css
  }
  compileEmbeddedVersion() {
   return ""
  }
  get scrollCss() {
    const hakonParser = this.root.hakonParser
    return new hakonParser(this.scrollStyles).compile()
  }
gazetteCssParser
 description Default Scroll theme CSS.
 extends abstractThemeCssParser
 javascript
  get css() {
    if (this.constructor._cachedCss)
      return this.constructor._cachedCss
    const hakonParser = this.root.hakonParser
    this.constructor._cachedCss = this.scrollCss + new hakonParser([this.hakonReset, this.hakonStandardStyles].join("\n")).compile()
    return this.constructor._cachedCss
  }
 // CSS Reset
 string hakonReset
  html,body,div,span,p,ol,ul,li,table,figure
   margin 0
   padding 0
   border 0
   vertical-align baseline
   border-spacing 0
  ol,ul
   padding-left 1rem
  li
   margin-top .4rem
   line-height 1.4
  a
   text-decoration-color transparent
   color #36c
  a:hover
   text-decoration-color initial
  sup,sub
   vertical-align baseline
   position relative
   top -.375rem
  sub
   top .375rem
  html
   padding .25rem
   background-color rgb(244,244,244)
   font-family Exchange,Georgia,serif
   color #000
   font-size var(--base-font-size, 16px)
   hyphens auto
  p
   margin-top .4rem
   line-height 1.4rem
  .scrollQuote
   break-inside avoid
   display block
   margin .5rem 0
   padding .5rem
   background rgba(204,204,204,.5)
   white-space pre-line
   border-left .5rem solid rgba(204,204,204,.8)
  code
   font-size .9rem
   background-color rgba(204,204,204,.5)
   padding .125rem .25rem
   border-radius .25rem
 // Styles for Scroll standard tags
 string hakonStandardStyles
  comment Main body of both pages is similar
  .scrollParagraph
   text-align justify
  center
   .scrollParagraph
    text-align center
  .scrollColumns
   column-count auto
   column-fill balance
   column-width 35ch
   column-gap 1.5rem
   padding-left 1.25rem
   padding-right 1.25rem
   margin auto
  comment On group pages add some spacing around files
  .scrollSnippetContainer
   padding 1ch 0
   break-inside avoid
   text-align justify
  h1,h2,h3,h4
   margin .625rem 0
  h1
   font-size 1.25rem
  h2
   font-size 1.125rem
  h3,h4
   font-size 1rem
  h1.scrollTitle
   text-align center
   margin auto
   margin-bottom .15625rem
   margin-top 0
   font-size 1.75rem
   comment On narrow browsers like phones make sure the title doesn't overlap with the icons buttons in top left and right.
   max-width calc(100vw - 2 * (1.5625rem + 1.875rem))
   a
    color #000
  .scrollDateline
   font-style italic
   line-height 1.4rem
   comment Decrease font size to deemphasize dateline but keep the line height the same to not cause different line spacing.
   font-size .75rem
  .scrollSection
   break-inside avoid
   h1,h2,h3,h4
    text-align center
  h4.scrollQuestion
   text-align left
   margin 1.4rem 0 0 0
  .scrollSection:first-child
   h1,h2,h3,h4
    margin-top 0
   h4.scrollQuestion
    margin-top 0
  .scrollNoteLink
   opacity .4
   text-decoration none
   &:hover
    opacity 1
  .scrollFootNoteUsageLink
   opacity .7
   text-decoration none
   &:hover
    opacity 1
  
  .scrollHoverNote
   text-decoration underline dashed 1px rgba(0,0,0,.1)
   cursor default
  
  .scrollCodeBlock
   border-left .5rem solid rgba(204,204,204,.8)
  
  .scrollTable
   table-layout fixed
   font-family "SF Pro", "Helvetica Neue", "Segoe UI", "Arial"
   margin .5rem 0
   overflow hidden
   font-size .8rem
   width 100%
   hyphens none
   border 1px solid rgba(224,224,224,.8)
   td,th
    padding .1875rem
    overflow hidden
    white-space nowrap
   th
    text-transform capitalize
    border-bottom 2px solid rgba(0,0,0,.6)
    text-align left
   td
    cursor zoom-in
   tr:nth-child(even)
    background rgba(224,224,224,.6)
  .scrollTable
   pre
    white-space nowrap
    overflow hidden
    margin 0
  .scrollTable.expandedTable
   pre
    white-space unset
    overflow unset
   table-layout unset
   background white
   position relative
   z-index 10
   overflow unset
   td,th
    overflow unset
    white-space unset
   td
    cursor zoom-out
  
  .scrollByLine
   font-size .875rem
   font-style italic
   margin .25rem 0
   text-align center
  
  comment View source badge
  .scrollViewSourceBadge
   text-align right
   position absolute
   display block
   right 20px
   top 8px
   svg
    width 24px
    height 24px
    fill rgba(204,204,204,0.8)
   svg:hover
    fill #333
  comment Subtle "Article Source" link
  .scrollViewSource
   text-align center
   font-family Verdana
   font-weight 100
   a
    color rgba(204,204,204,.5)
    &:hover
     color #333
  
  .scrollContinueReadingLink
   display block
   text-align center
  
  .scrollDashboard
   width 100%
   font-size 1.875rem
   text-align center
   font-weight bold
   break-inside avoid
   margin-top .5rem
   margin-bottom .5rem
   td
    width 33.3%
    border 1px solid #e8e8e8
   span
    font-size 1.25rem
    display block
  .scrollChat
   span
    font-family Verdana
    margin-top .3125rem
    padding .3125rem 1.25rem
    border-radius .9375rem
    display inline-block
  .scrollChatLeft
   span
    background rgba(204,204,204, .5)
  .scrollChatRight
   span
    color white
    background rgb(0,132,255)
  .scrollYouTubeHolder
   position relative
   width 100%
   height 0
   padding-bottom 56.25%
  .scrollYouTubeEmbed
   position absolute
   top 0
   left 0
   width 100%
   height 100%
tufteCssParser
 // https://github.com/edwardtufte/tufte-css
 description Theme from Tufte CSS.
 extends abstractThemeCssParser
 javascript
  get css() {
    return this.scrollCss + this.tufteCss
  }
  tufteCss = `html {
     font-size: 15px;
  }
   body {
       width: 87.5%;
       margin-left: auto;
       margin-right: auto;
       padding-left: 12.5%;
       font-family: Palatino, "Palatino Linotype", "Palatino LT STD", "Book Antiqua", Georgia, serif;
       background-color: #fffff8;
       color: #111;
       max-width: 1400px;
       counter-reset: sidenote-counter;
  }
  /* Adds dark mode */
   @media (prefers-color-scheme: dark) {
       body {
           background-color: #151515;
           color: #ddd;
      }
  }
   h1 {
       font-weight: 400;
       margin-top: 3rem;
       margin-bottom: 1.5rem;
       font-size: 2.4rem;
       line-height: 1;
  }
  .scrollTitle a { text-decoration: none; font-size: 3.2rem;}
  .scrollParagraph { text-align: justify; hyphens: auto;}
  a.scrollNoteLink { text-decoration: none;}
   h2 {
       font-style: italic;
       font-weight: 400;
       margin-top: 2.1rem;
       margin-bottom: 1.4rem;
       font-size: 2.2rem;
       line-height: 1;
  }
   h3 {
       font-style: italic;
       font-weight: 400;
       font-size: 1.7rem;
       margin-top: 2rem;
       margin-bottom: 1.4rem;
       line-height: 1;
  }
   hr {
       display: block;
       height: 1px;
       width: 55%;
       border: 0;
       border-top: 1px solid #ccc;
       margin: 1em 0;
       padding: 0;
  }
   p.subtitle {
       font-style: italic;
       margin-top: 1rem;
       margin-bottom: 1rem;
       font-size: 1.8rem;
       display: block;
       line-height: 1;
  }
   .numeral {
       font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
  }
   .danger {
       color: red;
  }
   article {
       padding: 5rem 0rem;
  }
   section {
       padding-top: 1rem;
       padding-bottom: 1rem;
  }
   p, dl, ol, ul {
       font-size: 1.4rem;
       line-height: 2rem;
  }
   p {
       margin-top: 1.4rem;
       margin-bottom: 1.4rem;
       padding-right: 0;
       vertical-align: baseline;
  }
  /* Chapter Epigraphs */
   div.epigraph {
       margin: 5em 0;
  }
   div.epigraph > blockquote {
       margin-top: 3em;
       margin-bottom: 3em;
  }
   div.epigraph > blockquote, div.epigraph > blockquote > p {
       font-style: italic;
  }
   div.epigraph > blockquote > footer {
       font-style: normal;
  }
   div.epigraph > blockquote > footer > cite {
       font-style: italic;
  }
  /* end chapter epigraphs styles */
   blockquote {
       font-size: 1.4rem;
  }
   blockquote p {
       width: 55%;
       margin-right: 40px;
  }
   blockquote footer {
       width: 55%;
       font-size: 1.1rem;
       text-align: right;
  }
   section > p, section > footer, section > table {
       width: 55%;
  }
  /* 50 + 5 == 55, to be the same width as paragraph */
   section > dl, section > ol, section > ul {
       width: 50%;
       -webkit-padding-start: 5%;
  }
   dt:not(:first-child), li:not(:first-child) {
       margin-top: 0.25rem;
  }
  /* Links: replicate underline that clears descenders */
   a:link, a:visited {
       color: inherit;
  }
  /* Sidenotes, margin notes, figures, captions */
   img {
       max-width: 100%;
  }
   .sidenote, .marginnote {
       float: right;
       clear: right;
       margin-right: -60%;
       width: 50%;
       margin-top: 0.3rem;
       margin-bottom: 0;
       font-size: 1.1rem;
       line-height: 1.3;
       vertical-align: baseline;
       position: relative;
  }
   .sidenote-number {
       counter-increment: sidenote-counter;
  }
   .sidenote-number:after, .sidenote:before {
       font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
       position: relative;
       vertical-align: baseline;
  }
   .sidenote-number:after {
       content: counter(sidenote-counter);
       font-size: 1rem;
       top: -0.5rem;
       left: 0.1rem;
  }
   .sidenote:before {
       content: counter(sidenote-counter) " ";
       font-size: 1rem;
       top: -0.5rem;
  }
   blockquote .sidenote, blockquote .marginnote {
       margin-right: -82%;
       min-width: 59%;
       text-align: left;
  }
   div.fullwidth, table.fullwidth {
       width: 100%;
  }
   div.table-wrapper {
       overflow-x: auto;
       font-family: "Trebuchet MS", "Gill Sans", "Gill Sans MT", sans-serif;
  }
   .sans {
       font-family: "Gill Sans", "Gill Sans MT", Calibri, sans-serif;
       letter-spacing: 0.03em;
  }
   code, pre > code {
       font-family: Consolas, "Liberation Mono", Menlo, Courier, monospace;
       font-size: 1rem;
       line-height: 1.42;
       -webkit-text-size-adjust: 100%;
      /* Prevent adjustments of font size after orientation changes in iOS. See https://github.com/edwardtufte/tufte-css/issues/81#issuecomment-261953409 */
  }
   .sans > code {
       font-size: 1.2rem;
  }
   h1 > code, h2 > code, h3 > code {
       font-size: 0.8em;
  }
   .marginnote > code, .sidenote > code {
       font-size: 1rem;
  }
   pre > code {
       font-size: 0.9rem;
       width: 52.5%;
       margin-left: 2.5%;
       overflow-x: auto;
       display: block;
  }
   pre.fullwidth > code {
       width: 90%;
  }
   .fullwidth {
       max-width: 90%;
       clear: both;
  }
   span.newthought {
       font-variant: small-caps;
       font-size: 1.2em;
  }
   input.margin-toggle {
       display: none;
  }
   label.sidenote-number {
       display: inline-block;
       max-height: 2rem;
      /* should be less than or equal to paragraph line-height */
  }
   label.margin-toggle:not(.sidenote-number) {
       display: none;
  }
   .iframe-wrapper {
       position: relative;
       padding-bottom: 56.25%;
      /* 16:9 */
       padding-top: 25px;
       height: 0;
  }
   .iframe-wrapper iframe {
       position: absolute;
       top: 0;
       left: 0;
       width: 100%;
       height: 100%;
  }
   @media (max-width: 760px) {
       body {
           width: 84%;
           padding-left: 8%;
           padding-right: 8%;
      }
       hr, section > p, section > footer, section > table {
           width: 100%;
      }
       pre > code {
           width: 97%;
      }
       section > dl, section > ol, section > ul {
           width: 90%;
      }
       blockquote {
           margin-left: 1.5em;
           margin-right: 0em;
      }
       blockquote p, blockquote footer {
           width: 100%;
      }
       label.margin-toggle:not(.sidenote-number) {
           display: inline;
      }
       .sidenote, .marginnote {
           display: none;
      }
       .margin-toggle:checked + .sidenote, .margin-toggle:checked + .marginnote {
           display: block;
           float: left;
           left: 1rem;
           clear: both;
           width: 95%;
           margin: 1rem 2.5%;
           vertical-align: baseline;
           position: relative;
      }
       label {
           cursor: pointer;
      }
       div.table-wrapper, table {
           width: 85%;
      }
       img {
           width: 100%;
      }
  }`
heatrixParser
 cruxFromId
 example
  heatrix
   '2007 '2008 '2009 '2010 '2011 '2012 '2013 '2014 '2015 '2016 '2017 '2018 '2019 '2020 '2021 '2022 '2023 '2024
   4 11 23 37 3 14 12 0 0 0 5 1 2 11 15 10 12 56
 description A heatmap matrix data visualization.
 catchAllParser heatrixCatchAllParser
 extends abstractScrollParser
 javascript
  compile() {
   // A hacky but simple way to do this for now.
   const advanced = new TreeNode("heatrixAdvanced")
   advanced.appendLineAndChildren("table", "\n " + this.childrenToString().replace(/\n/g, "\n "))
   const node = this.appendSibling("heatrixAdvanced", advanced.childrenToString())
   const html = node.compile()
   node.destroy()
   return html
  }
heatrixAdvancedParser
 cruxFromId
 catchAllParser heatrixCatchAllParser
 extends abstractScrollParser
 description Advanced heatrix.
 example
  heatrix
   table
     
    %h10; '2007 '2008 '2009
     12 4 323
   scale
    #ebedf0 0
    #c7e9c0 100
    #a1d99b 400
    #74c476 1600
 javascript
  compile() {
  class Heatrix {
    static HeatrixId = 0
    uid = Heatrix.HeatrixId++
    constructor(program) {
      const isDirective = word => /^(f|l|w|h)\d+$/.test(word) || word === "right" || word === "left" || word.startsWith("http://") || word.startsWith("https://") || word.endsWith(".html")
      const tree = new TreeNode(program)
      this.program = tree
      const generateColorBinningString = (data, colors) => {
       const sortedData = [...data].sort((a, b) => a - b);
       const n = sortedData.length;
       const numBins = colors.length;
       // Calculate the indices for each quantile
       const indices = [];
       for (let i = 1; i < numBins; i++) {
         indices.push(Math.floor((i / numBins) * n));
       }
       // Get the quantile values and round them
       const thresholds = indices.map(index => Math.round(sortedData[index]));
       // Generate the string
       let result = '';
       colors.forEach((color, index) => {
         const threshold = index === colors.length - 1 ? thresholds[index - 1] * 2 : thresholds[index];
         result += `${color} ${threshold}\n`;
       });
       return result.trim();
      }
      const buildScale = (table) => {
        const numbers = table.split("\n").map(line => line.split(" ")).flat().filter(word => !isDirective(word)).map(word => parseFloat(word)).filter(number => !isNaN(number))
        const colors = ['#ebedf0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#005a32'];
        numbers.unshift(0)
        return generateColorBinningString(numbers, colors);
      }
      const table = tree.getNode("table").childrenToString()
      const scale = tree.getNode("scale")?.childrenToString() || buildScale(table)
      const thresholds = []
      const colors = []
      scale.split("\n").map((line) => {
        const parts = line.split(" ")
        thresholds.push(parseFloat(parts[1]))
        colors.push(parts[0])
      })
      const colorCount = colors.length
      const colorFunction = (value) => {
        if (isNaN(value)) return "" // #ebedf0
        for (let index = 0; index < colorCount; index++) {
          const threshold = thresholds[index]
          if (value <= threshold) return colors[index]
        }
        return colors[colorCount - 1]
      }
      const directiveDelimiter = ";"
      const getSize = (directives, letter) =>
        directives
          .filter((directive) => directive.startsWith(letter))
          .map((dir) => dir.replace(letter, "") + "px")[0] ?? ""
      this.table = table.split("\n").map((line) =>
        line
          .trimEnd()
          .split(" ")
          .map((cell) => {
            const words = cell.split(directiveDelimiter).filter((word) => !isDirective(word)).join("")
            const directivesInThisCell = cell
              .split(directiveDelimiter)
              .filter(isDirective)
            const value = parseFloat(words)
            const label = words.includes("'") ? words.split("'")[1] : words
            const alignment = directivesInThisCell.includes("right")
              ? "right"
              : directivesInThisCell.includes("left")
              ? "left"
              : ""
            const color = colorFunction(value)
            const width = getSize(directivesInThisCell, "w")
            const height = getSize(directivesInThisCell, "h")
            const fontSize = getSize(directivesInThisCell, "f")
            const lineHeight = getSize(directivesInThisCell, "l") || height
            const link = directivesInThisCell.filter(i => i.startsWith("http") || i.endsWith(".html"))[0]
            const style = {
              "background-color": color,
              width,
              height,
              "font-size": fontSize,
              "line-height": lineHeight,
              "text-align": alignment,
            }
            Object.keys(style).filter(key => !style[key]).forEach((key) => delete style[key])
            return {
              value,
              label,
              style,
              link,
            }
          })
      )
    }
    get html() {
      const { program } = this
      const cssId = `#heatrix${this.uid}`
      const defaultWidth = "40px"
      const defaultHeight = "40px"
      const fontSize = "10px"
      const lineHeight = defaultHeight
      const style = `<style>
      .heatrixContainer {
        margin: auto;
      }.heatrixRow {white-space: nowrap;}
  ${cssId} .heatrixCell {
    font-family: arial;
    border-radius: 2px;
    border: 1px solid transparent;
    display: inline-block;
    margin: 1px;
    text-align: center;
    vertical-align: middle;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .heatrixCell a {
    color: black;
  }
  ${cssId} .heatrixCell{
   width: ${defaultWidth};
   height: ${defaultHeight};
   font-size: ${fontSize};
   line-height: ${lineHeight};
  }
  </style>`
      const firstRow = this.table[0]
      return (
        `<div class="heatrixContainer" id="heatrix${this.uid}">${style}` +
        this.table
          .map((row, rowIndex) => {
            if (!rowIndex) return ""
            const rowStyle = row[0].style
            return `<div class="heatrixRow heatrixRow${rowIndex}">${row
              .map((cell, columnIndex) => {
                if (!columnIndex) return ""
                const columnStyle = firstRow[columnIndex]?.style || {}
                let { value, label, style, link } = cell
                const extendedStyle = Object.assign(
                  {},
                  rowStyle,
                  columnStyle,
                  style
                )
                const inlineStyle = Object.keys(extendedStyle)
                  .map((key) => `${key}:${extendedStyle[key]};`)
                  .join("")
                let valueClass = value ? " valueCell" : ""
                const href = link ? ` href="${link}"` : ""
                return `<div class="heatrixCell heatrixColumn${columnIndex}${valueClass}" style="${inlineStyle}"><a title="${label}" ${href}>${label}</a></div>`
              })
              .join("")}</div>`
          })
          .join("\n") +
        "</div>"
      ).replace(/\n/g, "")
    }
  }
    return new Heatrix(this.childrenToString().trim()).html
  }
abstractHtmlParser
 extends abstractScrollParser
 catchAllParser htmlLineParser
 catchAllCellType htmlAnyCell
 javascript
  compile() {
   return `${this.content ?? ""}${this.childrenToString()}`
  }
  compileTxt() {
    return ""
  }
htmlParser
 extends abstractHtmlParser
 description HTML one liners or blocks.
 cruxFromId
htmlInlineParser
 extends abstractHtmlParser
 cells htmlAnyCell
 pattern ^<
 description Inline HTML.
 boolean isPopular true
 javascript
  compile() {
   return `${this.getLine() ?? ""}${this.childrenToString()}`
  }
stumpParser
 cruxFromId
 extends abstractScrollParser
 description Compile Stump to HTML.
 catchAllParser stumpContentParser
 javascript
  compile() {
   const file = this.parent.file
   return file.compileStumpCode(this.childrenToString())
  }
stumpNoSnippetParser
 // todo: make noSnippets an aftertext directive?
 extends stumpParser
 description Compile Stump unless snippet.
 cruxFromId
 javascript
  compileEmbeddedVersion() {
   return ""
  }
abstractCaptionedParser
 extends abstractScrollParser
 cells commandWordCell urlCell
 inScope captionAftertextParser slashCommentParser
 cruxFromId
 javascript
  compile(compileSettings) {
   const caption = this.getNode("caption")
   const captionFig = caption ? `<figcaption>${caption.compile()}</figcaption>` : ""
   const {figureWidth} = this
   const widthStyle = figureWidth ? `width:${figureWidth}px; margin: auto;` : ""
   const float = this.has("float") ? `margin: 20px; float: ${this.get("float")};` : ""
   return `<figure class="scrollCaptionedFigure" style="${widthStyle + float}">${this.getFigureContent(compileSettings)}${captionFig}</figure>`
  }
  get figureWidth() {
    return this.get("width")
  }
imageParser
 description An img tag.
 boolean isPopular true
 extends abstractCaptionedParser
 inScope classMarkupParser aftertextIdParser linkParser linkTargetParser
 openGraphParser
  description Add this line to make this the open graph image.
  cruxFromId
  cells commandWordCell
 javascript
  get dimensions() {
    const width = this.get("width")
    const height = this.get("height")
    if (width || height)
      return {width, height}
    if (!this.isNodeJs())
      return {}
    const src = this.getWord(1)
    // If its a local image, get the dimensions and put them in the HTML
    // to avoid flicker
   if (src.startsWith("http:") || src.startsWith("https:")) return {}
   const file = this.root.file
    if (this._dimensions)
      return this._dimensions
    try {
     const sizeOf = require("image-size")
     const path = require("path")
     const fullImagePath = path.join(file.folderPath, src)
     this._dimensions = sizeOf(fullImagePath)
     return this._dimensions
    } catch (err) {
     console.error(err)
    }
    return {}
  }
  get figureWidth() {
    return this.dimensions.width
  }
  getFigureContent(compileSettings) {
   const file = this.root.file
   const linkRelativeToCompileTarget = (compileSettings ? (compileSettings.relativePath ?? "") : "") + this.getWord(1)
   const {width, height} = this.dimensions
   let dimensionAttributes = width || height  ? `width="${width}" height="${height}" ` : ""
   // Todo: can we reuse more code from aftertext?
   const className = this.has("class") ? ` class="${this.get("class")}" ` : ""
   const id = this.has("id") ? ` id="${this.get("id")}" ` : ""
   const clickLink = this.get("link") || linkRelativeToCompileTarget
   const target = this.has("target") ? this.get("target") : (this.has("link") ? "" : "_blank")
   return `<a href="${clickLink}" target="${target}" ${className} ${id}><img src="${linkRelativeToCompileTarget}" ${dimensionAttributes}loading="lazy"></a>`
  }
  compileTxt() {
    const children = this.filter(node => node.compileTxt).map(node => node.compileTxt()).filter(i => i).join("\n")
    return  "[Image Omitted]" + (children ? "\n " + children.replace(/\n/g, "\n ") : "")
  }
youTubeParser
 extends abstractCaptionedParser
 // Include the YouTube embed URL such as https://www.youtube.com/embed/CYPYZnVQoLg
 description A YouTube video widget.
 javascript
  getFigureContent() {
   const url = this.getWord(1).replace("youtube.com/watch?v=", "youtube.com/embed/")
   return `<div class="scrollYouTubeHolder"><iframe class="scrollYouTubeEmbed" src="${url}" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe></div>`
  }
importParser
 description Import a file.
 cruxFromId
 boolean isPopular true
 cells preBuildCommandWordCell
 extends abstractScrollParser
 catchAllCellType filePathCell
 javascript
  compile() {
   return ""
  }
 example
  import header.scroll
keyboardNavParser
 description Make left and right navigate files.
 extends abstractScrollParser
 cruxFromId
 catchAllCellType urlCell
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const file = this.root.file
   const linkToPrevious = this.getWord(1) ?? file.linkToPrevious
   const linkToNext = this.getWord(2) ?? file.linkToNext
   const script = `<script>document.addEventListener('keydown', function(event) {
    if (document.activeElement !== document.body) return
    const getLinks = () => document.getElementsByClassName("scrollKeyboardNav")[0].getElementsByTagName("a")
    if (event.key === "ArrowLeft")
      getLinks()[0].click()
    else if (event.key === "ArrowRight")
      getLinks()[1].click()
   });</script>`
   return `<div class="scrollKeyboardNav" style="display:none;"><a href="${linkToPrevious}">${linkToPrevious}</a> · ${file.permalink} · <a href="${linkToNext}">${linkToNext}</a>${script}</div>`
  }
printUsageStatsParser
 // todo: if we include the word "Parser" in a crux, bad things seem to happen.
 description Print parser usage stats in folder.
 extends abstractScrollParser
 cruxFromId
 javascript
  get stats() {
   const input = this.root.file.allScrollFiles.map(file => file.parserIds.join("\n")).join("\n")
   const result = input.split('\n').reduce((acc, word) => (acc[word] = (acc[word] || 0) + 1, acc), {})
   return "parserId uses\n" + Object.entries(result).map(([word, count]) => `${word} ${count}`).join('\n')
  }
  compile() {
    // A hacky but simple way to do this for now.
   const node = this.appendSibling("table  ", this.stats)
   const html = node.compile()
   node.destroy()
   return html
  }
  compileTxt() {
    return this.stats
  }
printLeetSheetParser
 description Print Scroll parser leet sheet.
 extends abstractScrollParser
 cruxFromId
 javascript
  get parsersToDocument() {
    const clone = this.root.clone()
    clone.setChildren("")
    const words = clone.getAutocompleteResultsAt(0,0).matches.map(a => a.text)
    words.push("blankline") // manually add blank line
    words.push("Catch All Paragraph.") // manually add catch all paragraph
    words.push("<h></h>") // manually add html
    words.sort()
    clone.setChildren(words.join("\n").replace(/blankline/, "")) // insert blank line in right spot
    return clone
  }
  sortDocs(docs) {
    return docs.map(node => {
      const {definition} = node
      const {id, description, isPopular} = definition
      return {id: definition.cruxIfAny || id, description, isPopular}
     }).sort((a, b) => a.id.localeCompare(b.id))
  }
  docToHtml(doc) {
   const css = `#scrollLeetSheet {color: grey;} #scrollLeetSheet a {color: #3498db; }`
   return `<style>${css}</style><div id="scrollLeetSheet">` + doc.map(obj => `<div><a>${obj.isPopular ? "<b>" : ""}${obj.id}</a> ${obj.description}${obj.isPopular ? "</b>" : ""}</div>`).join("\n") + "</div>"
  }
  compile() {
    return this.docToHtml(this.sortDocs(this.parsersToDocument))
  }
  compileTxt() {
   return this.sortDocs(this.parsersToDocument).map(obj => `${obj.id} - ${obj.description}`).join("\n")
  }
printAdvancedLeetSheetParser
 extends printLeetSheetParser
 description Print Parsers leet sheet.
 javascript
  compile() {
    return "<p><b>Line Parsers</b> match lines and parse them.</p><br>" + this.docToHtml(this.sortDocs(this.parsersToDocument)) + "<p><b>Cell Parsers</b> parse words in a line.</p><br>" + this.docToHtml(this.sortDocs(this.cellParsersToDocument))
  }
  get cellParsersToDocument() {
    const parsersParser = require("scrollsdk/products/parsers.nodejs.js")
    const clone = new parsersParser("anyCell\n ").clone()
    const parserNode = clone.getNode("anyCell")
    const words = clone.getAutocompleteResultsAt(1,1).matches.map(a => a.text)
    words.sort()
    parserNode.setChildren(words.join("\n"))
    return parserNode
  }
  get parsersToDocument() {
    const parsersParser = require("scrollsdk/products/parsers.nodejs.js")
    const clone = new parsersParser("latinParser\n ").clone()
    const parserNode = clone.getNode("latinParser")
    const words = clone.getAutocompleteResultsAt(1,1).matches.map(a => a.text)
    words.sort()
    parserNode.setChildren(words.join("\n"))
    return parserNode
  }
printMeasuresParser
 description Print measure stats to HTML table.
 cruxFromId
 extends abstractScrollParser
 javascript
   compile() {
   // A hacky but simple way to do this for now.
   const node = this.appendSibling("table \t", this.parent.file.compileMeasures("tsv"))
   const html = node.compile()
   node.destroy()
   return html
   }
abstractMeasureParser
 cells measureNameCell
 cruxFromId
 boolean isMeasure true
 float sortIndex 1.9
 boolean isComputed false
 string typeForCsvDocs unspecified
 extends abstractScrollParser
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   return ""
  }
  get measureValue() {
    return this.content ?? ""
  }
  get measureName() {
    return this.getFirstWordPath().replace(/ /g, "_")
  }
abstractWordMeasureParser
 description A measure that contains a single word.
 cells measureNameCell wordCell
 string typeForCsvDocs word
 extends abstractMeasureParser
abstractUrlMeasureParser
 string typeForCsvDocs url
 cells measureNameCell urlCell
 extends abstractWordMeasureParser
abstractStringMeasureParser
 string typeForCsvDocs string
 catchAllCellType stringCell
 extends abstractMeasureParser
abstractIdParser
 crux id
 description What is the ID of this concept?
 extends abstractStringMeasureParser
 float sortIndex 1
 boolean isMeasureRequired true
 boolean isConceptDelimiter true
 javascript
  getErrors() {
    const errors = super.getErrors()
    let requiredMeasureNames = this.parent.file.measures.filter(measure => measure.isMeasureRequired).map(measure => measure.Name).filter(name => name !== "id")
    if (!requiredMeasureNames.length) return errors
    let next = this.next
    while (requiredMeasureNames.length && next.firstWord !== "id" && next.getIndex() !== 0) {
      requiredMeasureNames = requiredMeasureNames.filter(i => i !== next.firstWord)
      next = next.next
    }
    requiredMeasureNames.forEach(name =>
      errors.push(this.makeError(`Concept "${this.content}" is missing required measure "${name}".`))
    )
    return errors
  }
abstractNumericMeasureParser
 string typeForCsvDocs number
 extends abstractMeasureParser
 javascript
  get measureValue() {
    const {content} = this
    return content === undefined ? "" : parseFloat(content)
  }
abstractIntegerMeasureParser
 string typeForCsvDocs integer
 cells measureNameCell integerCell
 extends abstractNumericMeasureParser
abstractFloatMeasureParser
 cells measureNameCell floatCell
 extends abstractNumericMeasureParser
abstractPercentageMeasureParser
 cells measureNameCell percentCell
 extends abstractNumericMeasureParser
 javascript
  get measureValue() {
    const {content} = this
    return content === undefined ? "" : parseFloat(content)
  }
abstractEnumMeasureParser
 string typeForCsvDocs enum
 cells measureNameCell enumCell
 extends abstractMeasureParser
abstractBooleanMeasureParser
 string typeForCsvDocs boolean
 cells measureNameCell booleanCell
 extends abstractMeasureParser
 javascript
  get measureValue() {
    const {content} = this
    return content === undefined ? "" : content == "true"
  }
metaTagsParser
 cruxFromId
 extends abstractScrollParser
 description Print meta tags including title.
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  compile() {
   const { file } = this.parent
   const { title, description, openGraphImage, SCROLL_VERSION, canonicalUrl } = file
   const rssFeedUrl = this.parent.get("rssFeedUrl")
   let rssTag = ""
   if (rssFeedUrl)
    rssTag = `<link rel="alternate" type="application/rss+xml" title="${title}" href="${rssFeedUrl}">`
   // todo: cleanup the head/body stuff.
   return `<head>
   <meta charset="utf-8">
   <title>${title}</title>
   <script>/* This HTML was generated by 📜 Scroll v${SCROLL_VERSION}. https://scroll.pub */</script>
   <style>@media print {.doNotPrint {display: none !important;}}</style>
   <link rel="canonical" href="${canonicalUrl}">
   <meta name="viewport" content="width=device-width,initial-scale=1">
   <meta name="description" content="${description}">
   <meta name="generator" content="Scroll v${SCROLL_VERSION}">
   <meta property="og:title" content="${title}">
   <meta property="og:description" content="${description}">
   <meta property="og:image" content="${openGraphImage}">
   ${rssTag}
   <meta name="twitter:card" content="summary_large_image">
  </head>
  <body>`
  }
pageFooterParser
 cruxFromId
 description HTML footer.
 extends abstractScrollParser
 string hakon
  .pageFooter
   margin-top 8px
   padding-top 8px
   text-align center
   svg
    width 30px
    height 30px
    fill rgba(204,204,204, .5)
    padding 0 7px
    &:hover
     fill #333
  .pageFooterScrollLink
   font-family Verdana
   font-weight 100
   margin .5em
   a
    color rgba(204,204,204,.5)
    &:hover
     color #333
     text-decoration none
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  get css() {
    const hakonParser = this.root.hakonParser
    return new hakonParser(this.hakon).compile()
  }
  compile() {
   const file = this.parent.file
   const { SVGS, SCROLL_VERSION, viewSourceUrl } = file
   const closeContainerTag = "</div>"
   const emailLink = file.email ? `a ${SVGS.email}
    href mailto:${file.email}` : ""
   const downloadLink = file.downloadUrl ? `a ${SVGS.download}
    href ${file.downloadUrl}` : ""
   const gitLink = file.viewSourceUrl ? `a ${SVGS.git}
    title View Source
    href ${file.viewSourceUrl}` : ""
   return (
    closeContainerTag + `<style>${this.css}</style>` +
    file.compileStumpCode(`p
   class scrollViewSource doNotPrint
  div
   class pageFooter doNotPrint
   ${emailLink}
   ${downloadLink}
   ${gitLink}
   div
    class pageFooterScrollLink
    a Built with Scroll v${SCROLL_VERSION}
     href https://scroll.pub`)
   )
  }
pageHeaderParser
 cruxFromId
 description HTML footer.
 extends abstractScrollParser
 string hakon
  .pageHeader
   position absolute
   top .25rem
   right 0
   left 0
   svg
    width 1.875rem
    height 1.875rem
    fill rgba(204,204,204,.8)
    &:hover
     fill #333
   a
    color rgba(204,204,204,.8)
    position absolute
    font-size 1.875rem
    line-height 1.7rem
    text-decoration none
    &:hover
     color #333
 javascript
  compileEmbeddedVersion() {
   return ""
  }
  get css() {
    const hakonParser = this.root.hakonParser
    return new hakonParser(this.hakon).compile()
  }
  compile() {
   const file = this.parent.file
   const { SVGS, linkToPrevious, linkToNext, viewSourceUrl } = file
   let previousButton = ""
   if (linkToPrevious)
    previousButton = `a &lt;
    style left:.1875rem;
    href ${linkToPrevious}`
   let nextButton = ""
   if (linkToNext)
    nextButton = `a &gt;
    style right:.1875rem;
    href ${linkToNext}`
   const gitLink = file.viewSourceUrl ? `a ${SVGS.git}
    style text-align:right;right: 1.5625rem;
    title View Source
    href ${file.viewSourceUrl}` : ""
   return `<style>\n${this.css}\n</style>` + file.compileStumpCode(`div
   class pageHeader doNotPrint
   ${previousButton}
   a ${SVGS.home}
    style text-align:left;left:1.5625rem;
    href ${file.get("homeUrl") || "index.html"}
   ${gitLink}
   ${nextButton}`)
  }
scrollParserDefinitionParser
 extends abstractScrollParser
 // todo Figure out best pattern for merging Scroll and Parsers?
 pattern ^[a-zA-Z0-9_]+Parser$
 description Define your own Parsers.
 baseParser blobParser
 javascript
  compile() {
   return ""
  }
quoteParser
 cruxFromId
 description A quote.
 catchAllParser quoteLineParser
 extends abstractScrollParser
 javascript
  compile() {
   return `<blockquote class="scrollQuote">${this.childrenToString()}</blockquote>`
  }
  compileTxt() {
    return this.childrenToString()
  }
redirectToParser
 description HTML redirect tag.
 extends abstractScrollParser
 cells commandWordCell urlCell
 cruxFromId
 example
  redirectTo https://scroll.pub/releaseNotes.html
 javascript
  compile() {
   return `<meta http-equiv="Refresh" content="0; url='${this.getWord(1)}'" />`
  }
abstractVariableParser
 extends abstractScrollParser
 catchAllCellType stringCell
 cells preBuildCommandWordCell
 cruxFromId
 javascript
  isTopMatter = true
  compile() {
   return ""
  }
replaceParser
 description Replace this with that.
 extends abstractVariableParser
 baseParser blobParser
 example
  replace YEAR 2022
replaceJsParser
 description Replace this with evaled JS.
 extends replaceParser
 catchAllCellType javascriptCell
 example
  replaceJs SUM 1+1
  * 1+1 = SUM
replaceNodejsParser
 description Replace this with evaled Node.JS.
 extends abstractVariableParser
 catchAllCellType javascriptCell
 baseParser blobParser
 example
  replaceNodejs
   module.exports = {SCORE : 1 + 2}
  * The score is SCORE
scriptParser
 extends abstractScrollParser
 description Print script tag.
 cruxFromId
 catchAllParser scriptLineParser
 catchAllCellType scriptAnyCell
 javascript
  compile() {
   return `<script>${this.scriptContent}</script>`
  }
  get scriptContent() {
    return this.content ?? this.childrenToString()
  }
  compileJs() {
    return this.scriptContent
  }
endSnippetParser
 description Cut for snippet here.
 extends abstractScrollParser
 cruxFromId
 javascript
  compile() {
   return ""
  }
stampParser
 description Expand project template to disk.
 extends abstractScrollParser
 inScope stampFolderParser
 catchAllParser stampFileParser
 example
  stamp
   .gitignore
    *.html
   readme.scroll
    # Hello world
    <script src="scripts/nested/hello.js"></script>
   scripts/
    nested/
     hello.js
      console.log("Hello world")
 cruxFromId
 cells preBuildCommandWordCell
 javascript
  build() {
    const dir = this.root.file.folderPath
    this.forEach(node => node.build(dir))
  }
abstractTableParser
 cruxFromId
 catchAllParser rowParser
 extends abstractScrollParser
 javascript
  get tableHeader() {
   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\n`)
  }
  get columnNames() {
   const header = this.nodeAt(0)
   return header ? header.getLine().split(this.delimiter) : []
  }
  get columns() {
   const cols = this.columnNames
   return cols.map((name, index) => {
    const isLink = name.endsWith("Link")
    const linkIndex = cols.indexOf(name + "Link")
    return {
     name,
     isLink,
     linkIndex
    }
   })
  }
  get tableBody() {
   const { delimiter } = this
   return this.topDownArray
    .slice(1)
    .map(node => `<tr>${node.toRow(this.columns, delimiter)}</tr>`)
    .join("\n")
  }
  compile() {
   return `<table id="table${this._getUid()}" class="scrollTable">
   <thead><tr>${this.tableHeader.join("\n")}</tr></thead>
   <tbody>${this.tableBody}</tbody>
   </table>
   <script>
   document.querySelector('#table${this._getUid()}').addEventListener('click', e => {
    if (window.getSelection().toString() || e.target.closest('a') || !e.target.closest('tbody')) return;
    e.currentTarget.classList.toggle('expandedTable');
   });
   </script>`
  }
  compileTxt() {
    return this.childrenToString()
  }
tableParser
 description A table from a custom delimiter.
 extends abstractTableParser
 catchAllCellType anyCell
 javascript
  get delimiter() {
   return this.content ?? ""
  }
commaTableParser
 description A table from CSV data.
 extends abstractTableParser
 string delimiter ,
pipeTableParser
 description A table from |SV data.
 extends abstractTableParser
 string delimiter |
spaceTableParser
 description A table. Last column is catchall.
 extends abstractTableParser
 string delimiter  
tabTableParser
 description A table from TSV data.
 extends abstractTableParser
 string delimiter \t
treeTableParser
 // Useful when a column contains a text blob.
 description Table from Scroll Notation data.
 extends abstractTableParser
 catchAllParser treeRowParser
 javascript
  get columnNames() {
   return this._getUnionNames()
  }
  get tableBody() {
   return this.map(node => `<tr>${node.toRow(this.columns)}</tr>`).join("\n")
  }
 example
  treeTable
   row
    name Javascript
    example
     console.log("Hello world")
   row
    name Python
    example
     print "Hello world"
printTableParser
 description Print table from tabular data.
 cruxFromId
 catchAllCellType integerCell
 extends abstractScrollParser
 javascript
   compile() {
    const node = this.appendSibling("table \t", this.tsv)
    const html = node.compile()
    node.destroy()
    return html
   }
   getTableByIndex(index) {
      const hit = this.root.file.tables[parseInt(index)]
      if (!hit)
        console.error(`Table "${index}" not found`)
      return hit
   }
   get table() {
     const index = this.getWord(1)
     if (index !== undefined)
        return this.getTableByIndex(index)
     if (this.next.isTabularData)
       return this.next
     if (this.previous.isTabularData)
       return this.previous.headerNode
    return this.getTableByIndex(0)
   }
   get tsv() {
    const firstNode = this.table
    const lastNode = firstNode.lastNode
    const aftertext = lastNode.childrenToString() // todo: we could be more specific and ignore comments
    let tableNode = firstNode
    let tsv = tableNode.getLine()
    while (tableNode.next.isTabularData) {
      tsv += "\n" + (aftertext ? tableNode.next.applyAftertext(aftertext) : tableNode.next.getLine())
      tableNode = tableNode.next
      if (tableNode === firstNode)
        break
    }
     return tsv
   }
   compileTxt() {
     return this.tsv
   }
plainTextParser
 description Plain text oneliner or block.
 cruxFromId
 extends abstractScrollParser
 catchAllParser plainTextLineParser
 catchAllCellType stringCell
 javascript
  compile() {
   return this.compileTxt()
  }
  compileTxt() {
    return `${this.content ?? ""}${this.childrenToString()}`
  }
plainTextOnlyParser
 extends plainTextParser
 description Only print for buildTxt.
 javascript
  compile() {
   return ""
  }
abstractAftertextAttributeParser
 cells commandWordCell
 boolean isAttribute true
 javascript
  get divAttributes() {
   return `${this.firstWord}="${this.content}"`
  }
  compile() {
   return ""
  }
aftertextIdParser
 crux id
 description Provide an ID to be output in the generated HTML tag.
 extends abstractAftertextAttributeParser
 cells commandWordCell htmlIdCell
 single
aftertextStyleParser
 crux style
 description Provide code for the generated HTML tag's "style" attribute.
 extends abstractAftertextAttributeParser
 cells commandWordCell
 catchAllCellType cssAnyCell
aftertextHiddenParser
 crux hidden
 cells commandWordCell
 description Do not compile this node to HTML.
 extends abstractAftertextAttributeParser
 single
aftertextTagParser
 cells commandWordCell htmlTagCell
 description Override the HTML tag that the compiled node will use.
 crux tag
 javascript
  compile() {
   return ""
  }
abstractAftertextDirectiveParser
 cells commandWordCell
 catchAllCellType stringCell
 javascript
  isMarkup = true
  compile() {
   return ""
  }
  getErrors() {
    const errors = super.getErrors()
    if (!this.isMarkup || this.matchWholeLine) return errors
    const inserts = this.getInserts(this.parent.originalTextPostLinkify)
    // todo: make AbstractTreeError class exported by sdk to allow Parsers to define their own error types.
    // todo: also need to be able to map lines back to their line in source (pre-imports)
    if (!inserts.length)
     errors.push(this.makeError(`No match found for "${this.getLine()}".`))
    return errors
  }
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get shouldMatchAll() {
   return this.has("matchAll")
  }
  getMatches(text) {
   const { pattern } = this
   const escapedPattern = pattern.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   return [...text.matchAll(new RegExp(escapedPattern, "g"))].map(match => {
    const { index } = match
    const endIndex = index + pattern.length
    return [
     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },
     { index: endIndex, endIndex, string: `</${this.closeTag}>` }
    ]
   })
  }
  getInserts(text) {
   const matches = this.getMatches(text)
   if (!matches.length) return false
   if (this.shouldMatchAll) return matches.flat()
   const match = this.getNode("match")
   if (match)
    return match.indexes
     .map(index => matches[index])
     .filter(i => i)
     .flat()
   return matches[0]
  }
  get allAttributes() {
   const attr = this.attributes.join(" ")
   return attr ? " " + attr : ""
  }
  get attributes() {
   return []
  }
  get openTag() {
   return this.tag
  }
  get closeTag() {
   return this.tag
  }
abstractMarkupParser
 extends abstractAftertextDirectiveParser
 inScope abstractMarkupParameterParser
 javascript
  get matchWholeLine() {
    return this.getWordsFrom(this.patternStartsAtWord).length === 0
  }
  get pattern() {
   return this.matchWholeLine ? this.parent.originalText : this.getWordsFrom(this.patternStartsAtWord).join(" ")
  }
  patternStartsAtWord = 1
boldParser
 cruxFromId
 description Bold matching text.
 extends abstractMarkupParser
 javascript
  tag = "b"
italicsParser
 cruxFromId
 description Italicize matching text.
 extends abstractMarkupParser
 javascript
  tag = "i"
underlineParser
 description Underline matching text.
 cruxFromId
 extends abstractMarkupParser
 javascript
  tag = "u"
afterTextCenterParser
 description Center paragraph.
 crux center
 extends abstractMarkupParser
 javascript
  tag = "center"
aftertextCodeParser
 description Wrap matching text in code span.
 crux code
 extends abstractMarkupParser
 javascript
  tag = "code"
aftertextStrikeParser
 description Wrap matching text in s span.
 crux strike
 extends abstractMarkupParser
 javascript
  tag = "s"
classMarkupParser
 description Add a custom class to the parent element instead. If matching text provided, a span with the class will be added around the matching text.
 extends abstractMarkupParser
 cells commandWordCell classNameCell
 crux class
 javascript
  tag = "span"
  get applyToParentElement() {
   return this.words.length === 2
  }
  getInserts(text) {
   // If no select text is added, set the class on the parent element.
   if (this.applyToParentElement) return []
   return super.getInserts(text)
  }
  get className() {
   return this.getWord(1)
  }
  get attributes() {
   return [`class="${this.className}"`]
  }
  get matchWholeLine() {
    return this.applyToParentElement
  }
  get pattern() {
   return this.matchWholeLine ? this.parent.content : this.getWordsFrom(2).join(" ")
  }
classesMarkupParser
 extends classMarkupParser
 crux classes
 javascript
  applyToParentElement = true
  get className() {
   return this.content
  }
hoverNoteParser
 description Add a caveat viewable on hover on matching text. When you want to be sure you've thoroughly addressed obvious concerns but ones that don't warrant to distract from the main argument of the text.
 cruxFromId
 extends classMarkupParser
 catchAllParser lineOfTextParser
 cells commandWordCell
 javascript
  get pattern() {
   return this.getWordsFrom(1).join(" ")
  }
  get attributes() {
   return [`class="scrollHoverNote"`, `title="${this.hoverNoteText}"`]
  }
  get hoverNoteText() {
   return this.childrenToString().replace(/\n/g, " ")
  }
linkParser
 extends abstractMarkupParser
 description Put the matching text in an <a> tag.
 cells commandWordCell urlCell
 inScope linkTitleParser linkTargetParser commentParser
 programParser
  description Anything here will be URI encoded and then appended to the link.
  cruxFromId
  cells commandWordCell
  catchAllParser programLinkParser
  javascript
   get encoded() {
    return encodeURIComponent(this.childrenToString())
   }
 cruxFromId
 javascript
  tag = "a"
  compileTxt() {
    return this.root.file.ensureAbsoluteLink(this.link) + " " + this.pattern
  }
  get link() {
   const {baseLink} = this
   if (this.has("program"))
     return baseLink + this.getNode("program").encoded
   return baseLink
  }
  get baseLink() {
   const link = this.getWord(1)
   const isAbsoluteLink = link.includes("://")
   if (isAbsoluteLink) return link
   const relativePath = this.parent.compileSettings?.relativePath || ""
   return relativePath + link
  }
  get attributes() {
   const attrs = [`href="${this.link}"`]
   const options = ["title", "target"]
   options.forEach(option => {
    const node = this.getNode(option)
    if (node) attrs.push(`${option}="${node.content}"`)
   })
   return attrs
  }
  patternStartsAtWord = 2
emailLinkParser
 description A mailto link
 crux email
 extends linkParser
 javascript
  get attributes() {
   return [`href="mailto:${this.link}"`]
  }
quickLinkParser
 pattern ^https?\:
 extends linkParser
 cells urlCell
 javascript
  get link() {
   return this.firstWord
  }
  patternStartsAtWord = 1
wrapsOnParser
 cruxFromId
 description Only turn on named wraps.
 example
  Hello *world*!
   wrapsOn bold
 extends abstractAftertextDirectiveParser
 catchAllCellType wrapNameCell
 javascript
  get shouldMatchAll() {
   return true
  }
  get wraps() {
    const wraps = [{delimiter: "`", tag: "code", exclusive: true, name: "code"},{delimiter: "*", tag: "strong", name: "bold"}, {delimiter: "_", tag: "em", name: "italics"}]
    // only add katex wrap if the root doc has katex.
    if (this.root.has("katex"))
      wraps.unshift({delimiter: "$", tag: "span", attributes: ' class="scrollKatex"', exclusive: true, name: "katex"})
    if (this.content)
      return wraps.filter(wrap => this.content.includes(wrap.name))
    return wraps
  }
  matchWholeLine = true
  getMatches(text) {
   const exclusives = []
   return this.wraps.map(wrap => this.runPattern(text, wrap, exclusives)).filter(i => i).flat()
  }
  runPattern(text, wrap, exclusives = []) {
   const {delimiter, tag, attributes} = wrap
   const escapedDelimiter = delimiter.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, "g")
   const delimiterLength = delimiter.length
   return [...text.matchAll(pattern)].map(match => {
    const { index } = match
    const endIndex = index + match[0].length
    // I'm too lazy to clean up sdk to write a proper inline markup parser so doing this for now.
    // The exclusive idea is to not try and apply bold or italic styles inside a TeX or code inline style.
    // Note that the way this is currently implemented any TeX in an inline code will get rendered, but code
    // inline of TeX will not. Seems like an okay tradeoff until a proper refactor and cleanup can be done.
    if (exclusives.some(exclusive => index >= exclusive[0] && index <= exclusive[1]))
      return undefined
    if (wrap.exclusive)
      exclusives.push([index, endIndex])
    return [
     { index, string: `<${tag + (attributes ? " " + attributes : "")}>`, endIndex, consumeStartCharacters: delimiterLength },
     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }
    ]
   }).filter(i => i)
  }
wrapParser
 cruxFromId
 cells commandWordCell delimiterCell tagOrUrlCell
 catchAllCellType htmlAttributesCell
 extends wrapsOnParser
 description Define a custom wrap, for example "wrap _ em" would support: _italics_.
 javascript
  getMatches(text) {
   try {
    const delimiter = this.getWord(1)
    const tag = this.getWord(2)
    const attributes = this.getWordsFrom(3).join(" ")
    if (tag.startsWith("https:")) return this.runPattern(text, {delimiter, tag: "a", attributes: `href="${tag}"` + attributes})
    return this.runPattern(text, {delimiter, tag, attributes})
   } catch (err) {
    console.error(err)
    return []
   }
   // Note: doubling up doesn't work because of the consumption characters.
  }
datelineParser
 cruxFromId
 description Gives your paragraph a dateline like "December 15, 2021 — The..."
 extends abstractAftertextDirectiveParser
 javascript
  getInserts() {
   const {day} = this
   if (!day) return false
   return [{ index: 0, string: `<span class="scrollDateline">${day} — </span>` }]
  }
  matchWholeLine = true
  get day() {
   let day = this.content || this.root.get("date") || this.root.file?.date
   if (!day) return ""
   try {
    const dayjs = require("dayjs")
    return dayjs(day).format(`MMMM D, YYYY`)
   } catch (err) {
    console.error(err)
   }
   return day || ""
  }
dayjsParser
 description Advanced directive that evals some Javascript code in an environment including "dayjs".
 cruxFromId
 extends abstractAftertextDirectiveParser
 javascript
  getInserts() {
   const dayjs = require("dayjs")
   const days = eval(this.content)
   const index = this.parent.originalTextPostLinkify.indexOf("days")
   return [{ index, string: `${days} ` }]
  }
linkifyParser
 description Use this to disable linkify on the text.
 extends abstractAftertextDirectiveParser
 cruxFromId
 cells commandWordCell booleanCell
abstractMarkupParameterParser
 cells commandWordCell
 cruxFromId
matchAllParser
 description Use this to match all occurrences of the text.
 extends abstractMarkupParameterParser
matchParser
 catchAllCellType integerCell
 description Use this to specify which index(es) to match.
 javascript
  get indexes() {
   return this.getWordsFrom(1).map(num => parseInt(num))
  }
 example
  aftertext
   hello ello ello
   bold ello
    match 0 2
 extends abstractMarkupParameterParser
abstractHtmlAttributeParser
 javascript
  compile() {
   return ""
  }
linkTargetParser
 extends abstractHtmlAttributeParser
 description If you want to set the target of the link. To "_blank", for example.
 crux target
 cells commandWordCell anyCell
blankLineParser
 description Print nothing. Break section.
 cells blankCell
 boolean isPopular true
 javascript
  compile() {
   return this.parent.clearSectionStack()
  }
 pattern ^$
 tags doNotSynthesize
chatLineParser
 catchAllCellType anyCell
 catchAllParser chatLineParser
lineOfCodeParser
 catchAllCellType codeCell
 catchAllParser lineOfCodeParser
commentLineParser
 catchAllCellType commentCell
cssLineParser
 catchAllCellType cssAnyCell
 catchAllParser cssLineParser
errorParser
 baseParser errorParser
heatrixCatchAllParser
 // todo Fill this out
 catchAllCellType stringCell
lineOfTextParser
 catchAllCellType stringCell
 boolean isTextParser true
htmlLineParser
 catchAllCellType htmlAnyCell
 catchAllParser htmlLineParser
stumpContentParser
 catchAllCellType anyCell
linkTitleParser
 description If you want to set the title of the link.
 crux title
 cells commandWordCell
 catchAllCellType anyCell
 example
  * This report showed the treatment had a big impact.
   https://example.com/report This report.
    title The average growth in the treatment group was 14.2x higher than the control group.
programLinkParser
 catchAllCellType codeCell
abstractLoopConfigParser
 cells commandWordCell
 cruxFromId
 catchAllCellType stringCell
abstractItemsProviderParser
 cells commandWordCell
loopLinesParser
 crux lines
 extends abstractItemsProviderParser
 description Iterate over the provided lines.
 catchAllParser loopLineParser
 loopLineParser
  catchAllCellType stringCell
 javascript
  get items() {
   return this.map(node => node.asString)
  }
loopWordsParser
 crux words
 extends abstractItemsProviderParser
 catchAllCellType stringCell
 description Iterate over the provided words.
 javascript
  get items() {
   return this.getWordsFrom(1)
  }
loopTagsParser
 crux tags
 extends abstractItemsProviderParser
 catchAllCellType tagWithOptionalFolderCell
 description Set this to iterate over scroll files in a folder. Provide both the folder and group name like this: [folder]/[tag]
 javascript
  get items() {
   return this.root.file.getFilesWithTagsForEmbedding(this.getWordsFrom(1))
  }
abstractPointConfigParser
 // todo: scoped parsers should support abstract types
 cruxFromId
 cells commandWordCell
 catchAllCellType stringCell
 single
latParser
 cells commandWordCell floatCell
 cruxFromId
 single
longParser
 cells commandWordCell floatCell
 cruxFromId
 single
quoteLineParser
 catchAllCellType anyCell
 catchAllParser quoteLineParser
scrollParser
 extensions scroll
 description Scroll is a language for scientists of all ages. Refine, share and collaborate on ideas.
 root
 inScope abstractScrollParser blankLineParser
 catchAllParser catchAllParagraphParser
 compilesTo html
 javascript
  setFile(file) {
   this.file = file
   return this
  }
  compile(compileSettings) {
    this.sectionStack = []
    return this.map(child => child.compile(compileSettings)).filter(i => i).join("\n") + this.clearSectionStack()
  }
  sectionStack = []
  clearSectionStack() {
   const result = this.sectionStack.join("")
   this.sectionStack = []
   return result
  }
  get hakonParser() {
    if (this.isNodeJs())
      return require("scrollsdk/products/hakon.nodejs.js")
    return hakonParser
  }
  alreadyRequired = new Set()
  compileEmbeddedVersion(compileSettings) {
   this.sectionStack = []
   return this.map(child => (child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))
     .filter(i => i)
     .join("\n")
     .trim() + this.clearSectionStack()
  }
  get footnotes() {
   if (this._footnotes === undefined) this._footnotes = this.filter(node => node.isFootnote)
   return this._footnotes
  }
  file = {}
  get permalink() {
   return this.get("permalink") || this.file.permalink || ""
  }
 example
  # Hello world
  ## This is Scroll
  * It compiles to HTML.
  
  code
   // You can add code as well.
   print("Hello world")
scriptLineParser
 catchAllCellType scriptAnyCell
 catchAllParser scriptLineParser
stampFileParser
 catchAllCellType stringCell
 description Create a file.
 javascript
  build(parentDir) {
   const fs = require("fs")
   const path = require("path")
   const fullPath = path.join(parentDir, this.getLine())
   this.root.file.log(`Creating file ${fullPath}`)
   fs.mkdirSync(path.dirname(fullPath), {recursive: true})
   const content = this.childrenToString()
   fs.writeFileSync(fullPath, content, "utf8")
   const isExecutable = content.startsWith("#!")
   if (isExecutable) fs.chmodSync(fullPath, "755")
  }
stampFolderParser
 catchAllCellType stringCell
 description Create a folder.
 inScope stampFolderParser
 catchAllParser stampFileParser
 pattern \/$
 javascript
  build(parentDir) {
   const fs = require("fs")
   const path = require("path")
   const newPath = path.join(parentDir, this.getLine())
   this.root.file.log(`Creating folder ${newPath}`)
   fs.mkdirSync(newPath, {recursive: true})
   this.forEach(node => node.build(newPath))
  }
rowParser
 catchAllCellType stringCell
 javascript
  toRow(columns, delimiter) {
   const words = this.getLine().split(delimiter)
   let str = ""
   let column = 0
   const columnCount = columns.length
   while (column < columnCount) {
    const col = columns[column]
    column++
    const content = (columnCount === column ? words.slice(columnCount - 1).join(" ") : words[column - 1]) ?? ""
    if (col.isLink) continue
    let tagged = content
    const link = words[col.linkIndex]
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    else if (content.match(/^https?\:[^ ]+$/)) tagged = `<a href="${content}">${content}</a>`
    str += `<td>${tagged}</td>\n`
   }
   return str
  }
plainTextLineParser
 catchAllCellType stringCell
 catchAllParser plainTextLineParser
treeRowContentParser
 description Any blob content in a cell.
 cells stringCell
 catchAllCellType stringCell
treeRowColumnParser
 catchAllParser treeRowContentParser
 description A columnName value pair, or just a columnName if the value is a text blob.
 cells anyCell
 catchAllCellType stringCell
treeRowParser
 cells anyCell
 description The root node of a row.
 catchAllParser treeRowColumnParser
 javascript
  toRow(columns) {
   let str = ""
   columns.forEach(col => {
    const node = this.getNode(col.name)
    if (col.isLink) return
    if (!node) {
     str += "<td></td>\n"
     return
    }
    const content = (node.length ? node.childrenToString() : node.content) ?? ""
    let tagged = ""
    const link = this.get(col.name + "Link")
    if (col.linkIndex > -1 && link) tagged = `<a href="${link}">${content}</a>`
    else if (node.length) tagged = `<pre>${content}</pre>`
    else tagged = content
    str += `<td>${tagged}</td>\n`
   })
   return str
  }