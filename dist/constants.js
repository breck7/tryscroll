const AppConstants = {"grammar":"// Related work:\n CSS is great for text selector ideas: https://www.w3schools.com/cssref/css_selectors.asp\n Roff has a lot of related markup ideas: https://www.systutorials.com/docs/linux/man/7-groff_man/\n// Extend this if you want to create a new provider\n// Some basic providers:\n\n\n\n\n\n\n\n\n\nwrapNameCell\n description What wraps are available to turn on?\n enum bold italics code katex\nanyCell\nurlCell\n highlightScope constant.language\nkeywordCell\n highlightScope keyword\nstringCell\n highlightScope string\nbooleanCell\n highlightScope constant.language\n enum true false\nidCell\n highlightScope constant.language\ndateCell\n highlightScope string\nintegerCell\n highlightScope constant.numeric\nfloatCell\n highlightScope constant.numeric\npermalinkCell\n highlightScope string\n description A string that doesn't contain characters that might interfere with most filesystems. No slashes, for instance.\ncommentCell\n highlightScope comment\nblankCell\npersonNameCell\n extends stringCell\ncodeCell\n highlightScope comment\nbulletPointCell\n description Any token used as a bullet point such as \"-\" or \"1.\" or \">\"\n highlightScope keyword\nemailAddressCell\n extends stringCell\ntagOrUrlCell\n description An HTML tag or a url.\n highlightScope constant.language\ndelimiterCell\n description String to use as a delimiter.\n highlightScope string\nhtmlAttributesCell\n highlightScope comment\nhtmlTagCell\n highlightScope constant.language\n enum div span p a img ul ol li h1 h2 h3 h4 h5 h6 header nav section article aside main footer input button form label select option textarea table tr td th tbody thead tfoot br hr meta link script style title code\nclassNameCell\n highlightScope constant\nhtmlIdCell\n extends idCell\nfilePathCell\n extends stringCell\ncssAnyCell\n extends anyCell\ngroupNameCell\n extends permalinkCell\ngroupNameWithOptionalFolderCell\n description A group name optionally combined with a folder path. Only used when referencing groups, not in posts.\n extends stringCell\nhtmlAnyCell\n extends stringCell\njavascriptCell\n extends stringCell\nabstractScrollParser\n cells keywordCell\n javascript\n  compileEmbeddedVersion(compileSettings) {\n   return this.compile(compileSettings)\n  }\nabstractAftertextParser\n description Text followed by markup commands.\n extends abstractScrollParser\n inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser aftertextTagParser commentParser\n example\n  aftertext\n   Hello brave new world\n   link home.com new\n   bold brave new\n   underline new world\n   strikethrough wor\n javascript\n  get markupInserts() {\n   const { originalTextPostLinkify } = this\n   return this.filter(node => node.isMarkup)\n    .map(node => node.getInserts(originalTextPostLinkify))\n    .filter(i => i)\n    .flat()\n  }\n  get originalText() {\n   return this.content ?? \"\"\n  }\n  get originalTextPostLinkify() {\n   const { originalText } = this\n   const shouldLinkify = this.get(\"linkify\") === \"false\" || originalText.includes(\"<a \") ? false : true\n   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText\n  }\n  replaceNotes(originalText) {\n   // Skip the replacements if there are no footnotes or the text has none.\n   if (!this.root.footnotes.length || !originalText.includes(\"^\")) return originalText\n   this.root.footnotes.forEach((note, index) => {\n    const needle = note.firstWord\n    const {linkBack} = note\n    if (originalText.includes(needle)) originalText = originalText.replace(new RegExp(\"\\\\\" + needle + \"\\\\b\"), `<a href=\"#${note.anchorId}\" class=\"scrollNoteLink\" id=\"${linkBack}\"><sup>${note.label}</sup></a>`)\n   })\n   return originalText\n  }\n  get text() {\n   const { originalTextPostLinkify, markupInserts } = this\n   let adjustment = 0\n   let newText = originalTextPostLinkify\n   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.\n   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))\n   markupInserts.forEach(insertion => {\n    insertion.index += adjustment\n    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0\n    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0\n    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)\n    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters\n   })\n   return newText\n  }\n  tag = \"p\"\n  get className() {\n   const classLine = this.getNode(\"class\")\n   if (classLine && classLine.applyToParentElement) return classLine.content\n   return this.defaultClassName\n  }\n  defaultClassName = \"scrollParagraph\"\n  get isHidden() {\n    return this.has(\"hidden\")\n  }\n  compile(compileSettings) {\n   if (this.isHidden) return \"\"\n   this.compileSettings = compileSettings\n   const { className } = this\n   const classAttr = className ? `class=\"${this.className}\"` : \"\"\n   const tag = this.get(\"tag\") || this.tag\n   return `<${tag} ${this.divAttributes}${classAttr}>${this.text}</${tag}>`\n  }\n  get divAttributes() {\n   const attrs = this.filter(node => node.isAttribute)\n   return attrs.length ? attrs.map(node => node.divAttributes).join(\" \") + \" \" : \"\"\n  }\nthoughtParser\n // todo Perhaps rewrite this from scratch and move out of aftertext.\n extends abstractAftertextParser\n catchAllCellType stringCell\n description A thought.\n cruxFromId\n javascript\n  compile(compileSettings) {\n   if (this.isHidden) return \"\"\n   // Hacky, I know.\n   const newLine = this.has(\"wrapsOn\") ? undefined : this.appendLine(\"wrapsOn\")\n   const compiled = super.compile(compileSettings)\n   if (newLine)\n    newLine.destroy()\n   return compiled\n  }\nindentableThoughtParser\n extends thoughtParser\n inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser indentableThoughtParser\n javascript\n  compile() {\n   return (\n    super.compile() +\n    this.map(node => node.compile())\n     .join(\"\\n\")\n     .trim()\n   )\n  }\nchecklistTodoParser\n extends indentableThoughtParser\n example\n  [] Get milk\n description An incomplete checklist item.\n crux []\n string checked \n javascript\n  get text() {\n   return `<div style=\"text-indent:${(this.getIndentLevel() - 1) * 20}px;\"><input type=\"checkbox\" ${this.checked} id=\"${this.id}\"><label for=\"${this.id}\">` + super.text + `</label></div>`\n  }\n  get id() {\n   return this.get(\"id\") || \"item\" + this._getUid()\n  }\nchecklistDoneParser\n extends checklistTodoParser\n description A complete checklist list item.\n string checked checked\n crux [x]\n example\n  [x] get milk\nlistAftertextParser\n extends indentableThoughtParser\n example\n  - I had a _new_ thought.\n description A list item.\n crux -\n javascript\n  defaultClassName = \"\"\n  compile() {\n   const index = this.getIndex()\n   const parent = this.parent\n   const nodeClass = this.constructor\n   const isStartOfList = index === 0 || !(parent.nodeAt(index - 1) instanceof nodeClass)\n   const isEndOfList = parent.length === index + 1 || !(parent.nodeAt(index + 1) instanceof nodeClass)\n   const { listType } = this\n   return (isStartOfList ? `<${listType} ${this.attributes}>` : \"\") + `${super.compile()}` + (isEndOfList ? `</${listType}>` : \"\")\n  }\n  get attributes() {\n    return \"\"\n  }\n  tag = \"li\"\n  listType = \"ul\"\norderedListAftertextParser\n extends listAftertextParser\n description A list item.\n example\n  1. Hello world\n pattern ^\\d+\\. \n javascript\n  listType = \"ol\"\n  get attributes() { return ` start=\"${this.getWord(0)}\"`}\nblinkParser\n description Useful when you have a client that always needs to find 1 thing they would like you to change.\n extends thoughtParser\n crux blink\n javascript\n  compile() {\n   return `<span class=\"scrollBlink\">${super.compile()}</span>\n    <script>\n    setInterval(()=>{\n        Array.from(document.getElementsByClassName(\"scrollBlink\")).forEach(el => \n        el.style.color = el.style.color === \"white\" ? \"black\" : \"white\"\n        )\n    }, 2000)\n    </script>`\n  }\ncatchAllParagraphParser\n description Any top level line that doesn't match a keyword is treated as a thought (aka paragraph) node.\n extends thoughtParser\n cells stringCell\n javascript\n  get originalText() {\n   return this.getLine() || \"\"\n  }\nfootnoteDefinitionParser\n description A footnote. Can also be used as section notes.\n extends thoughtParser\n boolean isFootnote true\n pattern ^\\^.+$\n labelParser\n  description If you want to show a custom label for a footnote. Default label is the note definition index.\n  cruxFromId\n  cells keywordCell\n  catchAllCellType stringCell\n javascript\n  get divAttributes() {\n   return super.divAttributes + ` id=\"${this.anchorId}\"`\n  }\n  get anchorId() {\n   return `note${this.noteDefinitionIndex}`\n  }\n  get label() {\n   // In the future we could allow common practices like author name\n   return this.get(\"label\") || this.noteDefinitionIndex\n  }\n  get linkBack() {\n   return `noteUsage${this.noteDefinitionIndex}`\n  }\n  get text() {\n   return `${this.label} ${super.text} <a class=\"scrollFootNoteUsageLink\" href=\"#noteUsage${this.noteDefinitionIndex}\">‚Æê</a>`\n  }\n  get noteDefinitionIndex() {\n   return this.parent.footnotes.indexOf(this) + 1\n  }\ncaptionAftertextParser\n description An optional caption to accompany the resource.\n crux caption\n extends thoughtParser\nabstractHeaderParser\n extends thoughtParser\n javascript\n  compile(compileSettings) {\n   if (this.isHidden) return \"\"\n   this.parent.sectionStack.push(\"</div>\")\n   return `<div class=\"scrollSection\">` + super.compile(compileSettings)\n  }\nh4Parser\n description Compiles to an html h4 tag.\n extends abstractHeaderParser\n crux ####\n javascript\n  tag = \"h4\"\nquestionAftertextParser\n description A question.\n extends h4Parser\n crux ?\n javascript\n  defaultClassName = \"scrollQuestion\"\nh1Parser\n description Compiles to an html h1 tag.\n extends abstractHeaderParser\n crux #\n javascript\n  tag = \"h1\"\ntitleParser\n description Title of the page for meta tags and also compiles to an html h1 tag.\n extends abstractHeaderParser\n crux title\n javascript\n  compile(compileSettings) {\n   // Hacky, I know.\n   const { permalink } = this.parent.file\n   if (!permalink) return super.compile(compileSettings)\n   const newLine = this.appendLine(`link ${permalink}`)\n   const compiled = super.compile(compileSettings)\n   newLine.destroy()\n   return compiled\n  }\n  defaultClassName = \"scrollTitle\"\n  tag = \"h1\"\nh2Parser\n description Compiles to an html h2 tag.\n extends abstractHeaderParser\n crux ##\n javascript\n  tag = \"h2\"\nh3Parser\n description Compiles to an html h3 tag.\n extends abstractHeaderParser\n crux ###\n javascript\n  tag = \"h3\"\nh5Parser\n description Compiles to an html h5 tag.\n extends abstractHeaderParser\n crux #####\n javascript\n  tag = \"h5\"\nquickThoughtParser\n crux *\n extends thoughtParser\n example\n  * I had a _new_ thought.\nstartColumnsParser\n extends abstractAftertextParser\n cruxFromId\n catchAllCellType integerCell\n description Start a multicolumn grid.\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  columnWidth = 35\n  columnGap = 20\n  compile() {\n   const {columnWidth, columnGap} = this\n   const maxColumns = parseInt(this.getWord(1) ?? 10)\n   const maxTotalWidth = maxColumns * columnWidth + (maxColumns - 1) * columnGap\n   // Starting the columns always first clears the section stack.\n   return this.parent.clearSectionStack() + `<div class=\"scrollColumns\" style=\"column-width:${columnWidth}ch;column-count:${maxColumns};max-width:${maxTotalWidth}ch;\">`\n  }\nwideColumnsParser\n extends startColumnsParser\n description Start a double wide column.\n javascript\n  columnWidth = 90\nendColumnsParser\n extends abstractAftertextParser\n cruxFromId\n description End a multicolumn grid.\n javascript\n  compile() {\n   return \"</div>\"\n  }\n  compileEmbeddedVersion() {\n   return \"\"\n  }\nhorizontalRuleParser\n crux ---\n description Prints an html <hr> tag\n extends abstractAftertextParser\n javascript\n  compile() {\n   return `<hr>`\n  }\nloopParser\n extends abstractAftertextParser\n cells keywordCell\n description Iterate over files, lines or words, evaluating code and joining the resulting HTML.\n cruxFromId\n inScope abstractItemsProviderParser\n joinParser\n  extends abstractLoopConfigParser\n  description HTML to use to join the items.\n limitParser\n  extends abstractLoopConfigParser\n  description HTML to use to join the items.\n javascriptParser\n  extends abstractLoopConfigParser\n  description Javascript to execute for each file in the loop.\n javascript\n  compile() {\n   const code = this.get(\"javascript\")\n   const joinWith = this.get(\"join\") ?? \"\"\n   try {\n    const limit = this.get(\"limit\")\n    let items = this.items\n    if (limit) items = items.slice(0, parseInt(limit))\n    return items.map((item, index) => eval(code)).join(joinWith)\n   } catch (err) {\n    console.error(err)\n    return \"\"\n   } finally {\n    this.teardown()\n   }\n  }\n  get items() {\n   const provider = this.getChildInstancesOfParserId(\"abstractItemsProviderParser\")[0]\n   return provider ? provider.items : []\n  }\n  teardown() {}\nloremIpsumParser\n extends abstractAftertextParser\n cruxFromId\n description Generate dummy text.\n catchAllCellType integerCell\n javascript\n  compile() {\n   const text = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`\n   return text.repeat(this.getWord(1) ? parseInt(this.getWord(1)) : 1)\n  }\nsnippetsParser\n extends abstractAftertextParser\n cruxFromId\n cells keywordCell groupNameWithOptionalFolderCell\n catchAllCellType groupNameWithOptionalFolderCell\n description Prints the snippets of all files in the named group(s).\n example\n  snippets index\n javascript\n  makeSnippet(file, compileSettings) {\n    const {scrollProgram} = file\n    const snippetBreak = scrollProgram.getNode(\"endSnippet\")\n    if (!snippetBreak) return scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml\n    const indexOfBreak = snippetBreak.getIndex()\n    const linkRelativeToCompileTarget = compileSettings.relativePath + file.permalink\n    const joinChar = \"\\n\"\n    const html = scrollProgram\n        .map((child, index) => (index >= indexOfBreak ? \"\" : child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))\n        .filter(i => i)\n        .join(joinChar)\n        .trim() +\n      `<a class=\"scrollContinueReadingLink\" href=\"${linkRelativeToCompileTarget}\">Continue reading...</a>`\n    return html + file.viewSourceHtml\n  }\n  compile() {\n   const file = this.parent.file\n   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1))\n   const alreadyRequired = this.root.alreadyRequired\n   const snippets = files.map(file => {\n   const compileSettings = {relativePath: file.relativePath, alreadyRequired }\n   return `<div class=\"scrollSnippetContainer\">${this.makeSnippet(file.file, compileSettings)}</div>`\n   }).join(\"\\n\\n\")\n   return `<div class=\"scrollColumns\" style=\"column-width:35ch;\">${snippets}</div>`\n  }\nfullSnippetsParser\n extends snippetsParser\n cruxFromId\n description Prints the full contents of files that are in the named group.\n javascript\n  makeSnippet(file, compileSettings) {\n   return file.scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml\n  }\nviewSourceParser\n extends abstractAftertextParser\n cruxFromId\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n   const file = this.parent.file\n   const { viewSourceUrl } = file\n   return file.compileStumpCode(`p\n   class scrollViewSource doNotPrint\n   a View source\n    href ${viewSourceUrl}`)\n  }\nchatParser\n description A dialogue between two people.\n catchAllParser chatLineParser\n cruxFromId\n extends abstractScrollParser\n javascript\n  compile() {\n   return this.map((line, index) => `<div style=\"text-align: ${index % 2 ? \"right\" : \"left\"};\" class=\"scrollChat ${index % 2 ? \"scrollChatRight\" : \"scrollChatLeft\"}\"><span>${line.asString}</span></div>`).join(\"\")\n  }\ncodeParser\n description A code block.\n catchAllParser lineOfCodeParser\n extends abstractScrollParser\n javascript\n  compile() {\n   return `<code class=\"scrollCodeBlock\">${this.childrenToString().replace(/\\</g, \"&lt;\")}</code>`\n  }\n cruxFromId\ncodeWithLanguageParser\n description Use this to specify the language of the code block, such as csvCode or rustCode.\n extends codeParser\n pattern ^[a-zA-Z0-9_]+Code$\nabstractScrollWithRequirementsParser\n extends abstractScrollParser\n javascript\n  compile(compileSettings) {\n    const {requireOnce} = this\n    const set = compileSettings?.alreadyRequired || this.root.alreadyRequired\n    let requireSnippet = \"\"\n    if (!set.has(requireOnce)) {\n      set.add(requireOnce)\n      requireSnippet = requireOnce + \"\\n\\n\"\n    }\n    return requireSnippet + this.compileInstance()\n  }\ncopyButtonsParser\n cruxFromId\n extends abstractScrollWithRequirementsParser\n description Make code snippets copyable.\n javascript\n  compileInstance() {\n   return \"\"\n  }\n string requireOnce\n  <script>\n  document.addEventListener(\"DOMContentLoaded\", () => document.querySelectorAll(\".scrollCodeBlock\").forEach(block =>\n   {\n    if (!navigator.clipboard) return\n    const button = document.createElement(\"span\")\n    button.classList.add(\"scrollCopyButton\")\n    block.appendChild(button)\n    button.addEventListener(\"click\", async () => {\n      await navigator.clipboard.writeText(block.innerText)\n      button.classList.add(\"scrollCopiedButton\")\n    })\n   }\n  ))\n  </script>\nkatexParser\n cruxFromId\n extends abstractScrollWithRequirementsParser\n catchAllCellType codeCell\n catchAllParser lineOfCodeParser\n description Use the KaTex library to typeset math.\n string requireOnce\n  <link rel=\"stylesheet\" href=\"https://cdn.jsdelivr.net/npm/katex@0.16.6/dist/katex.min.css\" integrity=\"sha384-mXD7x5S50Ko38scHSnD4egvoExgMPbrseZorkbE49evAfv9nNcbrXJ8LLNsDgh9d\" crossorigin=\"anonymous\">\n  <script defer src=\"https://cdn.jsdelivr.net/npm/katex@0.16.6/dist/katex.min.js\" integrity=\"sha384-j/ZricySXBnNMJy9meJCtyXTKMhIJ42heyr7oAdxTDBy/CYA9hzpMo+YTNV5C+1X\" crossorigin=\"anonymous\"></script>\n  <script>\n  document.addEventListener(\"DOMContentLoaded\", () => document.querySelectorAll(\".scrollKatex\").forEach(el =>\n   {\n    katex.render(el.innerText, el, {\n        throwOnError: false\n    });\n   }\n  ))\n  </script>\n javascript\n  compileInstance() {\n   const id = this._getUid()\n   const content = this.content === undefined ? \"\" : this.content\n   return `<div class=\"scrollKatex\" id=\"${id}\">${content + this.childrenToString()}</div>`\n  }\nmapParser\n cruxFromId\n inScope latParser longParser\n zoomParser\n  cells keywordCell integerCell\n  cruxFromId\n  single\n heightParser\n  cells keywordCell floatCell\n  cruxFromId\n  single\n pointParser\n  cells keywordCell\n  inScope latParser longParser\n  cruxFromId\n  titleParser\n   extends abstractPointConfigParser\n  descriptionParser\n   extends abstractPointConfigParser\n extends abstractScrollWithRequirementsParser\n description Uses LeafletJs\n // todo Make this only require once\n string requireOnce\n  <link rel=\"stylesheet\" href=\"https://unpkg.com/leaflet@1.7.1/dist/leaflet.css\" />\n  <script src=\"https://unpkg.com/leaflet@1.7.1/dist/leaflet.js\"></script>\n javascript\n  compileInstance() {\n   const height = 500\n   const id = this._getUid()\n   return `<div id=\"map${id}\" style=\"height: ${height}px;\"></div>\n  <script>\n   {\n    const lat = ${this.get(\"lat\") ?? 37.8}\n    const long = ${this.get(\"long\") ?? 4}\n    const zoomLevel = ${this.get(\"zoom\") ?? 4}\n    const points = ${JSON.stringify(this.findNodes(\"point\").map(node => node.toObject()))}\n    const map = L.map(\"map${id}\").setView([lat, long], zoomLevel)\n    L.tileLayer(\"https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png\", {\n     attribution: '<a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a>',\n     maxZoom: 18\n    }).addTo(map)\n    points.forEach(point => {\n     L.marker([point.lat, point.long])\n      .addTo(map)\n      .bindPopup(\"<b>\" +point.title + \"</b><br />\" + point.description)\n    })\n   }\n  </script>`\n  }\nbelowAsCodeParser\n description Print the Scroll code of the next node.\n extends abstractScrollParser\n catchAllCellType integerCell\n cruxFromId\n javascript\n  method = \"next\"\n  get code() {\n   const { method } = this\n   let code = \"\"\n   let howMany = parseInt(this.getWord(1))\n   if (!howMany || isNaN(howMany)) howMany = 1\n   let nodes = []\n   let next = this[method]\n   while (howMany) {\n    nodes.push(next)\n    next = next[method]\n    howMany--\n   }\n   if (this.reverse) nodes.reverse()\n   return nodes.map(node => node.asString).join(\"\\n\")\n  }\n  reverse = false\n  compile() {\n   return `<code class=\"scrollCodeBlock\">${this.code.replace(/\\</g, \"&lt;\")}</code>`\n  }\naboveAsCodeParser\n description Print the Scroll code for the previous node.\n extends belowAsCodeParser\n javascript\n  method = \"previous\"\n  reverse = true\ncommentParser\n description Comments do not appear in the compiled HTML.\n catchAllCellType commentCell\n cells commentCell\n extends abstractScrollParser\n cruxFromId\n javascript\n  compile() {\n   return ``\n  }\n catchAllParser commentLineParser\nslashCommentParser\n extends commentParser\n crux //\ncounterpointParser\n description A counterpoint. Will not show up in the compiled HTML.\n extends commentParser\n crux !\nthanksToParser\n description A place to store data on reviewers who helped improve a post (and a reminder to seek feedback!). Does not appear in compiled HTML.\n extends commentParser\n cruxFromId\nbyLineParser\n description Prints a byline with the author's name and optionally a link to them.\n extends abstractScrollParser\n cruxFromId\n cells keywordCell urlCell\n catchAllCellType personNameCell\n example\n  // With Link:\n  byLine https://breckyunits.com Breck Yunits\n  // No link:\n  byLine  Breck Yunits\n javascript\n  compile() {\n   const link = this.getWord(1)\n   return `<div class=\"scrollByLine\">by <a ${link ? `href=\"${link}\"` : \"\"}>${this.getWordsFrom(2).join(\" \")}</a></div>`\n  }\nauthorParser\n extends byLineParser\ncssParser\n extends abstractScrollParser\n description Prints CSS content wrapped in a style tag.\n cruxFromId\n catchAllParser cssLineParser\n catchAllCellType cssAnyCell\n javascript\n  compile() {\n   return `<style>${this.content ?? \"\"}${this.childrenToString()}</style>`\n  }\nprintFeedParser\n description Prints out the RSS feed for a group.\n extends abstractScrollParser\n cruxFromId\n cells keywordCell groupNameWithOptionalFolderCell\n catchAllCellType groupNameWithOptionalFolderCell\n example\n  printFeed index\n  printFeed cars/index\n  permalink feed.xml\n javascript\n  compile() {\n   const dayjs = require(\"dayjs\")\n   const file = this.root.file\n   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1)).map(file => file.file)\n   const { title, baseUrl, description } = file\n   return `<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>\n  <rss version=\"2.0\">\n  <channel>\n   <title>${title}</title>\n   <link>${baseUrl}</link>\n   <description>${description}</description>\n   <lastBuildDate>${dayjs().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\")}</lastBuildDate>\n   <language>en-us</language>\n  ${files.map(file => file.toRss()).join(\"\\n\")}\n  </channel>\n  </rss>`\n  }\nprintCsvParser\n description Prints out a group as a CSV.\n extends printFeedParser\n example\n  printCsv index\n  permalink posts.csv\n javascript\n  compile() {\n   const file = this.root.file\n   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1)).map(file => file.file)\n   const header = file.csvFields\n   return `${header.join(\",\")}\\n${files.map(file => file.toCsv()).join(\"\\n\")}`\n  }\nprintSourceParser\n description Prints out the source code for each file in a group.\n extends printFeedParser\n example\n  printSource index\n  permalink source.txt\n javascript\n  compile() {\n   const file = this.root.file\n   const files = file.getFilesInGroupsForEmbedding(this.getWordsFrom(1)).map(file => file.file)\n   return `${files.map(file => file.filePath + \"\\n \" + file.originalScrollCode.replace(/\\n/g, \"\\n \") ).join(\"\\n\")}`\n  }\ndashboardParser\n description Display key stats in a big font.\n catchAllParser rowParser\n cruxFromId\n extends abstractScrollParser\n example\n  dashboard\n   #2 Popularity\n   30 Years Old\n   $456 Revenue\n javascript\n  get tableBody() {\n   const items = this.topDownArray\n   let str = \"\"\n   for (let i = 0; i < items.length; i = i + 3) {\n    str += this.makeRow(items.slice(i, i + 3))\n   }\n   return str\n  }\n  makeRow(items) {\n   return `<tr>` + items.map(node => `<td>${node.firstWord}<span>${node.content}</span></td>`).join(\"\\n\") + `</tr>\\n`\n  }\n  compile() {\n   return `<table class=\"scrollDashboard\">${this.tableBody}</table>`\n  }\nabstractTopLevelSingleMetaParser\n description Use these keywords once per file.\n extends abstractScrollParser\n cruxFromId\n cells keywordCell\n javascript\n  compile() {\n   return \"\"\n  }\ndateParser\n catchAllCellType dateCell\n description Date this file was first published.\n extends abstractTopLevelSingleMetaParser\npermalinkParser\n description When compiling, Scroll will save this file to {permalink}\n extends abstractTopLevelSingleMetaParser\n cells keywordCell permalinkCell\nabstractThemeCssParser\n description Extend this to create a Scroll CSS theme.\n extends abstractTopLevelSingleMetaParser\n inScope tagsParser\n cruxFromId\n catchAllCellType stringCell\n string scrollStyles\n  figure\n   margin 0\n   padding 0\n  .dropcap:first-letter\n   font-size 3em\n   line-height .9em\n   margin-right 2px\n   display block\n   float left\n  .scrollCaptionedFigure\n   display block\n   text-align center\n   img\n    max-width 100%\n    height auto\n    margin-top 3px\n   figcaption\n    font-family Verdana\n    font-size 80%\n    .scrollParagraph\n     margin-top 0\n     line-height 1.1em\n  .scrollCodeBlock\n   overflow auto\n   font-size 80%\n   hyphens none\n   white-space pre\n   break-inside avoid\n   display block\n   margin .5em 0\n   padding .5em\n   border-radius 0\n   position relative\n  .scrollCodeBlock:hover\n   .scrollCopyButton\n    opacity .5\n   .scrollCopyButton:hover\n    opacity .8\n   .scrollCopyButton:active\n    opacity 1\n  .scrollCopyButton\n   position absolute\n   top 2px\n   right 2px\n   font-size 14px\n   cursor pointer\n   opacity 0\n  .scrollCopyButton::after\n   content \"[ ]\"\n  .scrollCopiedButton::after\n   content \"[‚úì]\"\n javascript\n  get useTags() {\n    return !(this.get(\"tags\") === \"false\")\n  }\n  compile() {\n   return this.useTags ? `<style>${this.css}</style>` : this.css\n  }\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  get scrollCss() {\n    const hakonParser = this.root.hakonParser\n    return new hakonParser(this.scrollStyles).compile()\n  }\ngazetteCssParser\n description The default Scroll theme.\n extends abstractThemeCssParser\n javascript\n  get css() {\n    if (this.constructor._cachedCss)\n      return this.constructor._cachedCss\n    const hakonParser = this.root.hakonParser\n    this.constructor._cachedCss = this.scrollCss + new hakonParser([this.hakonReset, this.hakonStandardStyles].join(\"\\n\")).compile()\n    return this.constructor._cachedCss\n  }\n // CSS Reset\n string hakonReset\n  html,body,div,span,p,ol,ul,li,table,figure\n   margin 0\n   padding 0\n   border 0\n   vertical-align baseline\n   border-spacing 0\n  ol,ul\n   padding-left 1em\n  li\n   margin-top .4em\n   line-height 140%\n  a\n   text-decoration-color transparent\n  a:hover\n   text-decoration-color initial\n  sup,sub\n   vertical-align baseline\n   position relative\n   top -0.6em\n  sub\n   top 0.6em\n  html\n   padding 4px\n   background-color rgb(244,244,244)\n   font-family Exchange,Georgia,serif\n   color #000\n   font-size 14px\n   hyphens auto\n  p\n   margin-top 0.4em\n   line-height 1.4em\n  .scrollQuote\n   break-inside avoid\n   display block\n   margin .5em 0\n   padding .5em\n   background rgba(204,204,204,.5)\n   white-space pre-line\n   border-left .5em solid rgba(204,204,204,.8)\n  code\n   font-size 90%\n   background-color rgba(204,204,204,.5)\n   padding 2px 4px\n   border-radius 4px\n // Styles for Scroll standard tags\n string hakonStandardStyles\n  comment Main body of both pages is similar\n  .scrollParagraph\n   text-align justify\n  .scrollColumns\n   column-count auto\n   column-fill balance\n   column-width 35ch\n   column-gap 20px\n   padding-left 20px\n   padding-right 20px\n   margin auto\n  comment On group pages add some spacing around files\n  .scrollSnippetContainer\n   padding 1ch 0\n   break-inside avoid\n   text-align justify\n  h1\n   font-size 18px\n   margin 10px 0\n  h2\n   font-size 16px\n   margin 10px 0\n  h3\n   font-size 14px\n   margin 10px 0\n  h4\n   margin 10px 0\n   font-size 14px\n  h1.scrollTitle\n   text-align center\n   margin-bottom .25em\n   margin-top 0\n   font-size 28px\n   a\n    color #000\n  .scrollDateline\n   font-style italic\n   font-size 80%\n  .scrollSection\n   break-inside avoid\n   h1\n    text-align center\n   h2\n    text-align center\n   h3\n    text-align center\n   h4\n    text-align center\n  h4.scrollQuestion\n   text-align left\n  .scrollNoteLink\n   opacity .4\n  \n  .scrollHoverNote\n   text-decoration underline dashed 1px rgba(0,0,0,.1)\n   cursor default\n  \n  .scrollCodeBlock\n   border-left .5em solid rgba(204,204,204,.8)\n  \n  .scrollTable\n   table-layout fixed\n   margin .5em 0\n   overflow hidden\n   font-size 80%\n   width 100%\n   hyphens none\n   border 1px solid rgba(224,224,224,.8)\n   td,th\n    padding 3px\n    overflow hidden\n   th\n    border-bottom 2px solid rgba(0,0,0,.6)\n    text-align left\n   tr:nth-child(even)\n    background rgba(224,224,224,.6)\n  \n  .scrollByLine\n   font-size 12px\n   font-style italic\n   margin 4px 0\n   text-align center\n  \n  comment Subtle \"Article Source\" link\n  .scrollViewSource\n   text-align center\n   font-size 80%\n   margin 0\n   margin-top 0.4em\n   line-height 1.4em\n   margin-bottom 1em\n   a\n    color #000\n  \n  .scrollContinueReadingLink\n   display block\n   text-align center\n  \n  .scrollDashboard\n   width 100%\n   font-size 30px\n   text-align center\n   font-weight bold\n   break-inside avoid\n   margin-top 8px\n   margin-bottom 8px\n   td\n    width 33.3%\n    border 1px solid #e8e8e8\n   span\n    font-size 20p;\n    display block\n  .scrollChat\n   span\n    font-family Verdana\n    margin-top 5px\n    padding 5px 20px\n    border-radius 15px\n    display inline-block\n  .scrollChatLeft\n   span\n    background rgba(204,204,204, .5)\n  .scrollChatRight\n   span\n    color white\n    background rgb(0,132,255)\n  .scrollFootNoteUsageLink\n   color rgba(204,204,204,.5)\n   &:hover\n    color #333\n    text-decoration none\n  .scrollYouTubeHolder\n   position relative\n   width 100%\n   height 0\n   padding-bottom 56.25%\n  .scrollYouTubeEmbed\n   position absolute\n   top 0\n   left 0\n   width 100%\n   height 100%\ntufteCssParser\n description A theme built using Tufte CSS. https://github.com/edwardtufte/tufte-css\n extends abstractThemeCssParser\n javascript\n  get css() {\n    return this.scrollCss + this.tufteCss\n  }\n  tufteCss = `html {\n     font-size: 15px;\n  }\n   body {\n       width: 87.5%;\n       margin-left: auto;\n       margin-right: auto;\n       padding-left: 12.5%;\n       font-family: Palatino, \"Palatino Linotype\", \"Palatino LT STD\", \"Book Antiqua\", Georgia, serif;\n       background-color: #fffff8;\n       color: #111;\n       max-width: 1400px;\n       counter-reset: sidenote-counter;\n  }\n  /* Adds dark mode */\n   @media (prefers-color-scheme: dark) {\n       body {\n           background-color: #151515;\n           color: #ddd;\n      }\n  }\n   h1 {\n       font-weight: 400;\n       margin-top: 3rem;\n       margin-bottom: 1.5rem;\n       font-size: 2.4rem;\n       line-height: 1;\n  }\n  .scrollTitle a { text-decoration: none; font-size: 3.2rem;}\n  .scrollParagraph { text-align: justify; hyphens: auto;}\n  a.scrollNoteLink { text-decoration: none;}\n   h2 {\n       font-style: italic;\n       font-weight: 400;\n       margin-top: 2.1rem;\n       margin-bottom: 1.4rem;\n       font-size: 2.2rem;\n       line-height: 1;\n  }\n   h3 {\n       font-style: italic;\n       font-weight: 400;\n       font-size: 1.7rem;\n       margin-top: 2rem;\n       margin-bottom: 1.4rem;\n       line-height: 1;\n  }\n   hr {\n       display: block;\n       height: 1px;\n       width: 55%;\n       border: 0;\n       border-top: 1px solid #ccc;\n       margin: 1em 0;\n       padding: 0;\n  }\n   p.subtitle {\n       font-style: italic;\n       margin-top: 1rem;\n       margin-bottom: 1rem;\n       font-size: 1.8rem;\n       display: block;\n       line-height: 1;\n  }\n   .numeral {\n       font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\n  }\n   .danger {\n       color: red;\n  }\n   article {\n       padding: 5rem 0rem;\n  }\n   section {\n       padding-top: 1rem;\n       padding-bottom: 1rem;\n  }\n   p, dl, ol, ul {\n       font-size: 1.4rem;\n       line-height: 2rem;\n  }\n   p {\n       margin-top: 1.4rem;\n       margin-bottom: 1.4rem;\n       padding-right: 0;\n       vertical-align: baseline;\n  }\n  /* Chapter Epigraphs */\n   div.epigraph {\n       margin: 5em 0;\n  }\n   div.epigraph > blockquote {\n       margin-top: 3em;\n       margin-bottom: 3em;\n  }\n   div.epigraph > blockquote, div.epigraph > blockquote > p {\n       font-style: italic;\n  }\n   div.epigraph > blockquote > footer {\n       font-style: normal;\n  }\n   div.epigraph > blockquote > footer > cite {\n       font-style: italic;\n  }\n  /* end chapter epigraphs styles */\n   blockquote {\n       font-size: 1.4rem;\n  }\n   blockquote p {\n       width: 55%;\n       margin-right: 40px;\n  }\n   blockquote footer {\n       width: 55%;\n       font-size: 1.1rem;\n       text-align: right;\n  }\n   section > p, section > footer, section > table {\n       width: 55%;\n  }\n  /* 50 + 5 == 55, to be the same width as paragraph */\n   section > dl, section > ol, section > ul {\n       width: 50%;\n       -webkit-padding-start: 5%;\n  }\n   dt:not(:first-child), li:not(:first-child) {\n       margin-top: 0.25rem;\n  }\n  /* Links: replicate underline that clears descenders */\n   a:link, a:visited {\n       color: inherit;\n  }\n  /* Sidenotes, margin notes, figures, captions */\n   img {\n       max-width: 100%;\n  }\n   .sidenote, .marginnote {\n       float: right;\n       clear: right;\n       margin-right: -60%;\n       width: 50%;\n       margin-top: 0.3rem;\n       margin-bottom: 0;\n       font-size: 1.1rem;\n       line-height: 1.3;\n       vertical-align: baseline;\n       position: relative;\n  }\n   .sidenote-number {\n       counter-increment: sidenote-counter;\n  }\n   .sidenote-number:after, .sidenote:before {\n       font-family: -apple-system, BlinkMacSystemFont, \"Segoe UI\", Roboto, Helvetica, Arial, sans-serif;\n       position: relative;\n       vertical-align: baseline;\n  }\n   .sidenote-number:after {\n       content: counter(sidenote-counter);\n       font-size: 1rem;\n       top: -0.5rem;\n       left: 0.1rem;\n  }\n   .sidenote:before {\n       content: counter(sidenote-counter) \" \";\n       font-size: 1rem;\n       top: -0.5rem;\n  }\n   blockquote .sidenote, blockquote .marginnote {\n       margin-right: -82%;\n       min-width: 59%;\n       text-align: left;\n  }\n   div.fullwidth, table.fullwidth {\n       width: 100%;\n  }\n   div.table-wrapper {\n       overflow-x: auto;\n       font-family: \"Trebuchet MS\", \"Gill Sans\", \"Gill Sans MT\", sans-serif;\n  }\n   .sans {\n       font-family: \"Gill Sans\", \"Gill Sans MT\", Calibri, sans-serif;\n       letter-spacing: 0.03em;\n  }\n   code, pre > code {\n       font-family: Consolas, \"Liberation Mono\", Menlo, Courier, monospace;\n       font-size: 1rem;\n       line-height: 1.42;\n       -webkit-text-size-adjust: 100%;\n      /* Prevent adjustments of font size after orientation changes in iOS. See https://github.com/edwardtufte/tufte-css/issues/81#issuecomment-261953409 */\n  }\n   .sans > code {\n       font-size: 1.2rem;\n  }\n   h1 > code, h2 > code, h3 > code {\n       font-size: 0.8em;\n  }\n   .marginnote > code, .sidenote > code {\n       font-size: 1rem;\n  }\n   pre > code {\n       font-size: 0.9rem;\n       width: 52.5%;\n       margin-left: 2.5%;\n       overflow-x: auto;\n       display: block;\n  }\n   pre.fullwidth > code {\n       width: 90%;\n  }\n   .fullwidth {\n       max-width: 90%;\n       clear: both;\n  }\n   span.newthought {\n       font-variant: small-caps;\n       font-size: 1.2em;\n  }\n   input.margin-toggle {\n       display: none;\n  }\n   label.sidenote-number {\n       display: inline-block;\n       max-height: 2rem;\n      /* should be less than or equal to paragraph line-height */\n  }\n   label.margin-toggle:not(.sidenote-number) {\n       display: none;\n  }\n   .iframe-wrapper {\n       position: relative;\n       padding-bottom: 56.25%;\n      /* 16:9 */\n       padding-top: 25px;\n       height: 0;\n  }\n   .iframe-wrapper iframe {\n       position: absolute;\n       top: 0;\n       left: 0;\n       width: 100%;\n       height: 100%;\n  }\n   @media (max-width: 760px) {\n       body {\n           width: 84%;\n           padding-left: 8%;\n           padding-right: 8%;\n      }\n       hr, section > p, section > footer, section > table {\n           width: 100%;\n      }\n       pre > code {\n           width: 97%;\n      }\n       section > dl, section > ol, section > ul {\n           width: 90%;\n      }\n       blockquote {\n           margin-left: 1.5em;\n           margin-right: 0em;\n      }\n       blockquote p, blockquote footer {\n           width: 100%;\n      }\n       label.margin-toggle:not(.sidenote-number) {\n           display: inline;\n      }\n       .sidenote, .marginnote {\n           display: none;\n      }\n       .margin-toggle:checked + .sidenote, .margin-toggle:checked + .marginnote {\n           display: block;\n           float: left;\n           left: 1rem;\n           clear: both;\n           width: 95%;\n           margin: 1rem 2.5%;\n           vertical-align: baseline;\n           position: relative;\n      }\n       label {\n           cursor: pointer;\n      }\n       div.table-wrapper, table {\n           width: 85%;\n      }\n       img {\n           width: 100%;\n      }\n  }`\ngroupsParser\n description Add this file to zero or more groups.\n cruxFromId\n example\n  groups index.html\n extends abstractTopLevelSingleMetaParser\n cells keywordCell\n catchAllCellType groupNameCell\nmetaTagsParser\n cruxFromId\n extends abstractTopLevelSingleMetaParser\n description Adds meta tags like title, description, et cetera.\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n   const { file } = this.parent\n   const { title, description, openGraphImage, SCROLL_VERSION, canonicalLink } = file\n   const rssFeedUrl = file.get(\"rssFeedUrl\")\n   let rssTag = \"\"\n   if (rssFeedUrl) {\n    rssTag = `link\n   rel alternate\n   type application/rss+xml\n   title ${title}\n   href ${rssFeedUrl}`\n   }\n   return file.compileStumpCode(`meta\n   charset utf-8\n  titleTag ${title}\n  script /* This HTML was generated by üìú Scroll v${SCROLL_VERSION}. http://scroll.pub */\n  styleTag @media print {.doNotPrint {display: none !important;}}\n  link\n   rel canonical\n   href ${canonicalLink}\n  meta\n   charset iso-8859-1\n  meta\n   name viewport\n   content width=device-width,initial-scale=1\n  meta\n   name description\n   content ${description}\n  meta\n   name generator\n   content Scroll v${SCROLL_VERSION}\n  meta\n   property og:title\n   content ${title}\n  meta\n   property og:description\n   content ${description}\n  meta\n   property og:image\n   content ${openGraphImage}\n  ${rssTag}\n  meta\n   name twitter:card\n   content summary_large_image`)\n  }\nhtmlLangParser\n cells keywordCell stringCell\n description The lang attribute for the <html lang=\"\"> tag. If not specified will be \"en\". See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang\n extends abstractTopLevelSingleMetaParser\ndescriptionParser\n catchAllCellType stringCell\n description Description for Open Graph. https://ogp.me/. If not defined, Scroll will try to generate it's own.\n extends abstractTopLevelSingleMetaParser\npageFooterParser\n cruxFromId\n description A footer for your page.\n extends abstractTopLevelSingleMetaParser\n string hakon\n  .pageFooter\n   margin-top 8px\n   padding-top 8px\n   text-align center\n   svg\n    width 30px\n    height 30px\n    fill rgba(204,204,204, .5)\n    padding 0 7px\n    &:hover\n     fill #333\n  .pageFooterScrollLink\n   display block\n   font-family Verdana\n   font-weight 100\n   margin .5em\n   color rgba(204,204,204,.5)\n   &:hover\n    color #333\n    text-decoration none\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  get css() {\n    const hakonParser = this.root.hakonParser\n    return new hakonParser(this.hakon).compile()\n  }\n  compile() {\n   const file = this.parent.file\n   const { SVGS, SCROLL_VERSION, viewSourceUrl } = file\n   const closeContainerTag = \"</div>\"\n   return (\n    closeContainerTag + `<style>${this.css}</style>` +\n    file.compileStumpCode(`p\n   class scrollViewSource doNotPrint\n   a View source\n    href ${viewSourceUrl}\n  div\n   class pageFooter doNotPrint\n   a ${SVGS.email}\n    href mailto:${file.email}\n   a ${SVGS.git}\n    href ${file.git}\n   a Built with Scroll v${SCROLL_VERSION}\n    href https://scroll.pub\n    class pageFooterScrollLink\n    style display:block; margin: .5em;`)\n   )\n  }\ngazetteFooterParser\n extends pageFooterParser\n description DEPRECATED! Use \"pageFooter\" instead.\npageHeaderParser\n cruxFromId\n description A header for your page.\n extends abstractTopLevelSingleMetaParser\n string hakon\n  .pageHeader\n   position absolute\n   top 4px\n   right 0\n   left 0\n   svg\n    width 30px\n    height 30px\n    fill rgba(204,204,204,.8)\n    &:hover\n     fill #333\n   a\n    color rgba(204,204,204,.8)\n    position absolute\n    font-size 30px\n    line-height 27px\n    text-decoration none\n    &:hover\n     color #333\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  get css() {\n    const hakonParser = this.root.hakonParser\n    return new hakonParser(this.hakon).compile()\n  }\n  compile() {\n   const file = this.parent.file\n   const { SVGS, linkToPrevious, linkToNext } = file\n   let previousButton = \"\"\n   if (linkToPrevious)\n    previousButton = `a <\n    style left:3px;\n    href ${linkToPrevious}`\n   let nextButton = \"\"\n   if (linkToNext)\n    nextButton = `a >\n    style right:3px;\n    href ${linkToNext}`\n   return `<style>${this.css}</style>` + file.compileStumpCode(`div\n   class pageHeader doNotPrint\n   ${previousButton}\n   a ${SVGS.home}\n    style text-align:left;left:25px;\n    href ${file.get(\"homeLink\") || \"index.html\"}\n   a ${SVGS.git}\n    style text-align:right;right: 25px;\n    href ${file.git}\n   ${nextButton}`)\n  }\ngazetteHeaderParser\n extends pageHeaderParser\n description DEPRECATED! Use \"pageHeader\" instead.\nendSnippetParser\n description Insert one of these where you want to cut the file for a snippet.\n extends abstractTopLevelSingleMetaParser\nviewSourceUrlParser\n catchAllCellType urlCell\n description Use this to override the link to the source code for a scroll file.\n extends abstractTopLevelSingleMetaParser\nabstractFileSettingParser\n extends abstractScrollParser\n cells keywordCell\n javascript\n  compile() {\n   return \"\"\n  }\nabstractUrlSettingParser\n extends abstractFileSettingParser\n cells keywordCell urlCell\n cruxFromId\nbaseUrlParser\n description Root url of this published site on the web. Must be provided for RSS Feeds and OpenGraph tags to work, but has no effect locally.\n extends abstractUrlSettingParser\nhomeLinkParser\n description In the default Scroll theme the home button will link to \"index.html\". You can override this with this setting.\n extends abstractUrlSettingParser\nviewSourceBaseUrlParser\n description The base link to be used to generate the \"View source\" link.\n extends abstractUrlSettingParser\ngitParser\n description A link to the web Git UI for this site.\n extends abstractUrlSettingParser\ncanonicalLinkParser\n description Canonical URL for SEO. If undefined Scroll generates this from the baseUrl and permalink.\n extends abstractUrlSettingParser\nopenGraphImageParser\n description URL for Open Graph Image. https://ogp.me/. If not defined, Scroll will try to generate it's own using the first image tag on your page.\n extends abstractUrlSettingParser\nrssFeedUrlParser\n description URL for RSS feed, if any.\n extends abstractUrlSettingParser\nabstractSiteStringSettingParser\n extends abstractFileSettingParser\n catchAllCellType stringCell\n cruxFromId\nemailParser\n description Email address for the site owner.\n extends abstractFileSettingParser\n cruxFromId\n cells keywordCell emailAddressCell\nscrollParserDefinitionParser\n extends abstractScrollParser\n // todo Figure out best pattern for integrating Scroll and Grammar?\n pattern ^[a-zA-Z0-9_]+Parser$\n description Define your own parsers in the Grammar language for using in your Scroll files.\n baseParser blobParser\n javascript\n  compile() {\n   return \"\"\n  }\nhtmlParser\n description A catch all block to drop in any loose html. Use for HTML one liners and/or blocks of HTML.\n cruxFromId\n extends abstractScrollParser\n catchAllParser htmlLineParser\n catchAllCellType htmlAnyCell\n javascript\n  compile() {\n   return `${this.content ?? \"\"}${this.childrenToString()}`\n  }\nquickHtmlParser\n extends htmlParser\n cells htmlAnyCell\n pattern ^<\n description Start a line with a less than sign to immediately write HTML\n javascript\n  compile() {\n   return `${this.getLine() ?? \"\"}${this.childrenToString()}`\n  }\nstumpParser\n cruxFromId\n extends abstractScrollParser\n description Stump is a Tree Language that compiles to HTML.\n catchAllParser stumpContentParser\n javascript\n  compile() {\n   const file = this.parent.file\n   return file.compileStumpCode(this.childrenToString())\n  }\nstumpNoSnippetParser\n extends stumpParser\n description Useful for headers and footers when you have something you don't want included in snippets.\n cruxFromId\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\nabstractCaptionedParser\n extends abstractScrollParser\n cells keywordCell urlCell\n inScope captionAftertextParser slashCommentParser\n cruxFromId\n javascript\n  compile(compileSettings) {\n   const caption = this.getNode(\"caption\")\n   const captionFig = caption ? `<figcaption>${caption.compile()}</figcaption>` : \"\"\n   return `<figure class=\"scrollCaptionedFigure\">${this.getFigureContent(compileSettings)}${captionFig}</figure>`\n  }\nimageParser\n description An img tag.\n extends abstractCaptionedParser\n inScope classMarkupParser aftertextIdParser\n javascript\n  getFigureContent(compileSettings) {\n   const file = this.root.file\n   const src = this.getWord(1)\n   const linkRelativeToCompileTarget = (compileSettings ? (compileSettings.relativePath ?? \"\") : \"\") + src\n   let dimensionAttributes = \"\"\n   // If its a local image, get the dimensions and put them in the HTML\n   // to avoid flicker\n   if (!src.startsWith(\"http:\") && !src.startsWith(\"https:\")) {\n    try {\n     const sizeOf = require(\"image-size\")\n     const path = require(\"path\")\n     const fullImagePath = path.join(file.folderPath, src)\n     const dimensions = sizeOf(fullImagePath)\n     const width = dimensions.width\n     const height = dimensions.height\n     dimensionAttributes = `width=\"${width}\" height=\"${height}\" `\n    } catch (err) {\n     console.error(err)\n    }\n   }\n   const className = this.has(\"class\") ? ` class=\"${this.get(\"class\")}\" ` : \"\"\n   const id = this.has(\"id\") ? ` id=\"${this.get(\"id\")}\" ` : \"\"\n   return `<a href=\"${linkRelativeToCompileTarget}\" target=\"_blank\" ${className} ${id}><img src=\"${linkRelativeToCompileTarget}\" ${dimensionAttributes}loading=\"lazy\"></a>`\n  }\nyouTubeParser\n extends abstractCaptionedParser\n description Embed a YouTube video. Include the YouTube embed URL such as https://www.youtube.com/embed/CYPYZnVQoLg\n javascript\n  getFigureContent() {\n   const url = this.getWord(1).replace(\"youtube.com/watch?v=\", \"youtube.com/embed/\")\n   return `<div class=\"scrollYouTubeHolder\"><iframe class=\"scrollYouTubeEmbed\" src=\"${url}\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></div>`\n  }\nimportParser\n description Import one file into another.\n cruxFromId\n extends abstractScrollParser\n catchAllCellType filePathCell\n javascript\n  compile() {\n   return \"\"\n  }\n example\n  import header.scroll\nimportOnlyParser\n description Mark a file as not one to build. This line will be not be imported into the importing file.\n cruxFromId\n extends abstractScrollParser\n javascript\n  compile() {\n   return \"\"\n  }\nkeyboardNavParser\n description Makes left go to previous file and right go to next file.\n extends abstractScrollParser\n cruxFromId\n catchAllCellType urlCell\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n   const file = this.root.file\n   const linkToPrevious = this.getWord(1) ?? file.linkToPrevious\n   const linkToNext = this.getWord(2) ?? file.linkToNext\n   const script = `<script>document.addEventListener('keydown', function(event) {\n    if (document.activeElement !== document.body) return\n    const getLinks = () => document.getElementsByClassName(\"scrollKeyboardNav\")[0].getElementsByTagName(\"a\")\n    if (event.key === \"ArrowLeft\")\n      getLinks()[0].click()\n    else if (event.key === \"ArrowRight\")\n      getLinks()[1].click()\n   });</script>`\n   return `<div class=\"scrollKeyboardNav\" style=\"display:none;\"><a href=\"${linkToPrevious}\">${linkToPrevious}</a> ¬∑ ${file.permalink} ¬∑ <a href=\"${linkToNext}\">${linkToNext}</a>${script}</div>`\n  }\nplainTextParser\n description Use for plain text one liners and/or blocks of plain text.\n cruxFromId\n extends abstractScrollParser\n catchAllParser plainTextLineParser\n catchAllCellType stringCell\n javascript\n  compile() {\n   return `${this.content ?? \"\"}${this.childrenToString()}`\n  }\nquoteParser\n cruxFromId\n description A blockquote.\n catchAllParser quoteLineParser\n extends abstractScrollParser\n javascript\n  compile() {\n   return `<blockquote class=\"scrollQuote\">${this.childrenToString()}</blockquote>`\n  }\nreadingListParser\n extends abstractScrollParser\n description Easily create a reading list with links, titles, and author names.\n cells keywordCell\n cruxFromId\n catchAllParser readingListItemParser\n example\n  readingList\n   https://example.com/similar by Author Name\n javascript\n  compile() {\n   return `<br><ul>${this.map(child => child.compile()).join(\"\\n\")}</ul>`\n  }\nredirectToParser\n description Prints an HTML redirect tag. In the future might also emit nginx config.\n extends abstractScrollParser\n cells keywordCell urlCell\n cruxFromId\n example\n  redirectTo https://scroll.pub/releaseNotes.html\n javascript\n  compile() {\n   return `<meta http-equiv=\"Refresh\" content=\"0; url='${this.getWord(1)}'\" />`\n  }\nreplaceParser\n description Define a variable token and replacement that will be applied to all lines before and after this one.\n extends abstractScrollParser\n cruxFromId\n catchAllCellType stringCell\n baseParser blobParser\n example\n  replace YEAR 2022\n javascript\n  compile() {\n   return \"\"\n  }\nreplaceJsParser\n description Define a variable token and replacement that will be applied to all lines before and after this one.\n extends replaceParser\n catchAllCellType javascriptCell\n example\n  replaceJs SUM 1+1\n  * 1+1 = SUM\nnodejsParser\n description Write nodejs code inside a Scroll file. Sort of like PHP.\n extends abstractScrollParser\n cruxFromId\n catchAllCellType javascriptCell\n baseParser blobParser\n example\n  nodejs\n   module.exports = {SCORE : 1 + 2}\n  * The score is SCORE\nreplaceDefaultParser\n description Define the default value for a replacement. Useful if you want to import a file and set a replacement later.\n extends abstractScrollParser\n catchAllCellType stringCell\n baseParser blobParser\n example\n  replaceDefault YEAR 2021\n cruxFromId\n javascript\n  compile() {\n   return \"\"\n  }\nabstractTableParser\n cruxFromId\n catchAllParser rowParser\n extends abstractScrollParser\n javascript\n  get tableHeader() {\n   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\\n`)\n  }\n  get columnNames() {\n   const header = this.nodeAt(0)\n   return header ? header.getLine().split(this.delimiter) : []\n  }\n  get columns() {\n   const cols = this.columnNames\n   return cols.map((name, index) => {\n    const isLink = name.endsWith(\"Link\")\n    const linkIndex = cols.indexOf(name + \"Link\")\n    return {\n     name,\n     isLink,\n     linkIndex\n    }\n   })\n  }\n  get tableBody() {\n   const { delimiter } = this\n   return this.topDownArray\n    .slice(1)\n    .map(node => `<tr>${node.toRow(this.columns, delimiter)}</tr>`)\n    .join(\"\\n\")\n  }\n  compile() {\n   return `<table class=\"scrollTable\"><thead><tr>${this.tableHeader.join(\"\\n\")}</tr></thead>\\n<tbody>${this.tableBody}</tbody></table>`\n  }\ntableParser\n description A table with a custom delimiter.\n extends abstractTableParser\n catchAllCellType anyCell\n javascript\n  get delimiter() {\n   return this.content ?? \"\"\n  }\ncommaTableParser\n description Comma separated values table.\n extends abstractTableParser\n string delimiter ,\npipeTableParser\n description Pipe separated values table.\n extends abstractTableParser\n string delimiter |\nspaceTableParser\n description Space separated values table. Last column is a catch all.\n extends abstractTableParser\n string delimiter  \ntabTableParser\n description Tab separated values table.\n extends abstractTableParser\n string delimiter \\t\ntreeTableParser\n description A table of data written in Tree Notation form. Useful when a column contains a text blob.\n extends abstractTableParser\n catchAllParser treeRowParser\n javascript\n  get columnNames() {\n   return this._getUnionNames()\n  }\n  get tableBody() {\n   return this.map(node => `<tr>${node.toRow(this.columns)}</tr>`).join(\"\\n\")\n  }\n example\n  treeTable\n   row\n    name Javascript\n    example\n     console.log(\"Hello world\")\n   row\n    name Python\n    example\n     print \"Hello world\"\nabstractAftertextAttributeParser\n cells keywordCell\n boolean isAttribute true\n javascript\n  get divAttributes() {\n   return `${this.firstWord}=\"${this.content}\"`\n  }\n  compile() {\n   return \"\"\n  }\naftertextIdParser\n crux id\n description Provide an ID to be output in the generated HTML tag.\n extends abstractAftertextAttributeParser\n cells keywordCell htmlIdCell\n single\naftertextStyleParser\n crux style\n description Provide code for the generated HTML tag's \"style\" attribute.\n extends abstractAftertextAttributeParser\n cells keywordCell\n catchAllCellType cssAnyCell\naftertextHiddenParser\n crux hidden\n cells keywordCell\n description Do not compile this node to HTML.\n extends abstractAftertextAttributeParser\n single\naftertextTagParser\n cells keywordCell htmlTagCell\n description Override the HTML tag that the compiled node will use.\n crux tag\n javascript\n  compile() {\n   return \"\"\n  }\nabstractAftertextDirectiveParser\n cells keywordCell\n catchAllCellType stringCell\n javascript\n  isMarkup = true\n  compile() {\n   return \"\"\n  }\n  get pattern() {\n   return this.getWordsFrom(1).join(\" \")\n  }\n  get shouldMatchAll() {\n   return this.has(\"matchAll\")\n  }\n  getMatches(text) {\n   const { pattern } = this\n   const escapedPattern = pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\")\n   return [...text.matchAll(new RegExp(escapedPattern, \"g\"))].map(match => {\n    const { index } = match\n    const endIndex = index + pattern.length\n    return [\n     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },\n     { index: endIndex, endIndex, string: `</${this.closeTag}>` }\n    ]\n   })\n  }\n  getInserts(text) {\n   const matches = this.getMatches(text)\n   if (!matches.length) return false\n   if (this.shouldMatchAll) return matches.flat()\n   const match = this.getNode(\"match\")\n   if (match)\n    return match.indexes\n     .map(index => matches[index])\n     .filter(i => i)\n     .flat()\n   return matches[0]\n  }\n  get allAttributes() {\n   const attr = this.attributes.join(\" \")\n   return attr ? \" \" + attr : \"\"\n  }\n  get attributes() {\n   return []\n  }\n  get openTag() {\n   return this.tag\n  }\n  get closeTag() {\n   return this.tag\n  }\nabstractMarkupParser\n extends abstractAftertextDirectiveParser\n inScope abstractMarkupParameterParser\nboldParser\n cruxFromId\n description Bold the matching text.\n extends abstractMarkupParser\n javascript\n  tag = \"b\"\nitalicsParser\n cruxFromId\n description Italicize the matching text.\n extends abstractMarkupParser\n javascript\n  tag = \"i\"\nunderlineParser\n description Underline the matching text.\n cruxFromId\n extends abstractMarkupParser\n javascript\n  tag = \"u\"\naftertextCodeParser\n description Wrap the matching text in a <code> span.\n crux code\n extends abstractMarkupParser\n javascript\n  tag = \"code\"\nlinkParser\n extends abstractMarkupParser\n description Put the matching text in an <a> tag.\n cells keywordCell urlCell\n inScope linkTitleParser linkTargetParser commentParser\n programParser\n  description Anything here will be URI encoded and then appended to the link.\n  cruxFromId\n  cells keywordCell\n  catchAllParser programLinkParser\n  javascript\n   get encoded() {\n    return encodeURIComponent(this.childrenToString())\n   }\n cruxFromId\n javascript\n  tag = \"a\"\n  get link() {\n   const {baseLink} = this\n   if (this.has(\"program\"))\n     return baseLink + this.getNode(\"program\").encoded\n   return baseLink\n  }\n  get baseLink() {\n   const link = this.getWord(1)\n   const isAbsoluteLink = link.includes(\"://\")\n   if (isAbsoluteLink) return link\n   const relativePath = this.parent.compileSettings?.relativePath || \"\"\n   return relativePath + link\n  }\n  get attributes() {\n   const attrs = [`href=\"${this.link}\"`]\n   const options = [\"title\", \"target\"]\n   options.forEach(option => {\n    const node = this.getNode(option)\n    if (node) attrs.push(`${option}=\"${node.content}\"`)\n   })\n   return attrs\n  }\n  patternStartsAtWord = 2\n  get pattern() {\n   // If no pattern is provided, apply to the *entire* content.\n   const words = this.getWordsFrom(this.patternStartsAtWord)\n   return words.length ? words.join(\" \") : this.parent.originalText\n  }\nemailLinkParser\n description A mailto link\n crux email\n extends linkParser\n javascript\n  get attributes() {\n   return [`href=\"mailto:${this.link}\"`]\n  }\nquickLinkParser\n pattern ^https?\\:\n extends linkParser\n cells urlCell\n javascript\n  get link() {\n   return this.firstWord\n  }\n  patternStartsAtWord = 1\nclassMarkupParser\n description Add a custom class to the parent element instead. If matching text provided, a span with the class will be added around the matching text.\n extends abstractMarkupParser\n cells keywordCell classNameCell\n crux class\n javascript\n  tag = \"span\"\n  get applyToParentElement() {\n   return this.words.length === 2\n  }\n  getInserts(text) {\n   // If no select text is added, set the class on the parent element.\n   if (this.applyToParentElement) return []\n   return super.getInserts(text)\n  }\n  get className() {\n   return this.getWord(1)\n  }\n  get attributes() {\n   return [`class=\"${this.className}\"`]\n  }\n  get pattern() {\n   const words = this.getWordsFrom(2)\n   return words.length ? words.join(\" \") : this.parent.content\n  }\nhoverNoteParser\n description Add a caveat viewable on hover on matching text. When you want to be sure you've thoroughly addressed obvious concerns but ones that don't warrant to distract from the main argument of the text.\n cruxFromId\n extends classMarkupParser\n catchAllParser lineOfTextParser\n cells keywordCell\n javascript\n  get pattern() {\n   return this.getWordsFrom(1).join(\" \")\n  }\n  get attributes() {\n   return [`class=\"scrollHoverNote\"`, `title=\"${this.hoverNoteText}\"`]\n  }\n  get hoverNoteText() {\n   return this.childrenToString().replace(/\\n/g, \" \")\n  }\nstrikethroughParser\n cruxFromId\n extends abstractMarkupParser\n javascript\n  tag = \"s\"\nlinkifyParser\n description Use this to disable linkify on the text.\n extends abstractAftertextDirectiveParser\n cruxFromId\n cells keywordCell booleanCell\nwrapsOnParser\n cruxFromId\n description Enable `code`, *bold*, and _italics_ rules.\n extends abstractAftertextDirectiveParser\n catchAllCellType wrapNameCell\n javascript\n  get shouldMatchAll() {\n   return true\n  }\n  get wraps() {\n    const wraps = [{delimiter: \"`\", tag: \"code\", exclusive: true, name: \"code\"},{delimiter: \"*\", tag: \"strong\", name: \"bold\"}, {delimiter: \"_\", tag: \"em\", name: \"italics\"}]\n    if (this.root.has(\"katex\"))\n      wraps.unshift({delimiter: \"$\", tag: \"span\", attributes: ' class=\"scrollKatex\"', exclusive: true, name: \"katex\"})\n    if (this.content)\n      return wraps.filter(wrap => this.content.includes(wrap.name))\n    return wraps\n  }\n  getMatches(text) {\n   const exclusives = []\n   return this.wraps.map(wrap => this.runPattern(text, wrap, exclusives)).filter(i => i).flat()\n  }\n  runPattern(text, wrap, exclusives = []) {\n   const {delimiter, tag, attributes} = wrap\n   const escapedDelimiter = delimiter.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\")\n   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, \"g\")\n   const delimiterLength = delimiter.length\n   return [...text.matchAll(pattern)].map(match => {\n    const { index } = match\n    const endIndex = index + match[0].length\n    // I'm too lazy to clean up Grammar to write a proper inline markup parser so doing this for now.\n    // The exclusive idea is to not try and apply bold or italic styles inside a TeX or code inline style.\n    // Note that the way this is currently implemented any TeX in an inline code will get rendered, but code\n    // inline of TeX will not. Seems like an okay tradeoff until a proper refactor and cleanup can be done.\n    if (exclusives.some(exclusive => index >= exclusive[0] && index <= exclusive[1]))\n      return undefined\n    if (wrap.exclusive)\n      exclusives.push([index, endIndex])\n    return [\n     { index, string: `<${tag + (attributes ? \" \" + attributes : \"\")}>`, endIndex, consumeStartCharacters: delimiterLength },\n     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }\n    ]\n   }).filter(i => i)\n  }\nwrapParser\n cruxFromId\n cells keywordCell delimiterCell tagOrUrlCell\n catchAllCellType htmlAttributesCell\n extends wrapsOnParser\n description Define a custom wrap, for example \"wrap _ em\" would support: _italics_.\n javascript\n  getMatches(text) {\n   try {\n    const delimiter = this.getWord(1)\n    const tag = this.getWord(2)\n    const attributes = this.getWordsFrom(3).join(\" \")\n    if (tag.startsWith(\"https:\")) return this.runPattern(text, {delimiter, tag: \"a\", attributes: `href=\"${tag}\"` + attributes})\n    return this.runPattern(text, {delimiter, tag, attributes})\n   } catch (err) {\n    console.error(err)\n    return []\n   }\n   // Note: doubling up doesn't work because of the consumption characters.\n  }\ndatelineParser\n cruxFromId\n description Gives your paragraph a dateline like \"December 15, 2021 ‚Äî The...\"\n extends abstractAftertextDirectiveParser\n javascript\n  getInserts() {\n   let day = this.content || this.root.get(\"date\")\n   if (!day) return false\n   try {\n    const dayjs = require(\"dayjs\")\n    day = dayjs(day).format(`MMMM D, YYYY`)\n   } catch (err) {\n    console.error(err)\n   }\n   return [{ index: 0, string: `<span class=\"scrollDateline\">${day} ‚Äî </span>` }]\n  }\ndayjsParser\n description Advanced directive that evals some Javascript code in an environment including \"dayjs\".\n cruxFromId\n extends abstractAftertextDirectiveParser\n javascript\n  getInserts() {\n   const dayjs = require(\"dayjs\")\n   const days = eval(this.content)\n   const index = this.parent.originalTextPostLinkify.indexOf(\"days\")\n   return [{ index, string: `${days} ` }]\n  }\nabstractMarkupParameterParser\n cells keywordCell\n cruxFromId\nmatchAllParser\n description Use this to match all occurrences of the text.\n extends abstractMarkupParameterParser\nmatchParser\n catchAllCellType integerCell\n description Use this to specify which index(es) to match.\n javascript\n  get indexes() {\n   return this.getWordsFrom(1).map(num => parseInt(num))\n  }\n example\n  aftertext\n   hello ello ello\n   bold ello\n    match 0 2\n extends abstractMarkupParameterParser\nabstractHtmlAttributeParser\n javascript\n  compile() {\n   return \"\"\n  }\nlinkTargetParser\n extends abstractHtmlAttributeParser\n description If you want to set the target of the link. To \"_blank\", for example.\n crux target\n cells keywordCell anyCell\nlinkTitleParser\n description If you want to set the title of the link.\n crux title\n cells keywordCell\n catchAllCellType anyCell\n example\n  * This report showed the treatment had a big impact.\n   https://example.com/report This report.\n    title The average growth in the treatment group was 14.2x higher than the control group.\nprogramLinkParser\n catchAllCellType codeCell\nblankLineParser\n description Blank lines compile to nothing in the HTML.\n cells blankCell\n javascript\n  compile() {\n   return this.parent.clearSectionStack()\n  }\n pattern ^$\n tags doNotSynthesize\nerrorParser\n baseParser errorParser\nchatLineParser\n catchAllCellType anyCell\n catchAllParser chatLineParser\nlineOfCodeParser\n catchAllCellType codeCell\n catchAllParser lineOfCodeParser\ncommentLineParser\n catchAllCellType commentCell\ncssLineParser\n catchAllCellType cssAnyCell\n catchAllParser cssLineParser\nlineOfTextParser\n catchAllCellType stringCell\n boolean isTextParser true\nhtmlLineParser\n catchAllCellType htmlAnyCell\n catchAllParser htmlLineParser\nstumpContentParser\n catchAllCellType anyCell\nabstractLoopConfigParser\n cells keywordCell\n cruxFromId\n catchAllCellType stringCell\nabstractItemsProviderParser\n cells keywordCell\nloopLinesParser\n crux lines\n extends abstractItemsProviderParser\n description Iterate over the provided lines.\n catchAllParser loopLineParser\n loopLineParser\n  catchAllCellType stringCell\n javascript\n  get items() {\n   return this.map(node => node.asString)\n  }\nloopWordsParser\n crux words\n extends abstractItemsProviderParser\n catchAllCellType stringCell\n description Iterate over the provided words.\n javascript\n  get items() {\n   return this.getWordsFrom(1)\n  }\nloopGroupsParser\n crux groups\n extends abstractItemsProviderParser\n catchAllCellType groupNameWithOptionalFolderCell\n description Set this to iterate over scroll files in a folder. Provide both the folder and group name like this: [folder]/[groupName]\n javascript\n  get items() {\n   return this.root.file.getFilesInGroupsForEmbedding(this.getWordsFrom(1))\n  }\nabstractPointConfigParser\n // todo: scoped parsers should support abstract types\n cruxFromId\n cells keywordCell\n catchAllCellType stringCell\n single\nlatParser\n cells keywordCell floatCell\n cruxFromId\n single\nlongParser\n cells keywordCell floatCell\n cruxFromId\n single\nplainTextLineParser\n catchAllCellType stringCell\n catchAllParser plainTextLineParser\nquoteLineParser\n catchAllCellType anyCell\n catchAllParser quoteLineParser\nreadingListItemParser\n cells urlCell\n catchAllCellType stringCell\n javascript\n  compile() {\n   const url = this.firstWord\n   const [title, author] = this.content.split(\" by \")\n   return `<li><a href=\"${url}\">${title ?? url}</a>${author ? ` by ${author}` : \"\"}</li>`\n  }\nscrollParser\n extensions scroll\n description Tools for thought thats compile to HTML.\n root\n inScope abstractScrollParser blankLineParser\n catchAllParser catchAllParagraphParser\n compilesTo html\n javascript\n  setFile(file) {\n   this.file = file\n   return this\n  }\n  compile(compileSettings) {\n    this.sectionStack = []\n    return this.map(child => child.compile(compileSettings)).filter(i => i).join(\"\\n\") + this.clearSectionStack()\n  }\n  sectionStack = []\n  clearSectionStack() {\n   const result = this.sectionStack.join(\"\")\n   this.sectionStack = []\n   return result\n  }\n  get hakonParser() {\n    if (this.isNodeJs())\n      return require(\"jtree/products/hakon.nodejs.js\")\n    return hakonParser\n  }\n  alreadyRequired = new Set()\n  compileEmbeddedVersion(compileSettings) {\n   this.sectionStack = []\n   return this.map(child => (child.compileEmbeddedVersion ? child.compileEmbeddedVersion(compileSettings) : child.compile(compileSettings)))\n     .filter(i => i)\n     .join(\"\\n\")\n     .trim() + this.clearSectionStack()\n  }\n  get footnotes() {\n   if (this._footnotes === undefined) this._footnotes = this.filter(node => node.isFootnote)\n   return this._footnotes\n  }\n  file = {}\n  get permalink() {\n   return this.get(\"permalink\") || this.file.permalink || \"\"\n  }\n example\n  # Hello world\n  ## This is Scroll\n  * It compiles to HTML.\n  \n  code\n   // You can add code as well.\n   print(\"Hello world\")\nrowParser\n catchAllCellType stringCell\n javascript\n  toRow(columns, delimiter) {\n   const words = this.getLine().split(delimiter)\n   let str = \"\"\n   let column = 0\n   const columnCount = columns.length\n   while (column < columnCount) {\n    const col = columns[column]\n    column++\n    const content = (columnCount === column ? words.slice(columnCount - 1).join(\" \") : words[column - 1]) ?? \"\"\n    if (col.isLink) continue\n    let tagged = content\n    const link = words[col.linkIndex]\n    if (col.linkIndex > -1 && link) tagged = `<a href=\"${link}\">${content}</a>`\n    else if (content.match(/^https?\\:[^ ]+$/)) tagged = `<a href=\"${content}\">${content}</a>`\n    str += `<td>${tagged}</td>\\n`\n   }\n   return str\n  }\ntagsParser\n // Todo: there may be a bug with having scoped parsers in abstract classes not being available to child classes.\n cells keywordCell booleanCell\n cruxFromId\ntreeRowContentParser\n description Any blob content in a cell.\n cells stringCell\n catchAllCellType stringCell\ntreeRowColumnParser\n catchAllParser treeRowContentParser\n description A columnName value pair, or just a columnName if the value is a text blob.\n cells idCell\n catchAllCellType stringCell\ntreeRowParser\n cells idCell\n description The root node of a row.\n catchAllParser treeRowColumnParser\n javascript\n  toRow(columns) {\n   let str = \"\"\n   columns.forEach(col => {\n    const node = this.getNode(col.name)\n    if (col.isLink) return\n    if (!node) {\n     str += \"<td></td>\\n\"\n     return\n    }\n    const content = (node.length ? node.childrenToString() : node.content) ?? \"\"\n    let tagged = \"\"\n    const link = this.get(col.name + \"Link\")\n    if (col.linkIndex > -1 && link) tagged = `<a href=\"${link}\">${content}</a>`\n    else if (node.length) tagged = `<pre>${content}</pre>`\n    else tagged = content\n    str += `<td>${tagged}</td>\\n`\n   })\n   return str\n  }"}