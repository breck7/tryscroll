const AppConstants = {"grammar":"tooling\n Related work\n CSS is great for text selector ideas: https://www.w3schools.com/cssref/css_selectors.asp\n Roff has a lot of related markup ideas: https://www.systutorials.com/docs/linux/man/7-groff_man/\nanyCell\nurlCell\n highlightScope constant.language\nkeywordCell\n highlightScope keyword\nstringCell\n highlightScope string\nbooleanCell\n highlightScope constant.language\n enum true false\nidCell\n highlightScope constant.language\ndateCell\n highlightScope string\nintegerCell\n highlightScope constant.numeric\npermalinkCell\n highlightScope string\n description A string that doesn't contain characters that might interfere with most filesystems. No slashes, for instance.\ncommentCell\n highlightScope comment\nblankCell\npersonNameCell\n extends stringCell\ncodeCell\n highlightScope comment\nbulletPointCell\n description Any token used as a bullet point such as \"-\" or \"1.\" or \">\"\n highlightScope keyword\nemailAddressCell\n extends stringCell\ntagOrUrlCell\n description An HTML tag or a url.\n highlightScope constant.language\ndelimiterCell\n description String to use as a delimiter.\n highlightScope string\nhtmlAttributesCell\n highlightScope comment\nclassNameCell\n highlightScope constant\nhtmlIdCell\n extends idCell\nfilePathCell\n extends stringCell\ncssAnyCell\n extends anyCell\ngroupNameCell\n extends permalinkCell\ngroupNameWithOptionalFolderCell\n description A group name combined with a folder path. Only used when referencing groups, not in posts.\n extends stringCell\nhtmlAnyCell\n extends anyCell\njavascriptCell\n extends stringCell\nabstractScrollNode\n cells keywordCell\n javascript\n  compileSnippet() {\n   return this.compile()\n  }\nabstractAftertextNode\n description Text followed by markup commands.\n extends abstractScrollNode\n inScope abstractAftertextDirectiveNode abstractAftertextAttributeNode slashCommentNode\n example\n  aftertext\n   Hello brave new world\n   link home.com new\n   bold brave new\n   underline new world\n   strikethrough wor\n javascript\n  get markupInserts() {\n   const { originalTextPostLinkify } = this\n   return this.filter(node => node.isMarkupNode)\n    .map(node => node.getInserts(originalTextPostLinkify))\n    .filter(i => i)\n    .flat()\n  }\n  get originalText() {\n   return this.content ?? \"\"\n  }\n  get originalTextPostLinkify() {\n   const { originalText } = this\n   const shouldLinkify = this.get(\"linkify\") === \"false\" || originalText.includes(\"<a \") ? false : true\n   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText\n  }\n  replaceNotes(originalText) {\n   this.root.footnotes.forEach((note, index) => {\n    const needle = note.firstWord\n    if (originalText.includes(needle)) originalText = originalText.replace(needle, `<a href=\"#${note.anchorId}\" class=\"scrollNoteLink\" id=\"${note.linkBack()}\"><sup>${note.noteId}</sup></a>`)\n   })\n   return originalText\n  }\n  get text() {\n   const { originalTextPostLinkify, markupInserts } = this\n   let adjustment = 0\n   let newText = originalTextPostLinkify\n   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.\n   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))\n   markupInserts.forEach(insertion => {\n    insertion.index += adjustment\n    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0\n    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0\n    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)\n    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters\n   })\n   return newText\n  }\n  tag = \"p\"\n  get className() {\n    const classNode = this.getNode(\"class\")\n    if (classNode && classNode.applyToParentElement)\n      return classNode.content\n    return this.defaultClassName\n  }\n  defaultClassName = \"scrollParagraphComponent\"\n  compile() {\n   const { className } = this\n   const classAttr = className ? `class=\"${this.className}\"` : \"\"\n   return `<${this.tag} ${this.divAttributes}${classAttr}>${this.text}</${this.tag}>`\n  }\n  get divAttributes() {\n   const attrs = this.filter(node => node.isAttributeNode)\n   return attrs.length ? attrs.map(node => node.divAttributes).join(\" \") + \" \" : \"\"\n  }\nthoughtNode\n todo Perhaps rewrite this from scratch and move out of aftertext.\n extends abstractAftertextNode\n catchAllCellType stringCell\n example\n  * I had a _new_ thought.\n description A thought.\n crux *\n javascript\n  compile() {\n   // Hacky, I know.\n   const newLine = this.appendLine(\"wrapsOn\")\n   const compiled = super.compile()\n   newLine.destroy()\n   return compiled\n  }\nindentableThoughtNode\n extends thoughtNode\n inScope abstractAftertextDirectiveNode abstractAftertextAttributeNode indentableThoughtNode\n javascript\n  compile() {\n    return super.compile() + this.map(node => node.compile()).join(\"\\n\").trim()\n  }\nchecklistTodoNode\n extends indentableThoughtNode\n example\n  [] Get milk\n description An incomplete checklist item.\n crux []\n string checked \n javascript\n  get text() {\n   return `<div style=\"text-indent:${(this.getIndentLevel() - 1) * 20}px;\"><input type=\"checkbox\" ${this.checked} id=\"${this.id}\"><label for=\"${this.id}\">` + super.text + `</label></div>`\n  }\n  get id() {\n    return this.get(\"id\") || \"item\" + this._getUid()\n  }\nchecklistDoneNode\n extends checklistTodoNode\n description A complete checklist list item.\n string checked checked\n crux [x]\n example\n  [x] get milk\nlistAftertextNode\n extends indentableThoughtNode\n example\n  - I had a _new_ thought.\n description A list item.\n crux -\n javascript\n  defaultClassName = \"\"\n  compile() {\n   const index = this.getIndex()\n   const parent = this.parent\n   const nodeClass = this.constructor\n   const isStartOfList = index === 0 || !(parent.nodeAt(index - 1) instanceof nodeClass)\n   const isEndOfList = parent.length === index + 1 || !(parent.nodeAt(index + 1) instanceof nodeClass)\n   const { listType } = this\n   return (isStartOfList ? `<${listType} style=\"text-indent:${(this.getIndentLevel() - 1) * 20}px;\">` : \"\") + `${super.compile()}` + (isEndOfList ? `</${listType}>` : \"\")\n  }\n  tag = \"li\"\n  listType = \"ul\"\norderedListAftertextNode\n extends listAftertextNode\n description A list item.\n example\n  1. Hello world\n pattern ^\\d+\\. \n javascript\n  listType = \"ol\"\nblinkNode\n description Useful when you have a client that always needs to find 1 thing they would like you to change.\n extends thoughtNode\n crux blink\n javascript\n  compile() {\n   return `<span class=\"scrollBlink\">${super.compile()}</span>\n    <script>\n    setInterval(()=>{\n        Array.from(document.getElementsByClassName(\"scrollBlink\")).forEach(el => \n        el.style.color = el.style.color === \"white\" ? \"black\" : \"white\"\n        )\n    }, 2000)\n    </script>`\n  }\nfootnoteDefinitionNode\n description A footnote. Can also be used as section notes.\n extends thoughtNode\n boolean isFootnote true\n pattern ^\\^.+$\n javascript\n  get divAttributes() {\n   return super.divAttributes + ` id=\"${this.anchorId}\"`\n  }\n  get anchorId() {\n   return `note${this.noteIndex}`\n  }\n  get noteId() {\n   // In the future we could allow common practices like author name\n   return this.noteIndex\n  }\n  linkBack() {\n   return `noteUsage${this.noteIndex}`\n  }\n  get text() {\n   return `<a class=\"scrollNoteIndex\" href=\"#noteUsage${this.noteIndex}\">${this.noteIndex}</a> ${super.text}`\n  }\n  get noteIndex() {\n   return this.parent.footnotes.indexOf(this) + 1\n  }\ncaptionAftertextNode\n description An optional caption to accompany the resource.\n crux caption\n extends thoughtNode\nsectionTitleNode\n description Compiles to an html h3 tag.\n extends thoughtNode\n crux #\n javascript\n  compile() {\n   this.parent.stack.push(\"</div>\")\n   return `<div class=\"scrollSectionComponent\">` + super.compile()\n  }\n  tag = \"h3\"\ntitleNode\n description Title of the page for meta tags and also compiles to an html h1 tag.\n extends sectionTitleNode\n crux title\n javascript\n  compile() {\n   // Hacky, I know.\n   const { permalink } = this.parent.file\n   if (!permalink) return super.compile()\n   const newLine = this.appendLine(`link ${permalink}`)\n   const compiled = super.compile()\n   newLine.destroy()\n   return compiled\n  }\n  defaultClassName = \"scrollTitleComponent\"\n  tag = \"h1\"\nsectionSubTitleNode\n description Compiles to an html h4 tag.\n extends sectionTitleNode\n crux ##\n javascript\n  tag = \"h4\"\nquestionAftertextNode\n description A question.\n extends sectionTitleNode\n crux ?\n javascript\n  tag = \"h4\"\n  defaultClassName = \"scrollQuestionComponent\"\nstartColumnsNode\n extends abstractAftertextNode\n cruxFromId\n catchAllCellType integerCell\n description Start a multicolumn grid.\n javascript\n  compileSnippet() {\n   return \"\"\n  }\n  compile() {\n   const columnWidth = 35\n   const COLUMN_GAP = 20\n   const maxColumns = parseInt(this.getWord(1) ?? 10)\n   const maxTotalWidth = maxColumns * columnWidth + (maxColumns - 1) * COLUMN_GAP\n   return this.parent.clearStack() + `<div class=\"scrollColumnsComponent\" style=\"column-width:${columnWidth}ch;column-count:${maxColumns};max-width:${maxTotalWidth}ch;\">`\n  }\nendColumnsNode\n extends abstractAftertextNode\n cruxFromId\n description End a multicolumn grid.\n javascript\n  compile() {\n   return \"</div>\"\n  }\n  compileSnippet() {\n   return \"\"\n  }\nscrollCssTagNode\n extends abstractAftertextNode\n cruxFromId\n description Prints the Scroll CSS in an <style> tag. To not print the style tag use `scrollCss`.\n javascript\n  compile() {\n   return `<style>${this.parent.file.SCROLL_CSS}</style>`\n  }\n  compileSnippet() {\n   return \"\"\n  }\nscrollCssNode\n extends scrollCssTagNode\n javascript\n  compile() {\n   return this.parent.file.SCROLL_CSS\n  }\nscrollFooterNode\n extends abstractAftertextNode\n cruxFromId\n javascript\n  compileSnippet() {\n   return \"\"\n  }\n  compile() {\n   const file = this.parent.file\n   const { SVGS, SCROLL_VERSION, viewSourceUrl } = file\n   const closeContainerTag = \"</div>\"\n   return (\n    closeContainerTag +\n    file.compileStumpCode(`p\n   class scrollFileViewSourceUrlComponent doNotPrint\n   a View source\n    href ${viewSourceUrl}\n  div\n   class scrollFooterComponent doNotPrint\n   a ${SVGS.email}\n    href mailto:${file.email}\n   a ${SVGS.git}\n    href ${file.git}\n   a Built with Scroll v${SCROLL_VERSION}\n    href https://scroll.pub\n    class scrollCommunityLinkComponent`)\n   )\n  }\nscrollHeaderNode\n extends abstractAftertextNode\n cruxFromId\n description The simple default Scroll header.\n javascript\n  compileSnippet() {\n   return \"\"\n  }\n  compile() {\n   const file = this.parent.file\n   const { SVGS, linkToPrevious, linkToNext } = file\n   let previousButton = \"\"\n   if (linkToPrevious)\n    previousButton = `a <\n    class scrollPrevPageLink\n    href ${linkToPrevious}`\n   let nextButton = \"\"\n   if (linkToNext)\n    nextButton = `a >\n    class scrollNextPageLink\n    href ${linkToNext}`\n   return file.compileStumpCode(`div\n   class scrollHeaderComponent doNotPrint\n   ${previousButton}\n   a ${SVGS.home}\n    class scrollTopLeftBarComponent\n    href ${file.get(\"homeLink\") || \"index.html\"}\n   a ${SVGS.git}\n    class scrollTopRightBarComponent\n    href ${file.git}\n   ${nextButton}`)\n  }\nhorizontalRuleNode\n crux ---\n description Prints an html <hr> tag\n extends abstractAftertextNode\n javascript\n  compile() {\n   return `<hr>`\n  }\nloremIpsumNode\n extends abstractAftertextNode\n cruxFromId\n description Generate dummy text.\n catchAllCellType integerCell\n javascript\n  compile() {\n   const text = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`\n   return text.repeat(this.getWord(1) ? parseInt(this.getWord(1)) : 1)\n  }\nsnippetsNode\n extends abstractAftertextNode\n cruxFromId\n cells keywordCell groupNameWithOptionalFolderCell\n catchAllCellType groupNameWithOptionalFolderCell\n description Prints the snippets of all files in a folder that are in the named group.\n example\n  snippets index\n javascript\n  methodForGettingHtml = \"getHtmlCodeForSnippetsPage\"\n  makeSnippet(file) {\n   const snippet = new TreeNode(`div\n   class scrollSnippetContainerComponent`)\n   const div = snippet.getNode(\"div\")\n   div.appendLineAndChildren(\"bern\", file[this.methodForGettingHtml]())\n   return snippet.toString().replace(/\\n/g, \"\\n \")\n  }\n  compile() {\n   const file = this.parent.file\n   const files = file.folder.getFilesInGroups(this.getWordsFrom(1))\n   const snippets = files.map(file => this.makeSnippet(file)).join(this.delimiter)\n   const code = `div\n   class scrollColumnsComponent\n   style column-width:35ch;\n   ${snippets}`\n   return file.compileStumpCode(code)\n  }\n  delimiter = \"\\n \"\nfullSnippetsNode\n extends snippetsNode\n cruxFromId\n description Prints the full contents of files in a folder that are in the named group.\n javascript\n  methodForGettingHtml = \"getCompiledSnippet\"\nloopNode\n extends abstractAftertextNode\n cells keywordCell\n description Iterate over files, lines or words, evaluating code and joining the resulting HTML.\n cruxFromId\n inScope abstractLoopConfigNode\n javascript\n  compile() {\n   const code = this.get(\"javascript\")\n   const joinWith = this.get(\"join\") ?? \"\"\n   try {\n    const limit = this.get(\"limit\")\n    let items = this.items\n    if (limit)\n      items = items.slice(0, parseInt(limit))\n    return items.map((item, index) => eval(code)).join(joinWith)\n   } catch (err) {\n    console.error(err)\n    return \"\"\n   }\n  }\n  get items() {\n   const provider = this.getChildInstancesOfNodeTypeId(\"abstractItemsProviderNode\")[0]\n   return provider ? provider.items : []\n  }\nviewSourceNode\n extends abstractAftertextNode\n cruxFromId\n javascript\n  compileSnippet() {\n   return \"\"\n  }\n  compile() {\n   const file = this.parent.file\n   const { viewSourceUrl } = file\n   return file.compileStumpCode(`p\n   class scrollFileViewSourceUrlComponent doNotPrint\n   a View source\n    href ${viewSourceUrl}`)\n  }\nauthorNode\n description Prints an author byline with an optional link to a page for the author.\n extends abstractScrollNode\n cruxFromId\n cells keywordCell urlCell\n catchAllCellType personNameCell\n example\n  comment With Link:\n  author https://breckyunits.com Breck Yunits\n  comment No link:\n  author  Breck Yunits\n javascript\n  compile() {\n   const link = this.getWord(1)\n   return `<div class=\"scrollAuthor\">by <a ${link ? `href=\"${link}\"` : \"\"}>${this.getWordsFrom(2).join(\" \")}</a></div>`\n  }\nchatNode\n description A dialogue between two people.\n catchAllNodeType chatLineNode\n cruxFromId\n extends abstractScrollNode\n javascript\n  compile() {\n   return this.map((line, index) => `<div class=\"scrollDialogueComponent ${index % 2 ? \"scrollDialogueComponentRight\" : \"scrollDialogueComponentLeft\"}\"><span>${line.toString()}</span></div>`).join(\"\")\n  }\ncodeNode\n description A code block.\n catchAllNodeType lineOfCodeNode\n extends abstractScrollNode\n javascript\n  compile() {\n   return `<code class=\"scrollCodeBlockComponent\">${this.childrenToString().replace(/\\</g, \"&lt;\")}</code>`\n  }\n cruxFromId\ncodeWithLanguageNode\n description Use this to specify the language of the code block, such as csvCode or rustCode.\n extends codeNode\n pattern ^[a-zA-Z0-9_]+Code$\nbelowAsCodeNode\n description Print the Scroll code of the next node.\n extends abstractScrollNode\n catchAllCellType integerCell\n cruxFromId\n javascript\n  method = \"getNext\"\n  get code() {\n   const { method } = this\n   let code = \"\"\n   let howMany = parseInt(this.getWord(1))\n   if (!howMany || isNaN(howMany)) howMany = 1\n   let nodes = []\n   let next = this[method]()\n   while (howMany) {\n    nodes.push(next)\n    next = next[method]()\n    howMany--\n   }\n   if (this.reverseNodes) nodes.reverse()\n   return nodes.map(node => node.toString()).join(\"\\n\")\n  }\n  reverseNodes = false\n  compile() {\n   return `<code class=\"scrollCodeBlockComponent\">${this.code.replace(/\\</g, \"&lt;\")}</code>`\n  }\naboveAsCodeNode\n description Print the Scroll code for the previous node.\n extends belowAsCodeNode\n javascript\n  method = \"getPrevious\"\n  reverseNodes = true\ncommentNode\n description Comments do not appear in the compiled HTML.\n catchAllCellType commentCell\n extends abstractScrollNode\n cruxFromId\n javascript\n  compile() {\n   return ``\n  }\n catchAllNodeType commentLineNode\nslashCommentNode\n extends commentNode\n crux //\ncssNode\n extends abstractScrollNode\n description Prints CSS content wrapped in a style tag.\n cruxFromId\n catchAllNodeType cssLineNode\n catchAllCellType cssAnyCell\n javascript\n  compile() {\n   return `<style>${this.content ?? \"\"}${this.childrenToString()}</style>`\n  }\nabstractTopLevelSingleMetaNode\n description Use these keywords once per file.\n extends abstractScrollNode\n cruxFromId\n cells keywordCell\n javascript\n  compile() {\n   return \"\"\n  }\ndateNode\n catchAllCellType dateCell\n description Date this file was first published.\n extends abstractTopLevelSingleMetaNode\ngroupsNode\n description Add this file to zero or more groups.\n cruxFromId\n example\n  groups index.html\n extends abstractTopLevelSingleMetaNode\n cells keywordCell\n catchAllCellType groupNameCell\nmetaTagsNode\n cruxFromId\n extends abstractTopLevelSingleMetaNode\n description Adds meta tags like title, description, et cetera.\n javascript\n  compileSnippet() {\n   return \"\"\n  }\n  compile() {\n   const { file } = this.parent\n   const { title, description, openGraphImage, SCROLL_VERSION } = file\n   const rssFeedUrl = file.get(\"rssFeedUrl\")\n   let rssTag = \"\"\n   if (rssFeedUrl) {\n    rssTag = `link\n   rel alternate\n   type application/rss+xml\n   title ${title}\n   href ${rssFeedUrl}`\n   }\n   return file.compileStumpCode(`meta\n   charset utf-8\n  titleTag ${title}\n  script /* The HTML below was generated by ðŸ“œ Scroll v${SCROLL_VERSION}. http://scroll.pub */\n  styleTag @media print {.doNotPrint {display: none !important;}}\n  meta\n   charset iso-8859-1\n  meta\n   name viewport\n   content width=device-width,initial-scale=1\n  meta\n   name description\n   content ${description}\n  meta\n   name generator\n   content Scroll v${SCROLL_VERSION}\n  meta\n   property og:title\n   content ${title}\n  meta\n   property og:description\n   content ${description}\n  meta\n   property og:image\n   content ${openGraphImage}\n   ${rssTag}\n  meta\n   name twitter:card\n   content summary_large_image`)\n  }\ndescriptionNode\n catchAllCellType stringCell\n description Description for Open Graph. https://ogp.me/. If not defined, Scroll will try to generate it's own.\n extends abstractTopLevelSingleMetaNode\npermalinkNode\n description When compiling, Scroll will save this file to {permalink}\n extends abstractTopLevelSingleMetaNode\n cells keywordCell permalinkCell\nendSnippetNode\n description Insert one of these where you want to cut the file for a snippet.\n extends abstractTopLevelSingleMetaNode\nviewSourceUrlNode\n catchAllCellType urlCell\n description Use this to override the link to the source code for a scroll file.\n extends abstractTopLevelSingleMetaNode\nabstractFolderSettingNode\n extends abstractScrollNode\n cells keywordCell\n javascript\n  compile() {\n   return \"\"\n  }\nabstractUrlSettingNode\n extends abstractFolderSettingNode\n cells keywordCell urlCell\n cruxFromId\nbaseUrlNode\n description Root url of this published folder on the web. Must be provided for RSS Feeds and OpenGraph tags to work, but has no effect locally.\n extends abstractUrlSettingNode\nhomeLinkNode\n description In the default Scroll theme the home button will link to \"index.html\". You can override this with this setting.\n extends abstractUrlSettingNode\nviewSourceBaseUrlNode\n description The base link to be used to generate the \"View source\" link.\n extends abstractUrlSettingNode\ngitNode\n description A link to the web Git UI for this folder.\n extends abstractUrlSettingNode\nopenGraphImageNode\n description URL for Open Graph Image. https://ogp.me/. If not defined, Scroll will try to generate it's own using the first image tag on your page.\n extends abstractUrlSettingNode\nrssFeedUrlNode\n description URL for RSS feed, if any.\n extends abstractUrlSettingNode\nabstractSiteStringSettingNode\n extends abstractFolderSettingNode\n catchAllCellType stringCell\n cruxFromId\nemailNode\n description Email address for the folder owner.\n extends abstractFolderSettingNode\n cruxFromId\n cells keywordCell emailAddressCell\nscrollNodeTypeDefinitionNode\n extends abstractScrollNode\n todo Figure out best pattern for integrating Scroll and Grammar?\n pattern ^[a-zA-Z0-9_]+Node$\n description Define your own nodeTypes in the Grammar language for using in your Scroll files.\n baseNodeType blobNode\n javascript\n  compile() {\n   return \"\"\n  }\nhtmlNode\n description A catch all block to drop in any loose html. Use for HTML one liners and/or blocks of HTML.\n cruxFromId\n extends abstractScrollNode\n catchAllNodeType htmlLineNode\n catchAllCellType htmlAnyCell\n javascript\n  compile() {\n   return `${this.content ?? \"\"}${this.childrenToString()}`\n  }\nstumpNode\n cruxFromId\n extends abstractScrollNode\n description Stump is a Tree Language that compiles to HTML.\n catchAllNodeType stumpContentNode\n javascript\n  compile() {\n   const file = this.parent.file\n   return file.compileStumpCode(this.childrenToString())\n  }\nstumpNoSnippetNode\n extends stumpNode\n description Useful for headers and footers when you have something you don't want included in snippets.\n cruxFromId\n javascript\n  compileSnippet() {\n   return \"\"\n  }\nabstractCaptionedNode\n extends abstractScrollNode\n cells keywordCell urlCell\n inScope captionAftertextNode slashCommentNode\n cruxFromId\n javascript\n  compile() {\n   const caption = this.getNode(\"caption\")\n   const captionFig = caption ? `<figcaption>${caption.compile()}</figcaption>` : \"\"\n   return `<figure class=\"scrollCaptionedComponent\">${this.figureContent}${captionFig}</figure>`\n  }\nimageNode\n description An img tag.\n extends abstractCaptionedNode\n inScope classMarkupNode aftertextIdNode\n javascript\n  get figureContent() {\n   const file = this.root.file\n   const src = this.getWord(1)\n   let relativePath = file.folder ? file.folder.relativePath : \"\"\n   let dimensionAttributes = \"\"\n   // If its a local image, get the dimensions and put them in the HTML\n   // to avoid flicker\n   if (!src.startsWith(\"http:\") && !src.startsWith(\"https:\")) {\n    try {\n     const sizeOf = require(\"image-size\")\n     const path = require(\"path\")\n     const dimensions = sizeOf(path.join(file.folder.folder, src))\n     const width = dimensions.width\n     const height = dimensions.height\n     dimensionAttributes = `width=\"${width}\" height=\"${height}\" `\n    } catch (err) {\n     console.error(err)\n    }\n   }\n   const className = this.has(\"class\") ? ` class=\"${this.get(\"class\")}\" ` : \"\"\n   const id = this.has(\"id\") ? ` id=\"${this.get(\"id\")}\" ` : \"\"\n   return `<a href=\"${relativePath + src}\" target=\"_blank\" ${className} ${id}><img src=\"${relativePath + src}\" ${dimensionAttributes}loading=\"lazy\"></a>`\n  }\nyouTubeNode\n extends abstractCaptionedNode\n description Embed a YouTube video. Include the YouTube embed URL such as https://www.youtube.com/embed/CYPYZnVQoLg\n javascript\n  get figureContent() {\n   const url = this.getWord(1).replace(\"youtube.com/watch?v=\", \"youtube.com/embed/\")\n   return `<div class=\"youTubeHolder\"><iframe class=\"youTubeEmbed\" src=\"${url}\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></div>`\n  }\nimportNode\n description Import one file into another.\n cruxFromId\n extends abstractScrollNode\n catchAllCellType filePathCell\n javascript\n  compile() {\n   return \"\"\n  }\n example\n  import header.scroll\nimportOnlyNode\n description Mark a file as not one to build. This line will be not be imported into the importing file.\n cruxFromId\n extends abstractScrollNode\n javascript\n  compile() {\n   return \"\"\n  }\nkeyboardNavNode\n description Makes left go to previous file and right go to next file.\n extends abstractScrollNode\n cruxFromId\n catchAllCellType urlCell\n javascript\n  compileSnippet() {\n   return \"\"\n  }\n  compile() {\n   const file = this.root.file\n   const linkToPrevious = this.getWord(1) ?? file.linkToPrevious\n   const linkToNext = this.getWord(2) ?? file.linkToNext\n   const script = `<script>document.addEventListener('keydown', function(event) {\n    if (document.activeElement !== document.body) return\n    const getLinks = () => document.getElementsByClassName(\"scrollKeyboardNav\")[0].getElementsByTagName(\"a\")\n    if (event.key === \"ArrowLeft\")\n      getLinks()[0].click()\n    else if (event.key === \"ArrowRight\")\n      getLinks()[1].click()\n   });</script>`\n   return `<div class=\"scrollKeyboardNav\"><a href=\"${linkToPrevious}\">${linkToPrevious}</a> Â· ${file.permalink} Â· <a href=\"${linkToNext}\">${linkToNext}</a>${script}</div>`\n  }\nquoteNode\n cruxFromId\n description A blockquote.\n catchAllNodeType quoteLineNode\n extends abstractScrollNode\n javascript\n  compile() {\n   return `<blockquote class=\"scrollQuoteComponent\">${this.childrenToString()}</blockquote>`\n  }\nreadingListNode\n extends abstractScrollNode\n description Easily create a reading list with links, titles, and author names.\n cells keywordCell\n cruxFromId\n catchAllNodeType readingListItemNode\n example\n  readingList\n   https://example.com/similar by Author Name\n javascript\n  compile() {\n   return `<br><ul>${this.map(child => child.compile()).join(\"\\n\")}</ul>`\n  }\nredirectToNode\n description Prints an HTML redirect tag. In the future might also emit nginx config.\n extends abstractScrollNode\n cells keywordCell urlCell\n cruxFromId\n example\n  redirectTo https://scroll.pub/releaseNotes.html\n javascript\n  compile() {\n   return `<meta http-equiv=\"Refresh\" content=\"0; url='${this.getWord(1)}'\" />`\n  }\nreplaceNode\n description Define a variable token and replacement that will be applied to all lines before and after this one.\n extends abstractScrollNode\n cruxFromId\n catchAllCellType stringCell\n baseNodeType blobNode\n example\n  replace YEAR 2022\n javascript\n  compile() {\n   return \"\"\n  }\nreplaceJsNode\n description Define a variable token and replacement that will be applied to all lines before and after this one.\n extends replaceNode\n catchAllCellType javascriptCell\n example\n  replaceJs SUM 1+1\n  * 1+1 = SUM\nreplaceDefaultNode\n description Define the default value for a replacement. Useful if you want to import a file and set a replacement later.\n extends abstractScrollNode\n catchAllCellType stringCell\n baseNodeType blobNode\n example\n  replaceDefault YEAR 2021\n cruxFromId\n javascript\n  compile() {\n   return \"\"\n  }\nprintFeedNode\n description Prints out the RSS feed for a group.\n extends abstractScrollNode\n cruxFromId\n cells keywordCell groupNameWithOptionalFolderCell\n catchAllCellType groupNameWithOptionalFolderCell\n javascript\n  compile() {\n   const dayjs = require(\"dayjs\")\n   const file = this.root.file\n   const files = file.folder.getFilesInGroups(this.getWordsFrom(1))\n   const { title, baseUrl, description } = file\n   return `<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>\n  <rss version=\"2.0\">\n  <channel>\n   <title>${title}</title>\n   <link>${baseUrl}</link>\n   <description>${description}</description>\n   <lastBuildDate>${dayjs().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\")}</lastBuildDate>\n   <language>en-us</language>\n  ${files.map(file => file.toRss()).join(\"\\n\")}\n  </channel>\n  </rss>`\n  }\nabstractTableNode\n cruxFromId\n catchAllNodeType rowNode\n extends abstractScrollNode\n javascript\n  get tableHeader() {\n   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\\n`)\n  }\n  get columnNames() {\n   const header = this.nodeAt(0)\n   return header ? header.getLine().split(this.delimiter) : []\n  }\n  get columns() {\n   const cols = this.columnNames\n   return cols.map((name, index) => {\n    const isLink = name.endsWith(\"Link\")\n    const linkIndex = cols.indexOf(name + \"Link\")\n    return {\n     name,\n     isLink,\n     linkIndex\n    }\n   })\n  }\n  get tableBody() {\n   const { delimiter } = this\n   return this.getTopDownArray()\n    .slice(1)\n    .map(node => `<tr>${node.toRow(this.columns, delimiter)}</tr>`)\n    .join(\"\\n\")\n  }\n  compile() {\n   return `<table class=\"scrollTableComponent\"><thead><tr>${this.tableHeader.join(\"\\n\")}</tr></thead>\\n<tbody>${this.tableBody}</tbody></table>`\n  }\ntableNode\n description A table with a custom delimiter.\n extends abstractTableNode\n catchAllCellType anyCell\n javascript\n  get delimiter() {\n   return this.content ?? \"\"\n  }\ncommaTableNode\n description Comma separated values table.\n extends abstractTableNode\n string delimiter ,\npipeTableNode\n description Pipe separated values table.\n extends abstractTableNode\n string delimiter |\nspaceTableNode\n description Space separated values table. Last column is a catch all.\n extends abstractTableNode\n string delimiter  \ntabTableNode\n description Tab separated values table.\n extends abstractTableNode\n string delimiter \\t\ntreeTableNode\n description A table of data written in Tree Notation form. Useful when a column contains a text blob.\n extends abstractTableNode\n catchAllNodeType treeRowNode\n javascript\n  get columnNames() {\n   return this._getUnionNames()\n  }\n  get tableBody() {\n   return this.map(node => `<tr>${node.toRow(this.columns)}</tr>`).join(\"\\n\")\n  }\n example\n  treeTable\n   row\n    name Javascript\n    example\n     console.log(\"Hello world\")\n   row\n    name Python\n    example\n     print \"Hello world\"\nkpiTableNode\n description Display key statistics in a big font.\n catchAllNodeType rowNode\n cruxFromId\n extends abstractScrollNode\n example\n  kpiTable\n   #2 Popularity\n   30 Years Old\n   $456 Revenue\n javascript\n  get tableBody() {\n   const items = this.getTopDownArray()\n   let str = \"\"\n   for (let i = 0; i < items.length; i = i + 3) {\n    str += this.makeRow(items.slice(i, i + 3))\n   }\n   return str\n  }\n  makeRow(items) {\n   return `<tr>` + items.map(node => `<td>${node.firstWord}<span>${node.content}</span></td>`).join(\"\\n\") + `</tr>\\n`\n  }\n  compile() {\n   return `<table class=\"scrollKpiTable\">${this.tableBody}</table>`\n  }\nabstractAftertextAttributeNode\n cells keywordCell\n boolean isAttributeNode true\n javascript\n  get divAttributes() {\n   return `${this.firstWord}=\"${this.content}\"`\n  }\n  compile() {\n   return \"\"\n  }\naftertextIdNode\n crux id\n description Provide an ID to be output in the generated HTML tag.\n extends abstractAftertextAttributeNode\n cells keywordCell htmlIdCell\n single\naftertextHiddenNode\n crux hidden\n cells keywordCell\n description Do not compile this node to HTML.\n extends abstractAftertextAttributeNode\n single\nabstractAftertextDirectiveNode\n cells keywordCell\n catchAllCellType stringCell\n javascript\n  isMarkupNode = true\n  compile() {\n   return \"\"\n  }\n  get pattern() {\n   return this.getWordsFrom(1).join(\" \")\n  }\n  get shouldMatchAll() {\n   return this.has(\"matchAll\")\n  }\n  getMatches(text) {\n   const { pattern } = this\n   const escapedPattern = pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\")\n   return [...text.matchAll(new RegExp(escapedPattern, \"g\"))].map(match => {\n    const { index } = match\n    const endIndex = index + pattern.length\n    return [\n     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },\n     { index: endIndex, endIndex, string: `</${this.closeTag}>` }\n    ]\n   })\n  }\n  getInserts(text) {\n   const matches = this.getMatches(text)\n   if (!matches.length) return false\n   if (this.shouldMatchAll) return matches.flat()\n   const indexNode = this.getNode(\"match\")\n   if (indexNode)\n    return indexNode.indexes\n     .map(index => matches[index])\n     .filter(i => i)\n     .flat()\n   return matches[0]\n  }\n  get allAttributes() {\n   const attr = this.attributes.join(\" \")\n   return attr ? \" \" + attr : \"\"\n  }\n  get attributes() {\n   return []\n  }\n  get openTag() {\n   return this.tag\n  }\n  get closeTag() {\n   return this.tag\n  }\nabstractMarkupNode\n extends abstractAftertextDirectiveNode\n inScope abstractMarkupParameterNode\nboldNode\n cruxFromId\n extends abstractMarkupNode\n javascript\n  tag = \"b\"\nitalicsNode\n cruxFromId\n extends abstractMarkupNode\n javascript\n  tag = \"i\"\nunderlineNode\n cruxFromId\n extends abstractMarkupNode\n javascript\n  tag = \"u\"\naftertextCodeNode\n crux code\n extends abstractMarkupNode\n javascript\n  tag = \"code\"\nlinkNode\n extends abstractMarkupNode\n cells keywordCell urlCell\n inScope linkTitleNode linkTargetNode commentNode\n cruxFromId\n javascript\n  tag = \"a\"\n  get link() {\n   const link = this.getWord(1)\n   const isAbsoluteLink = link.startsWith(\"https://\") || link.startsWith(\"http://\")\n   return isAbsoluteLink ? link : (this.root.file.folder?.relativePath || \"\") + link\n  }\n  get attributes() {\n   const attrs = [`href=\"${this.link}\"`]\n   const options = [\"title\", \"target\"]\n   options.forEach(option => {\n    const node = this.getNode(option)\n    if (node) attrs.push(`${option}=\"${node.content}\"`)\n   })\n   return attrs\n  }\n  patternStartsAtWord = 2\n  get pattern() {\n   // If no pattern is provided, apply to the *entire* content.\n   const words = this.getWordsFrom(this.patternStartsAtWord)\n   return words.length ? words.join(\" \") : this.parent.content\n  }\nemailLinkNode\n description A mailto link\n crux email\n extends linkNode\n javascript\n  get attributes() {\n   return [`href=\"mailto:${this.link}\"`]\n  }\nquickLinkNode\n pattern ^https?\\:\n extends linkNode\n cells urlCell\n javascript\n  get link() {\n   return this.firstWord\n  }\n  patternStartsAtWord = 1\nclassMarkupNode\n description Add a custom class to the parent element instead. If matching text provided, a span with the class will be added around the matching text.\n extends abstractMarkupNode\n cells keywordCell classNameCell\n crux class\n javascript\n  tag = \"span\"\n  get applyToParentElement() {\n    return this.words.length === 2\n  }\n  getInserts(text) {\n    // If no select text is added, set the class on the parent element.\n    if (this.applyToParentElement) return []\n    return super.getInserts(text)\n  }\n  get className() {\n   return this.getWord(1)\n  }\n  get attributes() {\n   return [`class=\"${this.className}\"`]\n  }\n  get pattern() {\n   const words = this.getWordsFrom(2)\n   return words.length ? words.join(\" \") : this.parent.content\n  }\nhoverNoteNode\n description Add a caveat viewable on hover on matching text. When you want to be sure you've thoroughly addressed obvious concerns but ones that don't warrant to distract from the main argument of the text.\n cruxFromId\n extends classMarkupNode\n catchAllNodeType lineOfTextNode\n cells keywordCell\n javascript\n  get pattern() {\n   return this.getWordsFrom(1).join(\" \")\n  }\n  get attributes() {\n   return [`class=\"scrollHoverNote\"`, `title=\"${this.hoverNoteText}\"`]\n  }\n  get hoverNoteText() {\n   return this.childrenToString().replace(/\\n/g, \" \")\n  }\nstrikethroughNode\n cruxFromId\n extends abstractMarkupNode\n javascript\n  tag = \"s\"\nlinkifyNode\n description Use this to disable linkify on the text.\n extends abstractAftertextDirectiveNode\n cruxFromId\n cells keywordCell booleanCell\nwrapsOnNode\n cruxFromId\n description Enable `code`, *bold*, and _italics_ rules.\n extends abstractAftertextDirectiveNode\n javascript\n  get shouldMatchAll() {\n   return true\n  }\n  getMatches(text) {\n   return [this.runPattern(text, \"`\", \"code\"), this.runPattern(text, \"*\", \"strong\"), this.runPattern(text, \"_\", \"em\")].filter(i => i).flat()\n  }\n  runPattern(text, delimiter, tag, attributes = \"\") {\n   const escapedDelimiter = delimiter.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\")\n   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, \"g\")\n   const delimiterLength = delimiter.length\n   return [...text.matchAll(pattern)].map(match => {\n    const { index } = match\n    const endIndex = index + match[0].length\n    return [\n     { index, string: `<${tag + (attributes ? \" \" + attributes : \"\")}>`, endIndex, consumeStartCharacters: delimiterLength },\n     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }\n    ]\n   })\n  }\nwrapNode\n cruxFromId\n cells keywordCell delimiterCell tagOrUrlCell\n catchAllCellType htmlAttributesCell\n extends wrapsOnNode\n description Define a custom wrap, for example \"wrap _ em\" would support: _italics_.\n javascript\n  getMatches(text) {\n   try {\n    const delimiter = this.getWord(1)\n    const tag = this.getWord(2)\n    const attributes = this.getWordsFrom(3).join(\" \")\n    if (tag.startsWith(\"https:\")) return this.runPattern(text, delimiter, \"a\", `href=\"${tag}\"` + attributes)\n    return this.runPattern(text, delimiter, tag, attributes)\n   } catch (err) {\n    console.error(err)\n    return []\n   }\n   // Note: doubling up doesn't work because of the consumption characters.\n  }\ndatelineNode\n cruxFromId\n description Gives your paragraph a dateline like \"December 15, 2021 â€” The...\"\n extends abstractAftertextDirectiveNode\n javascript\n  getInserts() {\n   let day = this.content || this.parent.parent.get(\"date\")\n   if (!day) return false\n   try {\n    const dayjs = require(\"dayjs\")\n    day = dayjs(day).format(`MMMM D, YYYY`)\n   } catch (err) {\n    console.error(err)\n   }\n   return [{ index: 0, string: `<span class=\"scrollDateComponent\">${day} â€” </span>` }]\n  }\ndayjsNode\n description Advanced directive that evals some Javascript code in an environment including \"dayjs\".\n cruxFromId\n extends abstractAftertextDirectiveNode\n javascript\n  getInserts() {\n   const dayjs = require(\"dayjs\")\n   const days = eval(this.content)\n   const index = this.parent.originalTextPostLinkify.indexOf(\"days\")\n   return [{ index, string: `${days} ` }]\n  }\nabstractMarkupParameterNode\n cells keywordCell\n cruxFromId\nmatchAllNode\n description Use this to match all occurrences of the text.\n extends abstractMarkupParameterNode\nmatchNode\n catchAllCellType integerCell\n description Use this to specify which index(es) to match.\n javascript\n  get indexes() {\n   return this.getWordsFrom(1).map(num => parseInt(num))\n  }\n example\n  aftertext\n   hello ello ello\n   bold ello\n    match 0 2\n extends abstractMarkupParameterNode\nabstractHtmlAttributeNode\n javascript\n  compile() {\n   return \"\"\n  }\nlinkTargetNode\n extends abstractHtmlAttributeNode\n description If you want to set the target of the link. To \"_blank\", for example.\n crux target\n cells keywordCell anyCell\nlinkTitleNode\n description If you want to set the title of the link.\n crux title\n cells keywordCell\n catchAllCellType anyCell\n example\n  * This report showed the treatment had a big impact.\n   https://example.com/report This report.\n    title The average growth in the treatment group was 14.2x higher than the control group.\nblankLineNode\n description Blank lines compile to nothing in the HTML.\n cells blankCell\n javascript\n  compile() {\n   return this.parent.clearStack()\n  }\n pattern ^$\n tags doNotSynthesize\ncatchAllParagraphNode\n description A catch all block. This may be removed in future versions.\n catchAllCellType stringCell\n baseNodeType errorNode\n javascript\n  compile() {\n   return `<p class=\"scrollParagraphComponent\">${this.getLine()}</p>`\n  }\nerrorNode\n baseNodeType errorNode\nchatLineNode\n catchAllCellType anyCell\n catchAllNodeType chatLineNode\nlineOfCodeNode\n catchAllCellType codeCell\n catchAllNodeType lineOfCodeNode\ncommentLineNode\n catchAllCellType commentCell\ncssLineNode\n catchAllCellType cssAnyCell\n catchAllNodeType cssLineNode\nlineOfTextNode\n catchAllCellType stringCell\n boolean isTextNode true\nhtmlLineNode\n catchAllCellType htmlAnyCell\n catchAllNodeType htmlLineNode\nstumpContentNode\n catchAllCellType anyCell\nquoteLineNode\n catchAllCellType anyCell\n catchAllNodeType quoteLineNode\nreadingListItemNode\n cells urlCell\n catchAllCellType stringCell\n javascript\n  compile() {\n   const url = this.firstWord\n   const [title, author] = this.content.split(\" by \")\n   return `<li><a href=\"${url}\">${title ?? url}</a>${author ? ` by ${author}` : \"\"}</li>`\n  }\nscrollScriptNode\n extensions scroll\n description Tools for thought that compile to HTML.\n root\n inScope abstractScrollNode blankLineNode\n catchAllNodeType catchAllParagraphNode\n compilesTo html\n javascript\n  setFile(file) {\n   this.file = file\n   return this\n  }\n  stack = []\n  clearStack() {\n   const result = this.stack.join(\"\")\n   this.stack = []\n   return result\n  }\n  compileSnippet() {\n   return this.map(child => (child.compileSnippet ? child.compileSnippet() : child.compile())).join(\"\\n\")\n  }\n  get footnotes() {\n   if (this._footnotes === undefined) this._footnotes = this.filter(node => node.isFootnote)\n   return this._footnotes\n  }\n  file = {}\n  get permalink() {\n   return this.get(\"permalink\") || this.file.permalink || \"\"\n  }\n example\n  # Hello world\n  ## This is Scroll\n  * It compiles to HTML. Blank lines get turned into brs.\n  \n  code\n   // You can add code as well.\n   print(\"Hello world\")\nloopLineNode\n catchAllCellType stringCell\nabstractLoopConfigNode\n cells keywordCell\nabstractItemsProviderNode\n extends abstractLoopConfigNode\nloopLinesNode\n crux lines\n extends abstractItemsProviderNode\n description Iterate over the provided lines.\n catchAllNodeType loopLineNode\n javascript\n  get items() {\n   return this.map(node => node.toString())\n  }\nloopWordsNode\n crux words\n extends abstractItemsProviderNode\n catchAllCellType stringCell\n description Iterate over the provided words.\n javascript\n  get items() {\n   return this.getWordsFrom(1)\n  }\nloopGroupsNode\n crux groups\n extends abstractItemsProviderNode\n catchAllCellType groupNameWithOptionalFolderCell\n description Set this to iterate over scroll files in a folder. Provide both the folder and group name like this: [folder]/[groupName]\n javascript\n  get items() {\n   return this.parent.parent.file.folder.getFilesInGroups(this.getWordsFrom(1))\n  }\nloopJoinNode\n extends abstractLoopConfigNode\n crux join\n catchAllCellType stringCell\n description HTML to use to join the items.\nloopLimitNode\n extends abstractLoopConfigNode\n crux limit\n catchAllCellType stringCell\n description HTML to use to join the items.\nloopCodeNode\n extends abstractLoopConfigNode\n crux javascript\n catchAllCellType javascriptCell\n description Javascript to execute for each file in the loop.\nrowNode\n catchAllCellType stringCell\n javascript\n  toRow(columns, delimiter) {\n   const words = this.getLine().split(delimiter)\n   let str = \"\"\n   let column = 0\n   const columnCount = columns.length\n   while (column < columnCount) {\n    const col = columns[column]\n    column++\n    const content = columnCount === column ? words.slice(columnCount - 1).join(\" \") : words[column - 1]\n    if (col.isLink) continue\n    let tagged = content\n    const link = words[col.linkIndex]\n    if (col.linkIndex > -1 && link) tagged = `<a href=\"${link}\">${content}</a>`\n    else if (content && content.match(/^https?\\:[^ ]+$/))\n     tagged = `<a href=\"${content}\">${content}</a>`\n    str += `<td>${tagged}</td>\\n`\n   }\n   return str\n  }\ntreeRowContentNode\n description Any blob content in a cell.\n cells stringCell\n catchAllCellType stringCell\ntreeRowColumnNode\n catchAllNodeType treeRowContentNode\n description A columnName value pair, or just a columnName if the value is a text blob.\n cells idCell\n catchAllCellType stringCell\ntreeRowNode\n cells idCell\n description The root node of a row.\n catchAllNodeType treeRowColumnNode\n javascript\n  toRow(columns) {\n   let str = \"\"\n   columns.forEach(col => {\n    const node = this.getNode(col.name)\n    if (col.isLink) return\n    if (!node) {\n     str += \"<td></td>\\n\"\n     return\n    }\n    const content = node.length ? node.childrenToString() : node.content\n    let tagged = \"\"\n    const link = this.get(col.name + \"Link\")\n    if (col.linkIndex > -1 && link) tagged = `<a href=\"${link}\">${content}</a>`\n    else if (node.length) tagged = `<pre>${content ?? \"\"}</pre>`\n    else tagged = content ?? \"\"\n    str += `<td>${tagged}</td>\\n`\n   })\n   return str\n  }","style":"html,body,div,span,h1,h2,h3,h4,p,ol,ul,li,table,figure {\n  margin: 0;\n  padding: 0;\n  border: 0;\n  vertical-align: baseline;\n  border-spacing: 0;\n}\nli {\n  list-style-position: inside;\n  margin-top: .4em;\n  line-height: 1.2em;\n}\na {\n  text-decoration-color: transparent;\n}\na:hover {\n  text-decoration-color: initial;\n}\nsup,sub {\n  vertical-align: baseline;\n  position: relative;\n  top: -0.6em;\n}\nsub {\n  top: 0.6em;\n}\nhtml {\n  padding: 4px;\n  background-color: rgb(244,244,244);\n  font-family: Exchange,Georgia,serif;\n  color: #000;\n  font-size: 14px;\n  hyphens: auto;\n}\n.scrollHeaderComponent svg {\n  width: 30px;\n  height: 30px;\n  fill: rgba(204,204,204,.8);\n}\n.scrollHeaderComponent svg:hover {\n  fill: #333;\n}\n.scrollHeaderComponent a {\n  color: rgba(204,204,204,.8);\n  position: absolute;\n  font-size: 30px;\n  line-height: 27px;\n  text-decoration: none;\n}\n.scrollHeaderComponent a:hover {\n  color: #333;\n}\n.scrollHeaderComponent .scrollTopLeftBarComponent {\n  text-align: left;\n  left: 25px;\n}\n.scrollHeaderComponent .scrollTopRightBarComponent {\n  text-align: right;\n  right: 25px;\n}\n.scrollHeaderComponent a.scrollPrevPageLink {\n  left: 3px;\n}\n.scrollHeaderComponent a.scrollNextPageLink {\n  right: 3px;\n}\n.scrollFooterComponent {\n  margin-top: 8px;\n  padding-top: 8px;\n  text-align: center;\n}\n.scrollFooterComponent svg {\n  width: 30px;\n  height: 30px;\n  fill: rgba(204,204,204, .5);\n  padding: 0 7px;\n}\n.scrollFooterComponent svg:hover {\n  fill: #333;\n}\n.scrollCommunityLinkComponent {\n  display: block;\n  font-family: Verdana;\n  font-weight: 100;\n  margin: .5em;\n  color: rgba(204,204,204,.5);\n}\n.scrollColumnsComponent {\n  column-count: auto;\n  column-fill: balance;\n  column-width: 35ch;\n  column-gap: 20px;\n  padding-left: 20px;\n  padding-right: 20px;\n  margin: auto;\n}\n.scrollSnippetContainerComponent {\n  padding: 1ch 0;\n  break-inside: avoid;\n  text-align: justify;\n}\n.scrollTitleComponent {\n  text-align: center;\n  margin-bottom: .25em;\n}\n.scrollTitleComponent a {\n  color: #000;\n}\n.scrollDateComponent {\n  font-style: italic;\n  font-size: 80%;\n}\n.scrollParagraphComponent {\n  margin-top: 0.4em;\n  line-height: 1.4em;\n}\n.scrollQuoteComponent {\n  break-inside: avoid;\n  display: block;\n  margin: .5em 0;\n  padding: .5em;\n  background: rgba(204,204,204,.5);\n  white-space: pre-line;\n  border-left: .5em solid rgba(204,204,204,.8);\n}\n.scrollSectionComponent {\n  break-inside: avoid;\n}\n.scrollSectionComponent h3 {\n  margin-top: 1em;\n  text-align: center;\n}\n.scrollSectionComponent h4 {\n  margin-top: 1em;\n  text-align: center;\n}\nh4.scrollQuestionComponent {\n  text-align: left;\n}\n.scrollNoteLink {\n  opacity: .4;\n}\ncode {\n  font-size: 90%;\n  background-color: rgba(204,204,204,.5);\n  padding: 2px 4px;\n  border-radius: 4px;\n}\n.scrollCodeBlockComponent {\n  overflow: auto;\n  font-size: 80%;\n  hyphens: none;\n  white-space: pre;\n  border-left: .5em solid rgba(204,204,204,.8);\n  break-inside: avoid;\n  display: block;\n  margin: .5em 0;\n  padding: .5em;\n  border-radius: 0;\n}\n.scrollTableComponent {\n  table-layout: fixed;\n  margin: .5em 0;\n  overflow: hidden;\n  font-size: 80%;\n  width: 100%;\n  hyphens: none;\n  border: 1px solid rgba(224,224,224,.8);\n}\n.scrollTableComponent td,.scrollTableComponent th {\n  padding: 3px;\n  overflow: hidden;\n}\n.scrollTableComponent th {\n  border-bottom: 2px solid rgba(0,0,0,.6);\n  text-align: left;\n}\n.scrollTableComponent tr:nth-child(even) {\n  background: rgba(224,224,224,.6);\n}\n.scrollAuthor {\n  font-size: 12px;\n  font-style: italic;\n  margin: 4px 0;\n  text-align: center;\n}\n.scrollKpiTable {\n  width: 100%;\n  font-size: 30px;\n  text-align: center;\n  font-weight: bold;\n  break-inside: avoid;\n  margin-top: 8px;\n  margin-bottom: 8px;\n}\n.scrollKpiTable td {\n  width: 33.3%;\n  border: 1px solid #e8e8e8;\n}\n.scrollKpiTable span {\n  font-size: 20p;;\n  display: block;\n}\n.scrollFileViewSourceUrlComponent {\n  text-align: center;\n  font-size: 80%;\n  margin: 0;\n  margin-top: 0.4em;\n  line-height: 1.4em;\n  margin-bottom: 1em;\n}\n.scrollFileViewSourceUrlComponent a {\n  color: #000;\n}\n.scrollContinueReadingLink {\n  display: block;\n  text-align: center;\n}\n.scrollDialogueComponent span {\n  font-family: Verdana;\n  margin-top: 5px;\n  padding: 5px 20px;\n  border-radius: 15px;\n  display: inline-block;\n}\n.scrollDialogueComponentLeft {\n  text-align: left;\n}\n.scrollDialogueComponentLeft span {\n  background: rgba(204,204,204, .5);\n}\n.scrollDialogueComponentRight {\n  text-align: right;\n}\n.scrollDialogueComponentRight span {\n  color: white;\n  background: rgb(0,132,255);\n}\n.scrollCaptionedComponent {\n  display: block;\n  text-align: center;\n}\n.scrollCaptionedComponent img {\n  max-width: 98%;\n  height: auto;\n}\n.scrollCaptionedComponent figcaption {\n  font-style: italic;\n}\n.scrollKeyboardNav {\n  display: none;\n}\n.scrollHoverNote {\n  text-decoration: underline dashed 1px rgba(0,0,0,.1);\n  cursor: default;\n}\n.youTubeHolder {\n  position: relative;\n  width: 100%;\n  height: 0;\n  padding-bottom: 56.25%;\n}\n.youTubeEmbed {\n  position: absolute;\n  top: 0;\n  left: 0;\n  width: 100%;\n  height: 100%;\n}\n"}