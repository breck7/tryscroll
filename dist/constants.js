const AppConstants = {"grammar":"tooling A function generates this Scrolldown grammar by combining all files in the grammars folder.\ntooling\n Related work\n CSS is great for text selector ideas: https://www.w3schools.com/cssref/css_selectors.asp\n Roff has a lot of related markup ideas: https://www.systutorials.com/docs/linux/man/7-groff_man/\ntagOrUrlCell\n description An HTML tag or a url.\n highlightScope constant.language\ndelimiterCell\n description String to use as a delimiter.\n highlightScope string\nhtmlAttributesCell\n highlightScope comment\nclassNameCell\n highlightScope constant\nhtmlIdCell\n extends idCell\ndateCell\n highlightScope string\nintegerCell\n highlightScope constant.numeric\npermalinkCell\n highlightScope string\ncodeCell\n highlightScope comment\ncommentCell\n highlightScope comment\nbulletPointCell\n highlightScope keyword\nanyCell\nurlCell\n highlightScope constant.language\nkeywordCell\n highlightScope keyword\nstringCell\n highlightScope string\nidCell\n highlightScope constant.language\nblankCell\naftertextTextNode\n catchAllCellType stringCell\n boolean isTextNode true\nabstractScrollNode\n abstract\n cells keywordCell\naftertextNode\n description Text followed by markup commands.\n extends abstractScrollNode\n catchAllNodeType aftertextTextNode\n inScope abstractAftertextDirectiveNode abstractAftertextAttributeNode\n cruxFromId\n example\n  aftertext\n   Hello brave new world\n   link home.com new\n   bold brave new\n   underline new world\n   strikethrough wor\n javascript\n  get markupInserts() {\n   const { originalText } = this\n   return this.filter(node => node.isMarkupNode)\n    .map(node => node.getInserts(originalText))\n    .filter(i => i)\n    .flat()\n  }\n  get originalText() {\n   return this.filter(node => node.isTextNode)\n    .map(node => node.toString())\n    .join(\"\\n\")\n  }\n  get text() {\n   const { originalText, markupInserts } = this\n   let adjustment = 0\n   let newText = originalText\n   // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.\n   markupInserts.sort((a, b) => (a.index === b.index ? b.endIndex - a.endIndex : a.index - b.index))\n   markupInserts.forEach(insertion => {\n    insertion.index += adjustment\n    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0\n    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0\n    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)\n    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters\n   })\n   return newText\n  }\n  compile() {\n   return `<p ${this.divAttributes}class=\"scrollParagraphComponent\">${this.text}</p>`\n  }\n  get divAttributes() {\n   const attrs = this.filter(node => node.isAttributeNode)\n   return attrs.length ? attrs.map(node => node.divAttributes).join(\" \") + \" \" : \"\"\n  }\nloremIpsumNode\n extends aftertextNode\n description Generate dummy text.\n cruxFromId\n catchAllCellType integerCell\n javascript\n  get originalText() {\n   return `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`\n  }\n  compile() {\n   return super.compile().repeat(this.getWord(1) ? parseInt(this.getWord(1)) : 1)\n  }\nabstractTopLevelSingleMetaNode\n abstract\n description Use these keywords once per file.\n extends abstractScrollNode\n cruxFromId\n cells keywordCell\n compiler\n  stringTemplate \npermalinkNode\n description When compiling, Scroll will save this article to {permalink}.html\n extends abstractTopLevelSingleMetaNode\n cells keywordCell permalinkCell\nskipIndexPageNode\n description Add this tag if you want to build a page but not include it in the index page.\n extends abstractTopLevelSingleMetaNode\ntitleNode\n catchAllCellType stringCell\n description Title of the article.\n extends abstractTopLevelSingleMetaNode\n javascript\n  compile() {\n   return `<h1 class=\"scrollTitleComponent\"><a href=\"${this.getRootNode().permalink}.html\">${this.getContent()}</a></h1>`\n  }\nhtmlTitleNode\n catchAllCellType stringCell\n description Use this to override the automatic HTML <title> generation.\n extends abstractTopLevelSingleMetaNode\nsourceLinkNode\n catchAllCellType urlCell\n description Use this to override the link to the source code for a scroll file.\n extends abstractTopLevelSingleMetaNode\ndateNode\n catchAllCellType dateCell\n description Date the article was first published.\n extends abstractTopLevelSingleMetaNode\nmaxColumnsNode\n catchAllCellType integerCell\n description Set your own max column count for a single article's generated HTML.\n extends abstractTopLevelSingleMetaNode\ncolumnWidthNode\n catchAllCellType integerCell\n description Set your own column width, in ch units, for the generated HTML.\n extends abstractTopLevelSingleMetaNode\nendSnippetNode\n description Insert one of these where you want to cut the article for the snippets.html page.\n extends abstractTopLevelSingleMetaNode\nchatNode\n description A dialogue between two people.\n catchAllNodeType chatLineNode\n cruxFromId\n extends abstractScrollNode\n javascript\n  compile() {\n   return this.map((line, index) => `<div class=\"scrollDialogueComponent ${index % 2 ? \"scrollDialogueComponentRight\" : \"scrollDialogueComponentLeft\"}\"><span>${line.toString()}</span></div>`).join(\"\")\n  }\ncodeNode\n description A code block.\n catchAllNodeType lineOfCodeNode\n extends abstractScrollNode\n javascript\n  compile() {\n   return `<code class=\"scrollCodeBlockComponent\">${this.childrenToString().replace(/\\</g, \"&lt;\")}</code>`\n  }\n cruxFromId\ncodeWithLanguageNode\n description Use this to specify the language of the code block, such as csvCode or rustCode.\n extends codeNode\n pattern ^[a-zA-Z0-9_]+Code$\nbelowAsCodeNode\n description Print the Scroll code of the next node.\n extends abstractScrollNode\n cruxFromId\n javascript\n  get target() {\n   return this.getNext()\n  }\n  compile() {\n   return `<code class=\"scrollCodeBlockComponent\">${this.target.toString().replace(/\\</g, \"&lt;\")}</code>`\n  }\naboveAsCodeNode\n description Print the Scroll code for the previous node.\n extends belowAsCodeNode\n javascript\n  get target() {\n   return this.getPrevious()\n  }\ncommentNode\n description Will not appear in the compiled HTML.\n catchAllCellType commentCell\n extends abstractScrollNode\n cruxFromId\n javascript\n  compile() {\n   return ``\n  }\n catchAllNodeType commentLineNode\ncssNode\n extends abstractScrollNode\n description Prints CSS content wrapped in a style tag.\n cruxFromId\n extends abstractScrollNode\n catchAllNodeType cssLineNode\n javascript\n  compile() {\n   return `<style>${this.childrenToString()}</style>`\n  }\nabstractHeaderNode\n cruxFromId\n catchAllCellType stringCell\n extends abstractScrollNode\n catchAllNodeType multilineTitleNode\n javascript\n  compile() {\n   const children = this.childrenToString() ? \" \" + this.childrenToString() : \"\"\n   return `<${this.tag} class=\"${this.className}\">${this.getContent() + children}</${this.tag}>`\n  }\nsectionNode\n description Compiles to an h3 tag.\n extends abstractHeaderNode\n javascript\n  tag = \"h3\"\n  className = \"scrollSectionComponent\"\nsubsectionNode\n description Compiles to an h4 tag.\n extends abstractHeaderNode\n javascript\n  tag = \"h4\"\n  className = \"scrollSubsectionComponent\"\nquestionNode\n description Use for pages like FAQs.\n extends abstractHeaderNode\n javascript\n  tag = \"h4\"\n  className = \"scrollQuestionComponent\"\nhtmlNode\n description A catch all block to drop in any loose html.\n cruxFromId\n extends abstractScrollNode\n catchAllNodeType htmlLineNode\n javascript\n  compile() {\n   return `${this.childrenToString()}`\n  }\nimageNode\n description An img tag.\n cells keywordCell urlCell\n extends abstractScrollNode\n cruxFromId\n inScope imageCaptionNode\n javascript\n  compile() {\n   const dirPath = this.getParent().folder\n   const src = this.getWord(1)\n   let imgTag = \"\"\n   try {\n    const sizeOf = require(\"image-size\")\n    const dimensions = sizeOf(dirPath + \"/\" + src)\n    const width = dimensions.width\n    const height = dimensions.height\n    imgTag = `<img src=\"${src}\" width=\"${width}\" height=\"${height}\" loading=\"lazy\"/>`\n   } catch (err) {\n    console.error(err)\n    imgTag = `<img src=\"${src}\">`\n   }\n   const caption = this.get(\"caption\")\n   const captionFig = caption ? `<figcaption>${caption}</figcaption>` : \"\"\n   return `<figure class=\"scrollImageComponent\"><a href=\"${src}\" target=\"_blank\">${imgTag}</a>${captionFig}</figure>`\n  }\ncustomHeaderNode\n extends abstractScrollNode\n description Define a header for a certain page. Setting to blank will also remove the header on a page.\n crux header\n catchAllNodeType stumpNode\n javascript\n  compile() {\n   return \"\"\n  }\ncustomFooterNode\n extends abstractScrollNode\n description Define a footer for a certain page. Setting to blank will also remove the footer on a page.\n crux footer\n catchAllNodeType stumpNode\n javascript\n  compile() {\n   return \"\"\n  }\nlistNode\n description An unordered list.\n catchAllNodeType listItemNode\n cruxFromId\n extends abstractScrollNode\n compiler\n  stringTemplate \n  openChildren <ul class=\"scrollUnorderedListComponent\">\n  closeChildren </ul>\norderedListNode\n description An ordered list.\n extends listNode\n cruxFromId\n compiler\n  stringTemplate \n  openChildren <ol class=\"scrollOrderedListComponent\">\n  closeChildren </ol>\nparagraphNode\n description Prose content.\n catchAllNodeType paragraphContentNode\n extends abstractScrollNode\n cruxFromId\n javascript\n  get paragraphContent() {\n   return this.childrenToString()\n  }\n  compile() {\n   return `<p class=\"scrollParagraphComponent\">${this.getRootNode().compileATags(this.paragraphContent)}</p>`\n  }\nquoteNode\n cruxFromId\n description A blockquote.\n catchAllNodeType quoteLineNode\n extends abstractScrollNode\n javascript\n  compile() {\n   return `<blockquote class=\"scrollQuoteComponent\">${this.childrenToString()}</blockquote>`\n  }\nabstractTableNode\n cruxFromId\n catchAllNodeType rowNode\n extends abstractScrollNode\n javascript\n  get tableHeader() {\n   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\\n`)\n  }\n  get columnNames() {\n   const header = this.nodeAt(0)\n   return header ? header.getLine().split(this.delimiter) : []\n  }\n  get columns() {\n   const cols = this.columnNames\n   return cols.map((name, index) => {\n    const isLink = name.endsWith(\"Link\")\n    const linkIndex = cols.indexOf(name + \"Link\")\n    return {\n     name,\n     isLink,\n     linkIndex\n    }\n   })\n  }\n  get tableBody() {\n   const { delimiter } = this\n   return this.getTopDownArray()\n    .slice(1)\n    .map(node => `<tr>${node.toRow(this.columns, delimiter)}</tr>`)\n    .join(\"\\n\")\n  }\n  compile() {\n   return `<table class=\"scrollTableComponent\"><thead><tr>${this.tableHeader.join(\"\\n\")}</tr></thead>\\n<tbody>${this.tableBody}</tbody></table>`\n  }\ncommaTableNode\n description Comma separated values table.\n extends abstractTableNode\n string delimiter ,\npipeTableNode\n description Pipe separated values table.\n extends abstractTableNode\n string delimiter |\nspaceTableNode\n description Space separated values table. Last column is a catch all.\n extends abstractTableNode\n string delimiter  \ntabTableNode\n description Tab separated values table.\n extends abstractTableNode\n string delimiter \\t\ntreeTableNode\n description A table of data written in Tree Notation form. Useful when a column contains a text blob.\n extends abstractTableNode\n catchAllNodeType treeRowNode\n javascript\n  get columnNames() {\n   return this._getUnionNames()\n  }\n  get tableBody() {\n   return this.map(node => `<tr>${node.toRow(this.columns)}</tr>`).join(\"\\n\")\n  }\n example\n  treeTable\n   row\n    name Javascript\n    example\n     console.log(\"Hello world\")\n   row\n    name Python\n    example\n     print \"Hello world\"\nabstractAftertextAttributeNode\n cells keywordCell\n boolean isAttributeNode true\n javascript\n  get divAttributes() {\n   return `${this.getWord(0)}=\"${this.getContent()}\"`\n  }\n  compile() {\n   return \"\"\n  }\naftertextIdNode\n crux id\n description Provide an ID to be output in the generated HTML paragraph.\n extends abstractAftertextAttributeNode\n cells keywordCell htmlIdCell\n single\nabstractAftertextDirectiveNode\n cells keywordCell\n catchAllCellType stringCell\n javascript\n  isMarkupNode = true\n  get pattern() {\n   return this.getWordsFrom(1).join(\" \")\n  }\n  get shouldMatchAll() {\n   return this.has(\"matchAll\")\n  }\n  getMatches(text) {\n   const { pattern } = this\n   const escapedPattern = pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\")\n   return [...text.matchAll(new RegExp(escapedPattern, \"g\"))].map(match => {\n    const { index } = match\n    const endIndex = index + pattern.length\n    return [\n     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },\n     { index: endIndex, endIndex, string: `</${this.closeTag}>` }\n    ]\n   })\n  }\n  getInserts(text) {\n   const matches = this.getMatches(text)\n   if (!matches.length) return false\n   if (this.shouldMatchAll) return matches.flat()\n   const indexNode = this.getNode(\"match\")\n   if (indexNode)\n    return indexNode.indexes\n     .map(index => matches[index])\n     .filter(i => i)\n     .flat()\n   return matches[0]\n  }\n  get allAttributes() {\n   const attr = this.attributes.join(\" \")\n   return attr ? \" \" + attr : \"\"\n  }\n  get attributes() {\n   return []\n  }\n  get openTag() {\n   return this.tag\n  }\n  get closeTag() {\n   return this.tag\n  }\nabstractMarkupNode\n extends abstractAftertextDirectiveNode\n inScope abstractMarkupParameterNode\nboldNode\n cruxFromId\n extends abstractMarkupNode\n javascript\n  tag = \"b\"\nitalicsNode\n cruxFromId\n extends abstractMarkupNode\n javascript\n  tag = \"i\"\nunderlineNode\n cruxFromId\n extends abstractMarkupNode\n javascript\n  tag = \"u\"\naftertextCodeNode\n crux code\n extends abstractMarkupNode\n javascript\n  tag = \"code\"\nlinkNode\n extends abstractMarkupNode\n cells keywordCell urlCell\n inScope linkNoteNode\n cruxFromId\n javascript\n  tag = \"a\"\n  get link() {\n   return this.getWord(1)\n  }\n  get attributes() {\n   const attrs = [`href=\"${this.link}\"`]\n   const title = this.getNode(\"note\")\n   if (title) attrs.push(`title=\"${title.childrenToString().replace(/\\n/g, \" \")}\"`)\n   return attrs\n  }\n  get pattern() {\n   return this.getWordsFrom(2).join(\" \")\n  }\nemailLinkNode\n description A mailto link\n crux email\n extends linkNode\n javascript\n  get attributes() {\n   return [`href=\"mailto:${this.link}\"`]\n  }\nquickLinkNode\n pattern ^https\\:\n extends linkNode\n cells urlCell\n javascript\n  get link() {\n   return this.getWord(0)\n  }\n  get pattern() {\n   return this.getWordsFrom(1).join(\" \")\n  }\nclassMarkupNode\n description Add a span with a class name around matching text.\n extends abstractMarkupNode\n cells keywordCell classNameCell\n crux class\n javascript\n  tag = \"span\"\n  get className() {\n   return this.getWord(1)\n  }\n  get attributes() {\n   return [`class=\"${this.className}\"`]\n  }\n  get pattern() {\n   return this.getWordsFrom(2).join(\" \")\n  }\ncaveatNode\n description Add a caveat viewable on hover on matching text. When you want to be sure you've thoroughly addressed obvious concerns but ones that don't warrant to distract from the main argument of the text.\n cruxFromId\n extends classMarkupNode\n cells keywordCell\n javascript\n  get pattern() {\n   return this.getWordsFrom(1).join(\" \")\n  }\n  get attributes() {\n   return [`class=\"scrollCaveat\"`, `title=\"${this.caveatText}\"`]\n  }\n  get caveatText() {\n   return this.childrenToString().replace(/\\n/g, \" \")\n  }\nstrikethroughNode\n cruxFromId\n extends abstractMarkupNode\n javascript\n  tag = \"s\"\nwrapsOnNode\n cruxFromId\n description Enable `code`, *bold*, and _italics_ rules.\n extends abstractAftertextDirectiveNode\n javascript\n  get shouldMatchAll() {\n   return true\n  }\n  getMatches(text) {\n   return [this.runPattern(text, \"`\", \"code\"), this.runPattern(text, \"*\", \"strong\"), this.runPattern(text, \"_\", \"em\")].filter(i => i).flat()\n  }\n  runPattern(text, delimiter, tag, attributes = \"\") {\n   const escapedDelimiter = delimiter.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\")\n   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, \"g\")\n   const delimiterLength = delimiter.length\n   return [...text.matchAll(pattern)].map(match => {\n    const { index } = match\n    const endIndex = index + match[0].length\n    return [\n     { index, string: `<${tag + (attributes ? \" \" + attributes : \"\")}>`, endIndex, consumeStartCharacters: delimiterLength },\n     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }\n    ]\n   })\n  }\nwrapNode\n cruxFromId\n cells keywordCell delimiterCell tagOrUrlCell\n catchAllCellType htmlAttributesCell\n extends wrapsOnNode\n description Define a custom wrap, for example \"wrap _ em\" would support: _italics_.\n javascript\n  getMatches(text) {\n   try {\n    const delimiter = this.getWord(1)\n    const tag = this.getWord(2)\n    const attributes = this.getWordsFrom(3).join(\" \")\n    if (tag.startsWith(\"https:\")) return this.runPattern(text, delimiter, \"a\", `href=\"${tag}\"` + attributes)\n    return this.runPattern(text, delimiter, tag, attributes)\n   } catch (err) {\n    console.error(err)\n    return []\n   }\n   // Note: doubling up doesn't work because of the consumption characters.\n  }\ndatelineNode\n cruxFromId\n description Gives your paragraph a dateline like \"December 15, 2021 â€” The...\"\n extends abstractAftertextDirectiveNode\n javascript\n  getInserts() {\n   let day =\n    this.getContent() ||\n    this.getParent()\n     .getParent()\n     .get(\"date\")\n   if (!day) return false\n   try {\n    const dayjs = require(\"dayjs\")\n    day = dayjs(day).format(`MMMM D, YYYY`)\n   } catch (err) {\n    console.error(err)\n   }\n   return [{ index: 0, string: `<span class=\"scrollArticleDateComponent\">${day} â€” </span>` }]\n  }\nabstractMarkupParameterNode\n cells keywordCell\n cruxFromId\nmatchAllNode\n description Use this to match all occurrences of the text.\n extends abstractMarkupParameterNode\nmatchNode\n catchAllCellType integerCell\n description Use this to specify which index(es) to match.\n javascript\n  get indexes() {\n   return this.getWordsFrom(1).map(num => parseInt(num))\n  }\n example\n  aftertext\n   hello ello ello\n   bold ello\n    match 0 2\n extends abstractMarkupParameterNode\nlinkNoteNode\n description When you want to include more information than just the link to your reference.\n crux note\n cells keywordCell\n example\n  aftertext\n   This report showed the treatment had a big impact.\n  https://example.com/report This report.\n   note\n    The average growth in the treatment group was 14.2x higher than the control group.\n baseNodeType blobNode\n compiler\n  stringTemplate \ncatchAllParagraphNode\n description A catch all block. This may be removed in future versions.\n catchAllCellType stringCell\n baseNodeType errorNode\n compiler\n  stringTemplate <p class=\"scrollParagraphComponent\">{stringCell}</p>\nchatLineNode\n catchAllCellType anyCell\n catchAllNodeType chatLineNode\nlineOfCodeNode\n catchAllCellType codeCell\n catchAllNodeType lineOfCodeNode\ncommentLineNode\n catchAllCellType commentCell\ncssLineNode\n catchAllCellType anyCell\n catchAllNodeType cssLineNode\nmultilineTitleNode\n catchAllCellType stringCell\nhtmlLineNode\n catchAllCellType anyCell\n catchAllNodeType htmlLineNode\nimageCaptionNode\n description An optional caption to accompany the image.\n crux caption\n cells keywordCell\n catchAllCellType stringCell\nstumpNode\n description Stump is a Tree Language that compiles to HTML.\n catchAllCellType anyCell\n catchAllNodeType stumpNode\nlistItemNode\n cells bulletPointCell\n catchAllCellType stringCell\n javascript\n  compile() {\n   return `<li>${this.getRootNode().compileATags(this.getContent() || \"\")}</li>`\n  }\nparagraphContentNode\n catchAllCellType stringCell\nerrorNode\n baseNodeType errorNode\nblankLineNode\n description Blank lines compile to nothing in the HTML.\n cells blankCell\n compiler\n  stringTemplate \n pattern ^$\n tags doNotSynthesize\nquoteLineNode\n catchAllCellType anyCell\n catchAllNodeType quoteLineNode\nscrolldownNode\n extensions scroll\n description A simple language for structurable thought. An extensible alternative to Markdown. Compiles to HTML.\n root\n inScope abstractScrollNode blankLineNode\n catchAllNodeType catchAllParagraphNode\n compilesTo html\n javascript\n  get permalink() {\n   return this.get(\"permalink\") || this._permalink || \"\"\n  }\n  setPermalink(permalink) {\n   this._permalink = permalink\n   return this\n  }\n  get folder() {\n   return this._folder || \"\"\n  }\n  setFolder(folder) {\n   this._folder = folder\n   return this\n  }\n  compileATags(text) {\n   // todo: a better place for these util functions? I stick them in here so the\n   // grammar is all in one file for ease of use in TreeLanguageDesigner\n   const linkReplacer = (match, p1, p2, p3, offset, str) => {\n    let suffix = \"\"\n    if (p3.endsWith(\",\")) suffix = \",\" + suffix\n    if (p3.endsWith(\".\")) suffix = \".\" + suffix\n    p3 = p3.replace(/(,|\\.)$/, \"\")\n    let prefix = \"https://\"\n    const isRelativeLink = p3.startsWith(\"./\")\n    if (isRelativeLink) {\n     prefix = \"\"\n     p3 = p3.substr(2)\n    }\n    if (p3.startsWith(\"https://\") || p3.startsWith(\"http://\")) prefix = \"\"\n    return `${p1}<a href=\"${prefix}${p3}\">${p2}</a>${suffix}`\n   }\n   return text.replace(/(^|\\s)(\\S+)ðŸ”—(\\S+)(?=(\\s|$))/g, linkReplacer)\n  }\n example\n  title Hello world\n  section This is Scrolldown\n  \n  paragraph\n   It compiles to HTML. Blank lines get turned into brs.\n  \n  code\n   // You can add code as well.\n   print(\"Hello world\")\nrowNode\n catchAllCellType stringCell\n javascript\n  toRow(columns, delimiter) {\n   const words = this.getLine().split(delimiter)\n   let str = \"\"\n   let column = 0\n   const columnCount = columns.length\n   while (column < columnCount) {\n    const col = columns[column]\n    column++\n    const content = columnCount === column ? words.slice(columnCount - 1).join(\" \") : words[column - 1]\n    if (col.isLink) continue\n    let tagged = \"\"\n    const link = words[col.linkIndex]\n    if (col.linkIndex > -1 && link) tagged = `<a href=\"${link}\">${content}</a>`\n    else tagged = this.getRootNode().compileATags(content ?? \"\")\n    str += `<td>${tagged}</td>\\n`\n   }\n   return str\n  }\ntreeRowContentNode\n description Any blob content in a cell.\n cells stringCell\n catchAllCellType stringCell\ntreeRowColumnNode\n catchAllNodeType treeRowContentNode\n description A columnName value pair, or just a columnName if the value is a text blob.\n cells idCell\n catchAllCellType stringCell\ntreeRowNode\n cells idCell\n description The root node of a row.\n catchAllNodeType treeRowColumnNode\n javascript\n  toRow(columns) {\n   let str = \"\"\n   columns.forEach(col => {\n    const node = this.getNode(col.name)\n    if (col.isLink) return\n    if (!node) {\n     str += \"<td></td>\\n\"\n     return\n    }\n    const content = node.length ? node.childrenToString() : node.getContent()\n    let tagged = \"\"\n    const link = columns[col.linkIndex]\n    if (col.linkIndex > -1 && link) tagged = `<a href=\"${link}\">${content}</a>`\n    else if (node.length) tagged = `<pre>${content ?? \"\"}</pre>`\n    else tagged = content ?? \"\"\n    str += `<td>${tagged}</td>\\n`\n   })\n   return str\n  }","style":"html,\nbody,\ndiv,\nspan,\nh1,\nh2,\nh3,\nh4,\np,\nol,\nul,\ntable,\nfigure {\n\tmargin: 0;\n\tpadding: 0;\n\tborder: 0;\n\tvertical-align: baseline;\n\tborder-spacing: 0;\n}\nhtml {\n\tbackground-color: rgb(244, 244, 244);\n\tfont-family: Exchange, Georgia, serif;\n\tcolor: #000;\n\tfont-size: 14px;\n\thyphens: auto;\n}\n.scrollHeaderComponent {\n\tborder-bottom: 1px solid rgb(204, 204, 204);\n\ttext-align: center;\n\tpadding-bottom: 8px;\n}\n.scrollNameComponent a {\n\ttext-decoration: none;\n\tcolor: #000;\n}\n.scrollTopRightBarComponent {\n\ttext-align: right;\n\tposition: absolute;\n\tright: 25px;\n\ttop: 3px;\n}\n.scrollSocialMediaIconsComponent svg {\n\twidth: 30px;\n\tfill: rgba(204, 204, 204, 0.5);\n\tmargin-left: 15px;\n}\n.scrollSocialMediaIconsComponent svg:hover {\n\tfill: #333;\n}\n.scrollFooterComponent {\n\tborder-top: 1px solid rgb(204, 204, 204);\n\tmargin-top: 8px;\n\tpadding-top: 8px;\n\ttext-align: center;\n}\n.scrollCommunityLinkComponent {\n\tdisplay: block;\n\tfont-family: Verdana;\n\tfont-weight: 100;\n\tmargin: 0.5em;\n\tpadding-bottom: 1em;\n\ttext-decoration: none;\n\tcolor: rgba(204, 204, 204, 0.5);\n}\n.scrollIndexPageComponent,\n.scrollArticlePageComponent {\n\tcolumn-count: auto;\n\tcolumn-fill: balance;\n\tcolumn-width: 35ch;\n\tcolumn-gap: 20px;\n\tcolumn-rule: 1px solid rgb(204, 204, 204);\n\tpadding-left: 20px;\n\tpadding-right: 20px;\n\tmargin: auto;\n}\n.scrollArticlePageComponent {\n\tcolumn-rule: none;\n\tpadding-top: 8px;\n}\n.scrollIndexPageArticleContainerComponent {\n\tborder-bottom: 1px solid rgb(204, 204, 204);\n\tpadding: 1ch 0;\n\tbreak-inside: avoid;\n\ttext-align: justify;\n\tmargin-bottom: 0.5em;\n}\n.scrollTitleComponent {\n\ttext-align: center;\n\tfont-size: 24px;\n\tmargin-bottom: 0.25em;\n}\n.scrollTitleComponent a {\n\ttext-decoration: none;\n\tcolor: #000;\n}\n.scrollArticleDateComponent {\n\tfont-style: italic;\n\tfont-size: 80%;\n}\n.scrollParagraphComponent {\n\tmargin-top: 0.4em;\n\tline-height: 1.4em;\n}\n.scrollQuoteComponent {\n\tbreak-inside: avoid;\n\tdisplay: block;\n\tmargin: 0.5em 0;\n\tpadding: 0.5em;\n\tbackground: rgba(204, 204, 204, 0.5);\n\twhite-space: pre-line;\n\tborder-left: 0.5em solid rgba(204, 204, 204, 0.8);\n}\n.scrollSectionComponent,\n.scrollSubsectionComponent {\n\ttext-align: center;\n\tmargin-top: 1em;\n}\n.scrollQuestionComponent {\n\ttext-align: left;\n\tmargin-top: 2em;\n}\ncode {\n\tfont-size: 90%;\n\tbackground-color: rgba(204, 204, 204, 0.5);\n\tpadding: 2px 4px;\n\tborder-radius: 4px;\n}\n.scrollCodeBlockComponent {\n\toverflow: auto;\n\tfont-size: 80%;\n\thyphens: none;\n\twhite-space: pre;\n\tborder-left: 0.5em solid rgba(204, 204, 204, 0.8);\n\tbreak-inside: avoid;\n\tdisplay: block;\n\tmargin: 0.5em 0;\n\tpadding: 0.5em;\n\tborder-radius: 0;\n}\n.scrollTableComponent {\n\ttable-layout: fixed;\n\tmargin: 0.5em 0;\n\toverflow: hidden;\n\tfont-size: 80%;\n\twidth: 100%;\n\thyphens: none;\n\tborder: 1px solid rgba(224, 224, 224, 0.8);\n}\n.scrollTableComponent td,\n.scrollTableComponent th {\n\tpadding: 3px;\n\toverflow: hidden;\n}\n.scrollTableComponent th {\n\tborder-bottom: 2px solid rgba(0, 0, 0, 0.6);\n\ttext-align: left;\n}\n.scrollTableComponent tr:nth-child(even) {\n\tbackground: rgba(224, 224, 224, 0.6);\n}\n.scrollUnorderedListComponent,\n.scrollOrderedListComponent {\n\ttext-align: left;\n\tline-height: 1.4em;\n\tpadding-left: 1em;\n\tmargin-top: 0.4em;\n}\n.scrollArticleSourceLinkComponent {\n\ttext-align: center;\n\tfont-size: 80%;\n\tmargin: 0;\n\tmargin-top: 0.4em;\n\tline-height: 1.4em;\n}\n.scrollArticleSourceLinkComponent a {\n\tcolor: #000;\n\ttext-decoration: none;\n}\n.scrollDialogueComponent span {\n\tfont-family: Verdana;\n\tmargin-top: 5px;\n\tpadding: 5px 20px;\n\tborder-radius: 15px;\n\tdisplay: inline-block;\n}\n.scrollDialogueComponentLeft {\n\ttext-align: left;\n}\n.scrollDialogueComponentLeft span {\n\tbackground: rgba(204, 204, 204, 0.5);\n}\n.scrollDialogueComponentRight {\n\ttext-align: right;\n}\n.scrollDialogueComponentRight span {\n\tcolor: white;\n\tbackground: rgb(0, 132, 255);\n}\n.scrollImageComponent {\n\tdisplay: block;\n\ttext-align: center;\n}\n.scrollImageComponent img {\n\tmax-width: 35ch;\n\theight: auto;\n}\n.scrollImageComponent figcaption {\n\tfont-style: italic;\n}\n.scrollCaveat {\n\ttext-decoration: underline dashed 1px rgba(0, 0, 0, 0.1);\n\tcursor: default;\n}\n"}