const AppConstants = {"parsers":"blankAtom\nanyAtom\nenumAtom\n paint constant.language\nbooleanAtom\n enum true false\n extends enumAtom\nstringAtom\n paint string\natomAtom\n paint string\n description A non-empty single atom string.\n regex .+\ncolumnNameAtom\n extends stringAtom\nsemanticVersionAtom\n paint string\n description A 3 part sem version string like 1.2.1\ndateAtom\n paint string\nnumberAtom\n paint constant.numeric\nintegerAtom\n extends numberAtom\n paint constant.numeric.integer\nfloatAtom\n extends numberAtom\n paint constant.numeric.float\npercentAtom\n paint constant.numeric.float\n extends stringAtom\n // todo: this currently extends from stringAtom b/c scrollsdk needs to be fixed. seems like if extending from number then the hard coded number typescript regex takes precedence over a custom regex\ncountAtom\n extends integerAtom\nyearAtom\n extends integerAtom\ncueAtom\n description A atom that indicates a certain parser to use.\n paint keyword\npreBuildCommandAtom\n extends cueAtom\n description Give build command atoms their own color.\n paint constant.character.escape\ncommentAtom\n paint comment\ndelimiterAtom\n description String to use as a delimiter.\n paint string\ncodeAtom\n paint comment\nbulletPointAtom\n description Any token used as a bullet point such as \"-\" or \"1.\" or \">\"\n paint keyword\ncomparisonAtom\n enum < > <= >= = != includes doesNotInclude empty notEmpty\n paint constant\npersonNameAtom\n extends stringAtom\nurlAtom\n paint constant.language\nabsoluteUrlAtom\n paint constant.language\n regex (ftp|https?)://.+\nemailAddressAtom\n extends stringAtom\npermalinkAtom\n paint string\n description A string that doesn't contain characters that might interfere with most filesystems. No slashes, for instance.\nfilePathAtom\n extends stringAtom\ntagOrUrlAtom\n description An HTML tag or a url.\n paint constant.language\nhtmlAttributesAtom\n paint comment\nhtmlTagAtom\n paint constant.language\n enum div span p a img ul ol li h1 h2 h3 h4 h5 h6 header nav section article aside main footer input button form label select option textarea table tr td th tbody thead tfoot br hr meta link script style title code\nclassNameAtom\n paint constant\nhtmlIdAtom\n extends anyAtom\nbuildCommandAtom\n extends cueAtom\n description Give build command atoms their own color.\n paint constant\ncssAnyAtom\n extends anyAtom\ncssLengthAtom\n extends anyAtom\nhtmlAnyAtom\n extends stringAtom\ninlineMarkupNameAtom\n description Options to turn on some inline markups.\n enum bold italics code katex none\ntileOptionAtom\n enum default light\nmeasureNameAtom\n extends cueAtom\n // A regex for column names for max compatibility with a broad range of data science tools:\n regex [a-zA-Z][a-zA-Z0-9]*\njavascriptAtom\n extends stringAtom\nmetaCommandAtom\n extends cueAtom\n description Give meta command atoms their own color.\n paint constant.numeric\n // Obviously this is not numeric. But I like the green color for now.\n   We need a better design to replace this \"paint\" concept\n   https://github.com/breck7/scrollsdk/issues/186\nscriptAnyAtom\n extends anyAtom\ntagAtom\n extends permalinkAtom\ntagWithOptionalFolderAtom\n description A group name optionally combined with a folder path. Only used when referencing tags, not in posts.\n extends stringAtom\nscrollThemeAtom\n enum roboto gazette dark tufte\n paint constant\nabstractScrollParser\n atoms cueAtom\n javascript\n  compileEmbeddedVersion(compileSettings) {\n   return this.compile(compileSettings)\n  }\n  compileTxt() {\n    return \"\"\n  }\n  getHtmlRequirements(compileSettings) {\n    const {requireOnce} = this\n    if (!requireOnce)\n      return \"\"\n    const set = compileSettings?.alreadyRequired || this.root.alreadyRequired\n    if (set.has(requireOnce))\n      return \"\"\n    \n    set.add(requireOnce)\n    return requireOnce + \"\\n\\n\"\n  }\nabstractAftertextParser\n description Text followed by markup commands.\n extends abstractScrollParser\n inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser aftertextTagParser commentParser\n javascript\n  get markupInserts() {\n   const { originalTextPostLinkify } = this\n   return this.filter(particle => particle.isMarkup)\n    .map(particle => particle.getInserts(originalTextPostLinkify))\n    .filter(i => i)\n    .flat()\n  }\n  get originalText() {\n   return this.content ?? \"\"\n  }\n  get originalTextPostLinkify() {\n   const { originalText } = this\n   const shouldLinkify = this.get(\"linkify\") === \"false\" || originalText.includes(\"<a \") ? false : true\n   return shouldLinkify ? this.replaceNotes(Utils.linkify(originalText)) : originalText\n  }\n  replaceNotes(originalText) {\n   // Skip the replacements if there are no footnotes or the text has none.\n   if (!this.root.footnotes.length || !originalText.includes(\"^\")) return originalText\n   this.root.footnotes.forEach((note, index) => {\n    const needle = note.cue\n    const {linkBack} = note\n    if (originalText.includes(needle)) originalText = originalText.replace(new RegExp(\"\\\\\" + needle + \"\\\\b\"), `<a href=\"#${note.htmlId}\" class=\"scrollNoteLink\" id=\"${linkBack}\"><sup>${note.label}</sup></a>`)\n   })\n   return originalText\n  }\n  get text() {\n   const { originalTextPostLinkify, markupInserts } = this\n   let adjustment = 0\n   let newText = originalTextPostLinkify\n   markupInserts.sort((a, b) => {\n     if (a.index !== b.index)\n       return a.index - b.index\n     // If multiple tags start at same index, the tag that closes first should start last. Otherwise HTML breaks.\n     if (b.index === b.endIndex) // unless the endIndex is the same as index\n       return a.endIndex - b.endIndex\n     return b.endIndex - a.endIndex\n   })\n   markupInserts.forEach(insertion => {\n    insertion.index += adjustment\n    const consumeStartCharacters = insertion.consumeStartCharacters ?? 0\n    const consumeEndCharacters = insertion.consumeEndCharacters ?? 0\n    newText = newText.slice(0, insertion.index - consumeEndCharacters) + insertion.string + newText.slice(insertion.index + consumeStartCharacters)\n    adjustment += insertion.string.length - consumeEndCharacters - consumeStartCharacters\n   })\n   return newText\n  }\n  tag = \"p\"\n  get className() {\n   if (this.get(\"classes\"))\n     return this.get(\"classes\")\n   const classLine = this.getParticle(\"class\")\n   if (classLine && classLine.applyToParentElement) return classLine.content\n   return this.defaultClassName\n  }\n  defaultClassName = \"scrollParagraph\"\n  get isHidden() {\n    return this.has(\"hidden\")\n  }\n  compile(compileSettings) {\n   if (this.isHidden) return \"\"\n   this.compileSettings = compileSettings\n   const { className } = this\n   const classAttr = className ? `class=\"${this.className}\"` : \"\"\n   const tag = this.get(\"tag\") || this.tag\n   if (tag === \"none\") // Allow no tag for aftertext in tables\n     return this.text\n   const id = this.has(\"id\") ? \"\" : `id=\"${this.htmlId}\" ` // always add an html id\n   return this.getHtmlRequirements(compileSettings) + `<${tag} ${id}${this.htmlAttributes}${classAttr}>${this.text}</${tag}>`\n  }\n  get htmlAttributes() {\n   const attrs = this.filter(particle => particle.isAttribute)\n   return attrs.length ? attrs.map(particle => particle.htmlAttributes).join(\" \") + \" \" : \"\"\n  }\n  get htmlId() {\n   return this.get(\"id\") || \"particle\" + this.index\n  }\nparagraphParser\n // todo Perhaps rewrite this from scratch and move out of aftertext.\n extends abstractAftertextParser\n catchAllAtomType stringAtom\n description A paragraph.\n boolean suggestInAutocomplete false\n cueFromId\n javascript\n  compile(compileSettings) {\n   if (this.isHidden) return \"\"\n   // Hacky, I know.\n   const newLine = this.has(\"inlineMarkupsOn\") ? undefined : this.appendLine(\"inlineMarkupsOn\")\n   const compiled = super.compile(compileSettings)\n   if (newLine)\n    newLine.destroy()\n   return compiled\n  }\n  compileTxt() {\n    const subparticles = this.filter(particle => particle.compileTxt).map(particle => particle.compileTxt()).filter(i => i).join(\"\\n\")\n    const dateline = this.getParticle(\"dateline\")\n    return (dateline ? dateline.day + \"\\n\\n\" : \"\") + (this.originalText || \"\") + (subparticles ? \"\\n \" + subparticles.replace(/\\n/g, \"\\n \") : \"\")\n  }\nauthorsParser\n popularity 0.007379\n // multiple authors delimited by \" and \"\n boolean isPopular true\n extends paragraphParser\n description Set author(s) name(s).\n example\n  authors Breck Yunits\n   https://breckyunits.com Breck Yunits\n // note: once we have mixins in Parsers, lets mixin the below from abstractTopLevelSingleMetaParser\n atoms metaCommandAtom\n javascript\n  isTopMatter = true\n  isSetterParser = true\n  compileHtmlForPrint() {\n    // hacky. todo: cleanup\n    const originalContent = this.content\n    this.setContent(`by ${originalContent}`)\n    const html = super.compile()\n    this.setContent(originalContent)\n    return html\n  }\n  compileTxtForPrint() {\n    return 'by ' + super.compileTxt()\n  }\n  compile() {\n   return \"\"\n  }\n  compileTxt() {\n    return \"\"\n  }\n  defaultClassName = \"scrollByLine\"\nblinkParser\n description Just for fun.\n extends paragraphParser\n example\n  blink Carpe diem!\n cue blink\n javascript\n  compile() {\n   return `<span class=\"scrollBlink\">${super.compile()}</span>\n    <script>setInterval(()=>{ Array.from(document.getElementsByClassName(\"scrollBlink\")).forEach(el => el.style.visibility = el.style.visibility === \"hidden\" ? \"visible\" : \"hidden\") }, 500)</script>`\n  }\nscrollButtonParser\n extends paragraphParser\n cue button\n description A button.\n example\n  button Click me\n javascript\n  defaultClassName = \"scrollButton\"\n  tag = \"button\"\n  get htmlAttributes() {\n    const link = this.getFromParser(\"linkParser\")\n    return super.htmlAttributes + link ? `onclick=\"window.location='${link.link}'\"` : \"\" // better ideas?\n  }\n  getFromParser(parserId) {\n    return this.find(particle => particle.doesExtend(parserId))\n  }\ncatchAllParagraphParser\n popularity 0.115562\n description A paragraph.\n extends paragraphParser\n boolean suggestInAutocomplete false\n boolean isPopular true\n boolean isArticleContent true\n atoms stringAtom\n javascript\n  getErrors() {\n    const errors = super.getErrors() || []\n    return this.parent.has(\"testStrict\") ? errors.concat(this.makeError(`catchAllParagraphParser should not have any matches when testing with testStrict.`)) : errors\n  }\n  get originalText() {\n   return this.getLine() || \"\"\n  }\nscrollCenterParser\n popularity 0.006415\n cue center\n description A centered section.\n extends paragraphParser\n example\n  center\n  This paragraph is centered.\n javascript\n  compile() {\n   this.parent.sectionStack.push(\"</center>\")\n   return `<center>${super.compile()}`\n  }\n  compileTxt() {\n    return this.content\n  }\nabstractIndentableParagraphParser\n extends paragraphParser\n inScope abstractAftertextDirectiveParser abstractAftertextAttributeParser abstractIndentableParagraphParser\n javascript\n  compileSubparticles() {\n    return this.map(particle => particle.compile())\n     .join(\"\\n\")\n     .trim()\n  }\n  compile() {\n   return super.compile() + this.compileSubparticles()\n  }\n  compileTxt() {\n    return this.getAtom(0) + \" \" + super.compileTxt()\n  }\nchecklistTodoParser\n popularity 0.000193\n extends abstractIndentableParagraphParser\n example\n  [] Get milk\n description A task todo.\n cue []\n string checked \n javascript\n  get text() {\n   return `<div style=\"text-indent:${(this.getIndentLevel() - 1) * 20}px;\"><input type=\"checkbox\" ${this.checked} id=\"${this.id}\"><label for=\"${this.id}\">` + super.text + `</label></div>`\n  }\n  get id() {\n   return this.get(\"id\") || \"item\" + this._getUid()\n  }\nchecklistDoneParser\n popularity 0.000072\n extends checklistTodoParser\n description A completed task.\n string checked checked\n cue [x]\n example\n  [x] get milk\nlistAftertextParser\n popularity 0.014325\n extends abstractIndentableParagraphParser\n example\n  - I had a _new_ thought.\n description A list item.\n cue -\n javascript\n  defaultClassName = \"\"\n  compile() {\n   const {index, parent} = this\n   const particleClass = this.constructor\n   const isStartOfList = index === 0 || !(parent.particleAt(index - 1) instanceof particleClass)\n   const isEndOfList = parent.length === index + 1 || !(parent.particleAt(index + 1) instanceof particleClass)\n   const { listType } = this\n   return (isStartOfList ? `<${listType} ${this.attributes}>` : \"\") + `${super.compile()}` + (isEndOfList ? `</${listType}>` : \"\")\n  }\n  get attributes() {\n    return \"\"\n  }\n  tag = \"li\"\n  listType = \"ul\"\nabstractCustomListItemParser\n extends listAftertextParser\n javascript\n  get requireOnce() {\n    return `<style>\\n.${this.constructor.name} li::marker {content: \"${this.cue} \";}\\n</style>`\n  }\n  get attributes() {\n    return `class=\"${this.constructor.name}\"`\n  }\norderedListAftertextParser\n popularity 0.004485\n extends listAftertextParser\n description A list item.\n example\n  1. Hello world\n pattern ^\\d+\\. \n javascript\n  listType = \"ol\"\n  get attributes() { return ` start=\"${this.getAtom(0)}\"`}\nquickQuoteParser\n popularity 0.000482\n cue >\n example\n  > The only thing we have to fear is fear itself. - FDR\n boolean isPopular true\n extends abstractIndentableParagraphParser\n description A quote.\n javascript\n  defaultClassName = \"scrollQuote\"\n  tag = \"blockquote\"\nscrollCounterParser\n description Visualize the speed of something.\n extends paragraphParser\n cue counter\n example\n  counter 4.5 Babies Born\n atoms cueAtom numberAtom\n javascript\n  compile() {\n   const line = this.getLine()\n   const atoms = line.split(\" \")\n   atoms.shift() // drop the counter atom\n   const perSecond = parseFloat(atoms.shift()) // get number\n   const increment = perSecond/10\n   const id = this._getUid()\n   this.setLine(`* <span id=\"counter${id}\" title=\"0\">0</span><script>setInterval(()=>{ const el = document.getElementById('counter${id}'); el.title = parseFloat(el.title) + ${increment}; el.textContent = Math.floor(parseFloat(el.title)).toLocaleString()}, 100)</script> ` + atoms.join(\" \"))\n   const html = super.compile()\n   this.setLine(line)\n   return html\n  }\nexpanderParser\n popularity 0.000072\n cueFromId\n description An collapsible HTML details tag.\n extends paragraphParser\n example\n  expander Knock Knock\n  Who's there?\n javascript\n  compile() {\n   this.parent.sectionStack.push(\"</details>\")\n   return `<details>${super.compile()}`\n  }\n  compileTxt() {\n    return this.content\n  }\n  tag = \"summary\"\n  defaultClassName = \"\"\nfootnoteDefinitionParser\n popularity 0.001953\n description A footnote. Can also be used as section notes.\n extends paragraphParser\n boolean isFootnote true\n pattern ^\\^.+$\n // We need to quickLinks back in scope because there is currently a bug in ScrollSDK/parsers where if a parser extending a parent class has a child parser defined, then any regex parsers in the parent class will not be tested unless explicitly included in scope again.\n inScope quickLinkParser\n labelParser\n  description If you want to show a custom label for a footnote. Default label is the note definition index.\n  cueFromId\n  atoms cueAtom\n  catchAllAtomType stringAtom\n javascript\n  get htmlId() {\n   return `note${this.noteDefinitionIndex}`\n  }\n  get label() {\n   // In the future we could allow common practices like author name\n   return this.get(\"label\") || `[${this.noteDefinitionIndex}]`\n  }\n  get linkBack() {\n   return `noteUsage${this.noteDefinitionIndex}`\n  }\n  get text() {\n   return `<a class=\"scrollFootNoteUsageLink\" href=\"#noteUsage${this.noteDefinitionIndex}\">${this.label}</a> ${super.text}`\n  }\n  get noteDefinitionIndex() {\n   return this.parent.footnotes.indexOf(this) + 1\n  }\n  compileTxt() {\n    return this.getAtom(0) + \": \" + super.compileTxt()\n  }\nabstractHeaderParser\n extends paragraphParser\n example\n  # Hello world\n javascript\n  compile(compileSettings) {\n   if (this.isHidden) return \"\"\n   if (this.parent.sectionStack)\n    this.parent.sectionStack.push(\"</div>\")\n   return `<div class=\"scrollSection\">` + super.compile(compileSettings)\n  }\n  compileTxt() {\n    const line = super.compileTxt()\n    return line + \"\\n\" + \"=\".repeat(line.length)\n  }\n  isHeader = true\nh1Parser\n popularity 0.017918\n description An html h1 tag.\n extends abstractHeaderParser\n boolean isArticleContent true\n cue #\n boolean isPopular true\n javascript\n  tag = \"h1\"\nh2Parser\n popularity 0.005257\n description An html h2 tag.\n extends abstractHeaderParser\n boolean isArticleContent true\n cue ##\n boolean isPopular true\n javascript\n  tag = \"h2\"\nh3Parser\n popularity 0.001085\n description An html h3 tag.\n extends abstractHeaderParser\n boolean isArticleContent true\n cue ###\n javascript\n  tag = \"h3\"\nh4Parser\n popularity 0.000289\n description An html h4 tag.\n extends abstractHeaderParser\n cue ####\n javascript\n  tag = \"h4\"\nscrollQuestionParser\n popularity 0.004244\n description A question.\n extends h4Parser\n cue ?\n example\n  ? Why is the sky blue?\n javascript\n  defaultClassName = \"scrollQuestion\"\nh5Parser\n description An html h5 tag.\n extends abstractHeaderParser\n cue #####\n javascript\n  tag = \"h5\"\nprintTitleParser\n popularity 0.007572\n description Print title.\n extends abstractHeaderParser\n boolean isPopular true\n example\n  title Eureka\n  printTitle\n cueFromId\n javascript\n  compile(compileSettings) {\n   // Hacky, I know.\n   const {content} = this\n   if (content === undefined)\n    this.setContent(this.root.title)\n   const { permalink } = this.root\n   if (!permalink) {\n    this.setContent(content) // Restore it as it was.\n    return super.compile(compileSettings)\n   }\n   const newLine = this.appendLine(`link ${permalink}`)\n   const compiled = super.compile(compileSettings)\n   newLine.destroy()\n   this.setContent(content) // Restore it as it was.\n   return compiled\n  }\n  get originalText() {\n   return this.content ?? this.root.title ?? \"\"\n  }\n  defaultClassName = \"scrollTitle\"\n  tag = \"h1\"\ncaptionAftertextParser\n popularity 0.003207\n description An image caption.\n cue caption\n extends paragraphParser\n boolean isPopular true\nabstractMediaParser\n extends paragraphParser\n inScope scrollMediaLoopParser scrollAutoplayParser\n int atomIndex 1\n javascript\n  compileTxt() {\n    return \"\"\n  }\n  get filename() {\n    return this.getAtom(this.atomIndex)\n  }\n  getAsHtmlAttribute(attr) {\n    if (!this.has(attr)) return \"\"\n    const value = this.get(attr)\n    return value ? `${attr}=\"${value}\"` : attr\n  }\n  getAsHtmlAttributes(list) {\n    return list.map(atom => this.getAsHtmlAttribute(atom)).filter(i => i).join(\" \")\n  }\n  compile() {\n    return `<${this.tag} src=\"${this.filename}\" controls ${this.getAsHtmlAttributes(\"width height loop autoplay\".split(\" \"))}></${this.tag}>`\n  }\nscrollMusicParser\n popularity 0.000024\n extends abstractMediaParser\n cue music\n description Play sound files.\n example\n  music sipOfCoffee.m4a\n javascript\n  compile() {\n    return `<audio controls ${this.getAsHtmlAttributes(\"loop autoplay\".split(\" \"))}><source src=\"${this.filename}\" type=\"audio/mpeg\"></audio>`\n  }\nquickSoundParser\n popularity 0.000024\n extends scrollMusicParser\n atoms urlAtom\n pattern ^[^\\s]+\\.(mp3|wav|ogg|aac|m4a|flac)\n int atomIndex 0\nscrollVideoParser\n popularity 0.000024\n extends abstractMediaParser\n cue video\n example\n  video spirit.mp4\n description Play video files.\n widthParser\n  cueFromId\n  atoms cueAtom\n heightParser\n  cueFromId\n  atoms cueAtom\n javascript\n  tag = \"video\"\nquickVideoParser\n popularity 0.000024\n extends scrollVideoParser\n atoms urlAtom\n pattern ^[^\\s]+\\.(mp4|webm|avi|mov)\n int atomIndex 0\nquickParagraphParser\n popularity 0.001881\n cue *\n extends paragraphParser\n description A paragraph.\n boolean isArticleContent true\n example\n  * I had a _new_ idea.\nscrollStopwatchParser\n description A stopwatch.\n extends paragraphParser\n cue stopwatch\n example\n  stopwatch\n atoms cueAtom\n catchAllAtomType numberAtom\n javascript\n  compile() {\n   const line = this.getLine()\n   const id = this._getUid()\n   this.setLine(`* <span class=\"scrollStopwatchParser\" id=\"stopwatch${id}\">0.0</span><script>{let startTime = parseFloat(new URLSearchParams(window.location.search).get('start') || 0); document.getElementById('stopwatch${id}').title = startTime; setInterval(()=>{ const el = document.getElementById('stopwatch${id}'); el.title = parseFloat(el.title) + .1; el.textContent = (parseFloat(el.title)).toFixed(1)}, 100)}</script> `)\n   const html = super.compile()\n   this.setLine(line)\n   return html\n  }\nthinColumnsParser\n popularity 0.003690\n extends abstractAftertextParser\n cueFromId\n catchAllAtomType integerAtom\n description Thin columns.\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  columnWidth = 35\n  columnGap = 20\n  compile() {\n   const {columnWidth, columnGap, maxColumns} = this\n   const maxTotalWidth = maxColumns * columnWidth + (maxColumns - 1) * columnGap\n   const stackContents = this.parent.clearSectionStack() // Starting columns always first clears the section stack.\n   if (this.singleColumn) this.parent.sectionStack.push(\"</div>\") // Single columns are self-closing after section break.\n   return stackContents + `<div class=\"scrollColumns\" style=\"column-width:${columnWidth}ch;column-count:${maxColumns};max-width:${maxTotalWidth}ch;\">`\n  }\n  get maxColumns() {\n    return this.singleColumn ? 1 : parseInt(this.getAtom(1) ?? 10)\n  }\nwideColumnsParser\n popularity 0.000386\n extends thinColumnsParser\n description Wide columns.\n javascript\n  columnWidth = 90\nwideColumnParser\n popularity 0.003376\n extends wideColumnsParser\n description A wide column section.\n boolean singleColumn true\nmediumColumnsParser\n popularity 0.003376\n extends thinColumnsParser\n description Medium width columns.\n javascript\n  columnWidth = 65\nmediumColumnParser\n popularity 0.003376\n extends mediumColumnsParser\n description A medium column section.\n boolean singleColumn true\nthinColumnParser\n popularity 0.003376\n extends thinColumnsParser\n description A thin column section.\n boolean singleColumn true\nendColumnsParser\n popularity 0.007789\n extends abstractAftertextParser\n cueFromId\n description End columns.\n javascript\n  compile() {\n   return \"</div>\"\n  }\n  compileEmbeddedVersion() {\n   return \"\"\n  }\nabstractDinkusParser\n extends abstractAftertextParser\n boolean isDinkus true\n javascript\n  compile() {\n   return `<div class=\"${this.defaultClass}\"><span>${this.dinkus}</span></div>`\n  }\n  defaultClass = \"dinkus\"\n  compileTxt() {\n    return this.dinkus\n  }\n  get dinkus() {\n    return this.content || this.getLine()\n  }\nhorizontalRuleParser\n popularity 0.000362\n cue ---\n description A horizontal rule.\n extends abstractDinkusParser\n javascript\n  compile() {\n   return `<hr>`\n  }\nscrollDinkusParser\n popularity 0.010828\n cue ***\n description A dinkus. Breaks section.\n boolean isPopular true\n extends abstractDinkusParser\n javascript\n  dinkus = \"*\"\ncustomDinkusParser\n cue dinkus\n description A custom dinkus.\n extends abstractDinkusParser\nendOfPostDinkusParser\n popularity 0.005740\n extends abstractDinkusParser\n description End of post dinkus.\n boolean isPopular true\n cue ****\n javascript\n  dinkus = \"⁂\"\nabstractIconButtonParser\n extends abstractAftertextParser\n cueFromId\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n    return `<style>.abstractIconButtonParser {position:absolute;top:0.25rem; }.abstractIconButtonParser svg {fill: rgba(204,204,204,.8);width:1.875rem;height:1.875rem; padding: 0 7px;} .abstractIconButtonParser:hover svg{fill: #333;}</style><a href=\"${this.link}\" class=\"doNotPrint abstractIconButtonParser\" style=\"${this.style}\">${this.svg}</a>`\n  }\ndownloadButtonParser\n popularity 0.006294\n description Link to download/WWS page.\n extends abstractIconButtonParser\n catchAllAtomType urlAtom\n string style position:relative;\n string svg <svg fill=\"#000000\" xmlns=\"http://www.w3.org/2000/svg\" width=\"800px\" height=\"800px\" viewBox=\"0 0 52 52\" enable-background=\"new 0 0 52 52\" xml:space=\"preserve\"><path d=\"M38.6,20.4c-1-6.5-6.7-11.5-13.5-11.5c-7.6,0-13.7,6.1-13.7,13.7c0,0.3,0,0.7,0.1,1c-5,0.4-8.9,4.6-8.9,9.6 c0,5.4,4.3,9.7,9.7,9.7h11.5c-0.8-0.8-8.1-8.1-8.1-8.1c-0.4-0.4-0.4-0.9,0-1.3l1.3-1.3c0.4-0.4,0.9-0.4,1.3,0l3.5,3.5 c0.4,0.4,1.1,0.1,1.1-0.4V21.8c0-0.4,0.5-0.9,1-0.9h1.9c0.5,0,0.9,0.4,0.9,0.9v13.4c0,0.6,0.8,0.8,1.1,0.4l3.5-3.5 c0.4-0.4,0.9-0.4,1.3,0l1.3,1.3c0.4,0.4,0.4,0.9,0,1.3L26,42.9h12.3v0c6.1-0.1,11-5.1,11-11.3C49.4,25.5,44.6,20.6,38.6,20.4z\"/></svg><!-- Uploaded to: SVG Repo, www.svgrepo.com, Generator: SVG Repo Mixer Tools -->\n javascript\n  get link() {\n    return this.content\n  }\nemailButtonParser\n popularity 0.006294\n description Email button.\n extends abstractIconButtonParser\n catchAllAtomType emailAddressAtom\n // todo: should just be \"optionalAtomType\"\n string style position:relative;\n string svg <svg viewBox=\"3 5 24 20\" width=\"24\" height=\"20\" xmlns=\"http://www.w3.org/2000/svg\"><g transform=\"matrix(1, 0, 0, 1, 0, -289.0625)\"><path style=\"opacity:1;stroke:none;stroke-width:0.49999997;stroke-miterlimit:4;stroke-dasharray:none;stroke-opacity:1\" d=\"M 5 5 C 4.2955948 5 3.6803238 5.3628126 3.3242188 5.9101562 L 14.292969 16.878906 C 14.696939 17.282876 15.303061 17.282876 15.707031 16.878906 L 26.675781 5.9101562 C 26.319676 5.3628126 25.704405 5 25 5 L 5 5 z M 3 8.4140625 L 3 23 C 3 24.108 3.892 25 5 25 L 25 25 C 26.108 25 27 24.108 27 23 L 27 8.4140625 L 17.121094 18.292969 C 15.958108 19.455959 14.041892 19.455959 12.878906 18.292969 L 3 8.4140625 z \" transform=\"translate(0,289.0625)\" id=\"rect4592\"/></g></svg>\n javascript\n  get link() {\n    const email = this.content || this.parent.get(\"email\")\n    return email ? `mailto:${email}` : \"\"\n  }\nhomeButtonParser\n popularity 0.006391\n description Home button.\n extends abstractIconButtonParser\n catchAllAtomType urlAtom\n string style left:2rem;\n string svg <svg role=\"img\" viewBox=\"0 0 24 24\" xmlns=\"http://www.w3.org/2000/svg\"><path d=\"M12.7166 3.79541C12.2835 3.49716 11.7165 3.49716 11.2834 3.79541L4.14336 8.7121C3.81027 8.94146 3.60747 9.31108 3.59247 9.70797C3.54064 11.0799 3.4857 13.4824 3.63658 15.1877C3.7504 16.4742 4.05336 18.1747 4.29944 19.4256C4.41371 20.0066 4.91937 20.4284 5.52037 20.4284H8.84433C8.98594 20.4284 9.10074 20.3111 9.10074 20.1665V15.9754C9.10074 14.9627 9.90433 14.1417 10.8956 14.1417H13.4091C14.4004 14.1417 15.204 14.9627 15.204 15.9754V20.1665C15.204 20.3111 15.3188 20.4284 15.4604 20.4284H18.4796C19.0806 20.4284 19.5863 20.0066 19.7006 19.4256C19.9466 18.1747 20.2496 16.4742 20.3634 15.1877C20.5143 13.4824 20.4594 11.0799 20.4075 9.70797C20.3925 9.31108 20.1897 8.94146 19.8566 8.7121L12.7166 3.79541ZM10.4235 2.49217C11.3764 1.83602 12.6236 1.83602 13.5765 2.49217L20.7165 7.40886C21.4457 7.91098 21.9104 8.73651 21.9448 9.64736C21.9966 11.0178 22.0564 13.5119 21.8956 15.3292C21.7738 16.7067 21.4561 18.4786 21.2089 19.7353C20.9461 21.0711 19.7924 22.0001 18.4796 22.0001H15.4604C14.4691 22.0001 13.6655 21.1791 13.6655 20.1665V15.9754C13.6655 15.8307 13.5507 15.7134 13.4091 15.7134H10.8956C10.754 15.7134 10.6392 15.8307 10.6392 15.9754V20.1665C10.6392 21.1791 9.83561 22.0001 8.84433 22.0001H5.52037C4.20761 22.0001 3.05389 21.0711 2.79113 19.7353C2.54392 18.4786 2.22624 16.7067 2.10437 15.3292C1.94358 13.5119 2.00338 11.0178 2.05515 9.64736C2.08957 8.73652 2.55427 7.91098 3.28346 7.40886L10.4235 2.49217Z\"/></svg>\n javascript\n  get link() {\n    return this.content || this.get(\"link\") || \"index.html\"\n  }\nviewSourceButtonParser\n popularity 0.013963\n description Print badge top right.\n extends abstractIconButtonParser\n catchAllAtomType urlAtom\n string svg <svg xmlns=\"http://www.w3.org/2000/svg\" width=\"92pt\" height=\"92pt\" viewBox=\"0 0 92 92\"><path d=\"M90.156 41.965 50.036 1.848a5.913 5.913 0 0 0-8.368 0l-8.332 8.332 10.566 10.566a7.03 7.03 0 0 1 7.23 1.684 7.043 7.043 0 0 1 1.673 7.277l10.183 10.184a7.026 7.026 0 0 1 7.278 1.672 7.04 7.04 0 0 1 0 9.957 7.045 7.045 0 0 1-9.961 0 7.038 7.038 0 0 1-1.532-7.66l-9.5-9.497V59.36a7.04 7.04 0 0 1 1.86 11.29 7.04 7.04 0 0 1-9.957 0 7.04 7.04 0 0 1 0-9.958 7.034 7.034 0 0 1 2.308-1.539V33.926a7.001 7.001 0 0 1-2.308-1.535 7.049 7.049 0 0 1-1.516-7.7L29.242 14.273 1.734 41.777a5.918 5.918 0 0 0 0 8.371L41.855 90.27a5.92 5.92 0 0 0 8.368 0l39.933-39.934a5.925 5.925 0 0 0 0-8.371\"/></svg>\n javascript\n  get link() {\n    return this.content || this.parent.file?.viewSourceUrl || \"\"\n  }\n  get style() {\n    return this.parent.findParticles(\"viewSourceButton\")[0] === this ? \"right:2rem;\": \"position:relative;\"\n  }\ntheScrollButtonParser\n popularity 0.006294\n description WWS button.\n extends abstractIconButtonParser\n string style position:relative;\n string svg <svg xmlns=\"http://www.w3.org/2000/svg\" direction=\"ltr\" width=\"231.52568231268793\" height=\"249.33156169975996\" viewBox=\"297.27169239534896 1273.121785992385 231.52568231268793 249.33156169975996\" stroke-linecap=\"round\" stroke-linejoin=\"round\" data-color-mode=\"dark\" class=\"tl-container tl-theme__force-sRGB tl-theme__dark\" ><defs/><g transform=\"matrix(1, 0, 0, 1, 395.9682, 1413.3618)\" opacity=\"1\"><g transform=\"scale(1)\"><path d=\"M-5.7342,-1.1484 T-5.0182,-4.6536 -2.6672,-12.9768 1.7374,-22.3903 8.4597,-30.0892 16.5455,-35.2796 25.3478,-37.8247 34.4641,-37.2199 43.0676,-33.4606 50.27,-27.1118 55.7861,-19.7972 59.8042,-11.6764 61.6844,-2.3157 60.8049,7.9615 57.3259,17.5954 51.2605,25.5515 41.9451,31.9237 30.6489,36.2084 18.9812,37.6038 8.4915,36.637 -1.3063,34.5174 -10.6869,31.6604 -19.0463,27.0252 -26.0612,20.1562 -31.864,11.1271 -35.2772,1.0066 -35.7963,-9.1933 -35.203,-19.2337 -32.52,-28.3259 -27.3388,-37.4245 -20.2857,-45.7085 -11.787,-53.0395 -2.4314,-58.4864 7.1724,-61.8739 17.5002,-65.6025 28.2859,-68.1034 38.514,-69.1081 48.1844,-69.9134 57.9136,-70.1787 67.4056,-69.5971 76.297,-67.7446 84.5233,-63.97 92.0158,-57.5003 98.1976,-48.5614 102.8839,-38.056 105.9936,-27.6097 107.074,-18.168 107.175,-8.2882 106.6452,1.9768 105.4734,11.7698 104.0279,21.1013 101.7439,31.0445 98.0977,40.6386 92.7822,49.1039 86.2847,57.2337 78.6099,64.7113 69.8339,70.974 61.2863,75.092 52.4283,78.2186 42.5338,80.7945 32.7733,82.6629 22.8568,83.6574 12.2803,83.3538 2.4971,81.4828 -6.3367,78.789 -15.1061,75.8011 -24.259,72.3779 -33.2286,68.991 -41.5707,64.8363 -49.153,59.1909 -55.8375,52.2938 -62.9311,43.9553 -68.4604,34.4882 -71.2761,23.5855 -72.748,12.7452 -73.7673,2.0453 -74.1187,-8.7386 -72.293,-19.3856 -68.7376,-30.4053 -64.12,-39.7852 -59.1825,-47.8931 -53.7695,-56.4512 -48.1998,-65.7676 -43.1389,-74.401 -36.9006,-81.0179 -28.4317,-86.2639 -18.3342,-90.3521 -8.9259,-93.9355 0.1927,-98.7179 9.3551,-103.3537 18.7651,-106.7552 29.7482,-110.3584 40.9287,-113.446 50.87,-115.2231 57.8279,-116.0074 60.4065,-116.0632 A7.8326,7.8326 0 0 1 61.1735,-100.4168 T58.6018,-100.2201 51.1634,-99.3008 41.695,-96.884 32.4044,-94.0187 22.65,-91.382 13.4974,-87.3756 5.0519,-83.1026 -5.0443,-78.6175 -15.7236,-74.4743 -24.6193,-70.2681 -31.274,-62.5903 -36.3827,-53.9362 -41.2833,-46.2905 -46.0679,-38.5161 -50.639,-30.6576 -54.6876,-22.4063 -57.6038,-12.3346 -58.5104,-1.8678 -57.6022,9.4969 -56.0628,20.477 -53.6434,29.0487 -48.8908,36.7517 -42.4075,43.9784 -35.3064,50.6236 -27.3553,55.2062 -17.6884,59.4064 -7.6442,63.6638 2.4427,67.0449 12.7308,69.4843 22.9294,70.2171 33.2547,69.3921 42.4972,67.7384 52.2753,64.8425 61.8649,60.9142 69.5292,56.0828 76.3604,49.5927 82.431,42.3194 87.219,34.619 90.6076,25.5217 92.547,16.0352 93.8703,7.1315 94.4972,-2.5268 94.3672,-13.3681 93.3204,-24.4252 90.5377,-34.1656 85.7321,-43.6441 78.7334,-51.8057 68.7542,-56.0559 57.9857,-57.2713 48.079,-57.0198 38.4535,-56.3204 28.5246,-55.0036 18.6104,-52.4796 9.6402,-49.559 0.7193,-46.2981 -7.1531,-41.3715 -13.708,-34.8957 -19.5435,-26.853 -22.8356,-17.0622 -23.363,-6.5446 -21.9969,3.1439 -17.1086,11.9113 -9.276,18.744 -0.0685,22.6058 9.3636,24.796 19.2422,25.8817 29.052,25.0411 37.9338,21.3502 45.6819,13.8498 49.6675,4.5228 49.2802,-5.1854 45.3277,-14.4455 38.8603,-21.7879 30.5488,-25.7753 21.3356,-24.3975 13.6687,-19.2391 8.8217,-10.9919 6.423,-2.3609 5.7342,1.1484 A5.8481,5.8481 0 0 1 -5.7342,-1.1484 Z\" stroke-linecap=\"round\"/></g></g></svg>\n javascript\n  get link() {\n    return \"https://wws.scroll.pub\"\n  }\nclassicFormParser\n cue classicForm\n popularity 0.006391\n description Generate input form for ScrollSet.\n extends abstractAftertextParser\n atoms cueAtom emailAddressAtom\n catchAllAtomType stringAtom\n string script\n  <script>\n  sendFormViaEmail = form => {\n    const mailto = new URL(\"mailto:\")\n    const params = []\n    const { value, title } = form.querySelector('button[type=\"submit\"]')\n    params.push(`subject=${encodeURIComponent(value)}`)\n    params.push(`to=${encodeURIComponent(title)}`)\n    const oneTextarea = form.querySelector('textarea[title=\"oneTextarea\"]')\n    const body = oneTextarea ? codeMirrorInstance.getValue() : Array.from(new FormData(form)).map(([name, value]) => `${name} ${value}`).join(\"\\\\n\")\n    params.push(`body=${encodeURIComponent(body)}`)\n    mailto.search = params.join(\"&\")\n    window.open(mailto.href, '_blank')\n  }\n  </script>\n string style\n  <style> .scrollFormParser {\n      font-family: \"Gill Sans\", \"Bitstream Vera Sans\", sans-serif;\n    }\n  .scrollFormParser input , .scrollFormParser textarea{\n  padding: 10px;\n  margin-bottom: 10px;\n  width: 100%;\n  box-sizing: border-box;\n  } .scrollFormParser label {\n    display: block;\n    margin-bottom: 5px;\n  }\n  </style>\n javascript\n  get inputs() {\n    const {measures} = this.parent.file\n    return measures.filter(measure => !measure.IsComputed).map((measure, index) => {\n      const {Name, Question, IsRequired, Type} = measure\n      const type = Type || \"text\"\n      const placeholder = Question\n      const ucFirst = Name.substr(0, 1).toUpperCase() + Name.substr(1)\n      // ${index ? \"\" : \"autofocus\"}\n      let tag = \"\"\n      if (Type === \"textarea\")\n        tag = `<textarea placeholder=\"${placeholder}\" id=\"${Name}\" name=\"${Name}\" ${IsRequired ? \"required\" : \"\"}></textarea>`\n      else\n        tag = `<input placeholder=\"${placeholder}\" type=\"${type}\" id=\"${Name}\" name=\"${Name}\" ${IsRequired ? \"required\" : \"\"}>`\n      return `<div><label for=\"${Name}\" title=\"${IsRequired ? \"Required\" : \"\"}\">${ucFirst}${IsRequired ? \"*\" : \"\"}:</label>${tag}</div>`\n    }).join(\"\\n\")\n  }\n  compile() {\n    const {isEmail, formDestination, callToAction, subject} = this\n    return `${this.script}${this.style}<form ${isEmail ? \"onsubmit='sendFormViaEmail(this); return false;'\" : ` method='post' action='${formDestination}'`} class=\"scrollFormParser\">${this.inputs}<button value=\"${subject}\" title=\"${formDestination}\" class=\"scrollButton\" type=\"submit\">${callToAction}</button>${this.footer}</form>`\n  }\n  get callToAction() {\n    return (this.isEmail ? \"Submit via email\" : (this.subject || \"Post\"))\n  }\n  get isEmail() {\n    return this.formDestination.includes(\"@\")\n  }\n  get formDestination() {\n    return this.getAtom(1)\n  }\n  get subject() {\n    return this.getAtomsFrom(2)?.join(\" \") || \"\"\n  }\n  get footer() {\n    return \"\"\n  }\nscrollFormParser\n extends classicFormParser\n cue scrollForm\n placeholderParser\n  atoms cueAtom\n  baseParser blobParser\n  cueFromId\n  single\n valueParser\n  atoms cueAtom\n  baseParser blobParser\n  cueFromId\n  single\n description Generate a Scroll Form.\n string copyFromExternal codeMirror.css scrollLibs.js\n string requireOnce\n  <link rel=\"stylesheet\" href=\"codeMirror.css\">\n  <script src=\"scrollLibs.js\"></script>\n javascript\n  get placeholder() {\n    return this.getParticle(\"placeholder\")?.subparticlesToString() || \"\"\n  }\n  get value() {\n    return this.getParticle(\"value\")?.subparticlesToString() || \"\"\n  }\n  get footer() {\n    return \"\"\n  }\n  get inputs() {\n    const Name = \"particles\"\n    return `<textarea title=\"oneTextarea\" rows=\"${Math.min(this.parent.file.measures.length * 2, 30)}\" placeholder=\"${this.placeholder}\" id=\"${Name}\" name=\"${Name}\"></textarea>\n    <script id=\"${Name}Parsers\" type=\"text/plain\">${this.parent.file.parsersBundle}</script>\n    <script>{\n    let {width, height} = document.getElementById('${Name}').getBoundingClientRect();\n    const scrollParser = new HandParsersProgram(document.getElementById(\"${Name}Parsers\").textContent).compileAndReturnRootParser()\n    codeMirrorInstance = new ParsersCodeMirrorMode(\"custom\", () => scrollParser, undefined, CodeMirror).register().fromTextAreaWithAutocomplete(document.getElementById(\"${Name}\"), {\n      lineWrapping: false,\n      lineNumbers: false\n    })\n    codeMirrorInstance.setSize(width, height);\n    codeMirrorInstance.setValue(\\`${this.value}\\`); }</script>`\n  }\n  compile(compileSettings) {\n    return this.getHtmlRequirements(compileSettings) + super.compile()\n  }\nscrollLoopParser\n popularity 0.000024\n extends abstractAftertextParser\n atoms cueAtom\n boolean isTableVisualization true\n description Iterate over files+ to make HTML.\n cue loop\n inScope abstractItemsProviderParser\n joinParser\n  extends abstractLoopConfigParser\n  description HTML to use to join the items.\n limitParser\n  extends abstractLoopConfigParser\n  description HTML to use to join the items.\n javascriptParser\n  extends abstractLoopConfigParser\n  description Javascript to execute for each file in the loop.\n javascript\n  compile() {\n   const code = this.get(\"javascript\")\n   const joinWith = this.get(\"join\") ?? \"\"\n   try {\n    const limit = this.get(\"limit\")\n    let items = this.items\n    if (limit) items = items.slice(0, parseInt(limit))\n    return items.map((item, index) => eval(code)).join(joinWith)\n   } catch (err) {\n    console.error(err)\n    return \"\"\n   } finally {\n    this.teardown()\n   }\n  }\n  get items() {\n   const provider = this.getSubparticleInstancesOfParserId(\"abstractItemsProviderParser\")[0]\n   if (provider)\n     return provider.items\n   if (this.parent.coreTable)\n     return this.parent.coreTable\n   return []\n  }\n  teardown() {}\nloremIpsumParser\n extends abstractAftertextParser\n cueFromId\n description Generate dummy text.\n catchAllAtomType integerAtom\n javascript\n  text = `Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.`\n  compile() {\n   return this.text.repeat(this.howMany)\n  }\n  get howMany() {\n    return this.getAtom(1) ? parseInt(this.getAtom(1)) : 1\n  }\nnickelbackIpsumParser\n extends loremIpsumParser\n javascript\n  text = `And one day, I’ll be at the door. And lose your wings to fall in love? To the bottom of every bottle. I’m on the ledge of the eighteenth story. Why must the blind always lead the blind?`\nabstractTextLinkParser\n extends abstractAftertextParser\n cueFromId\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compileTxt() {\n    return this.text\n  }\n  compile() {\n   return `<div class=\"abstractTextLinkParser\"><a href=\"${this.link}\">${this.text}</a></div>`\n  }\nscrollVersionLinkParser\n popularity 0.006294\n extends abstractTextLinkParser\n string link https://scroll.pub\n description Print Scroll version.\n javascript\n  get text() {\n    return `Built with Scroll v${this.parent.file?.SCROLL_VERSION || \"\"}`\n  }\nviewSourceLinkParser\n popularity 0.001206\n extends abstractTextLinkParser\n description Print \"View source\" link.\n string text View source\n javascript\n  get link() {\n    return this.parent.file?.viewSourceUrl || \"\"\n  }\nprintSnippetsParser\n popularity 0.000338\n // todo: why are we extending AT here and not loops? Is it for class/id etc?\n extends abstractAftertextParser\n cueFromId\n atoms cueAtom\n catchAllAtomType tagWithOptionalFolderAtom\n description Prints snippets matching tag(s).\n example\n  printSnippets index\n javascript\n  makeSnippet(file, compileSettings) {\n    const {scrollProgram, endSnippetIndex} = file\n    if (endSnippetIndex === -1) return scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml\n    const linkRelativeToCompileTarget = compileSettings.relativePath + file.permalink\n    const joinChar = \"\\n\"\n    const html = scrollProgram\n        .map((subparticle, index) => (index >= endSnippetIndex ? \"\" : subparticle.compileEmbeddedVersion ? subparticle.compileEmbeddedVersion(compileSettings) : subparticle.compile(compileSettings)))\n        .filter(i => i)\n        .join(joinChar)\n        .trim() +\n      `<a class=\"scrollContinueReadingLink\" href=\"${linkRelativeToCompileTarget}\">Continue reading...</a>`\n    return html\n  }\n  get files() {\n   const thisFile = this.parent.file\n   const files = this.parent.file.getFilesWithTagsForEmbedding(this.content, this.has(\"limit\") ? parseInt(this.get(\"limit\")) : undefined).filter(file => file.file !== thisFile)\n   // allow sortBy lastCommit Time\n   if (this.get(\"sortBy\") === \"commitTime\") {\n     return require(\"lodash\").sortBy(files, file => file.file.lastCommitTime).reverse()\n   }\n   return files\n  }\n  compile() {\n   const alreadyRequired = this.root.alreadyRequired\n   const snippets = this.files.map(file => {\n    const compileSettings = {relativePath: file.relativePath, alreadyRequired }\n    return `<div class=\"scrollSnippetContainer\">${this.makeSnippet(file.file, compileSettings)}</div>`\n    }).join(\"\\n\\n\")\n   return `<div class=\"scrollColumns\" style=\"column-width:35ch;\">${snippets}</div>`\n  }\n  compileTxt() {\n   return this.files.map(file =>  {\n    const title = file.file.title\n    const ruler = \"=\".repeat(title.length)\n    // Note: I tried to print the description here but the description generating code needs work.\n    return `${title}\\n${ruler}\\n${file.file.date}\\n${file.file.absoluteLink}`\n   }).join(\"\\n\\n\")\n  }\nprintFullSnippetsParser\n popularity 0.000048\n extends printSnippetsParser\n cueFromId\n description Print full pages in group(s).\n javascript\n  makeSnippet(file, compileSettings) {\n   return file.scrollProgram.compileEmbeddedVersion(compileSettings) + file.viewSourceHtml\n  }\nprintShortSnippetsParser\n popularity 0.000048\n extends printSnippetsParser\n cueFromId\n description Titles and descriptions in group(s).\n javascript\n  makeSnippet(file, compileSettings) {\n   const { title, permalink, description, timestamp } = file\n   return `<div><a href=\"${permalink}\">${title}</a><div>${description}...</div><div class=\"subdued\" style=\"text-align:right;\">${this.dayjs(timestamp * 1000).format(`MMMM D, YYYY`)}</div></div>`\n  }\n  get dayjs() {\n    return this.isNodeJs() ? require(\"dayjs\") : dayjs\n  }\nprintRelatedParser\n popularity 0.001182\n description Print links to related posts.\n extends printSnippetsParser\n cueFromId\n javascript\n  compile() {\n   const alreadyRequired = this.root.alreadyRequired\n   const list = this.files.map(fileWrapper => {\n    const {relativePath, file} = fileWrapper\n    const {title, permalink, year} = file\n    return `- ${title}${year ? \" (\" + year + \")\" : \"\"}\\n link ${relativePath + permalink}`\n    }).join(\"\\n\")\n    const items = this.parent.concat(list)\n    const html = items.map(item => item.compile()).join(\"\\n\")\n    items.forEach(item => item.destroy())\n   return html\n  }\nprintSourceStackParser\n // useful for debugging\n description Print compilation steps.\n extends abstractAftertextParser\n cueFromId\n example\n  printOriginalSource\n javascript\n  get sources() {\n    const {file} = this.root\n    const passNames = [\"codeAtStart\", \"codeAfterImportPass\", \"codeAfterMacroPass\"]\n    let lastCode = \"\"\n    return passNames.map(name => {\n      let code = file[name]\n      if (lastCode === code)\n        code = \"[Unchanged]\"\n      lastCode = file[name]\n      return {\n      name,\n      code\n    }})\n  }\n  compile() {\n   return `<code class=\"scrollCodeBlock\">${this.compileTxt().replace(/\\</g, \"&lt;\")}</code>`\n  }\n  compileTxt() {\n   return this.sources.map((pass, index) => `Pass ${index + 1} - ${pass.name}\\n========\\n${pass.code}`).join(\"\\n\\n\\n\")\n  }\nabstractPrintMetaParser\n extends abstractScrollParser\n cueFromId\nprintAuthorsParser\n popularity 0.001664\n description Prints author(s) byline.\n boolean isPopular true\n extends abstractPrintMetaParser\n // todo: we need pattern matching added to sdk to support having no params or a url and personNameAtom\n catchAllAtomType anyAtom\n example\n  authors Breck Yunits\n   https://breckyunits.com\n  printAuthors\n javascript\n  compile() {\n   return this.parent.getParticle(\"authors\")?.compileHtmlForPrint()\n  }\n  compileTxt() {\n    return this.parent.getParticle(\"authors\")?.compileTxtForPrint()\n  }\nprintDateParser\n popularity 0.000434\n extends abstractPrintMetaParser\n // If not present computes the date from the file's ctime.\n description Print published date.\n boolean isPopular true\n javascript\n  compile() {\n   return `<div style=\"text-align: center;\" class=\"scrollDateline\">${this.day}</div>`\n  }\n  get day() {\n   let day = this.content || this.root.get(\"date\") || this.root.file?.date\n   if (!day) return \"\"\n   try {\n    const dayjs = require(\"dayjs\")\n    return dayjs(day).format(`MMMM D, YYYY`)\n   } catch (err) {\n    console.error(err)\n   }\n   return day || \"\"\n  }\n  compileTxt() {\n    return this.day\n  }\nprintFormatLinksParser\n description Prints links to other formats.\n extends abstractPrintMetaParser\n example\n  printFormatLinks\n javascript\n  compile() {\n   const permalink = this.root.file.permalink.replace(\".html\", \"\")\n   // hacky\n   const particle = this.appendSibling(`HTML | TXT`, `class scrollDateline\\nlink ${permalink}.html HTML\\nlink ${permalink}.txt TXT\\nstyle text-align:center;`)\n   const html = particle.compile()\n   particle.destroy()\n   return html\n  }\n  compileTxt() {\n    const permalink = this.root.file.permalink.replace(\".html\", \"\")\n    return `HTML | TXT\\n link ${permalink}.html HTML\\n link ${permalink}.txt TXT`\n  }\nabstractBuildCommandParser\n extends abstractScrollParser\n cueFromId\n atoms buildCommandAtom\n catchAllAtomType filePathAtom\n inScope slashCommentParser\n javascript\n  isTopMatter = true\n  compile() {\n   return \"\"\n  }\nloadConceptsParser\n // todo: clean this up. just add smarter imports with globs?\n // this currently removes any \"import\" statements.\n description Import all concepts in a folder.\n extends abstractBuildCommandParser\n cueFromId\n atoms preBuildCommandAtom filePathAtom\n javascript\n  build() {\n   const { Disk } = require(\"scrollsdk/products/Disk.node.js\")\n   const path = require(\"path\")\n   const {file} = this.parent\n   const folder = path.join(file.folderPath, this.getAtom(1))\n   const importParticleRegex = /^(import .+|[a-zA-Z\\_\\-\\.0-9\\/]+\\.(scroll|parsers)$)/gm\n   const ONE_BIG_FILE = Disk.getFiles(folder).filter(file => file.endsWith(\".scroll\")).map(Disk.read).filter(str => /^id /mg.test(str)).join(\"\\n\\n\").replace(/import .+/g, \"\")\n    this.parent.concat(ONE_BIG_FILE)\n   //console.log(ONE_BIG_FILE)\n  }\n  compile() {\n    return \"\"\n  }\nbuildConceptsParser\n popularity 0.000024\n cueFromId\n description Write concepts to csv+ files.\n extends abstractBuildCommandParser\n sortByParser\n  cueFromId\n  atoms cueAtom anyAtom\nbuildCssParser\n popularity 0.000048\n description Compile to CSS file.\n extends abstractBuildCommandParser\nbuildCsvParser\n popularity 0.000096\n description Compile to CSV file.\n extends abstractBuildCommandParser\nfetchParser\n description Download URL to disk.\n extends abstractBuildCommandParser\n cueFromId\n atoms preBuildCommandAtom urlAtom\n example\n  fetch https://breckyunits.com/posts.csv\n  fetch https://breckyunits.com/posts.csv renamed.csv\n javascript\n  get url() {\n    return this.getAtom(1)\n  }\n  get filename() {\n    return this.getAtom(2)\n  }\n  async build() {\n   await this.root.fetch(this.url, this.filename)\n  }\n  compile() {\n    return \"\"\n  }\nbuildHtmlParser\n popularity 0.007645\n description Compile to HTML file.\n extends abstractBuildCommandParser\n boolean isPopular true\nbuildMeasuresParser\n popularity 0.000024\n cueFromId\n description Write measures to csv+ files.\n extends abstractBuildCommandParser\n sortByParser\n  cueFromId\n  atoms cueAtom anyAtom\nbuildPdfParser\n popularity 0.000096\n description Compile to PDF file.\n extends abstractBuildCommandParser\nbuildRssParser\n popularity 0.000048\n description Write RSS file.\n extends abstractBuildCommandParser\nbuildJsParser\n description Compile to JS file.\n extends abstractBuildCommandParser\nbuildTxtParser\n popularity 0.007596\n description Compile to TXT file.\n extends abstractBuildCommandParser\n boolean isPopular true\nchatParser\n popularity 0.000362\n description A faux text chat conversation.\n catchAllParser chatLineParser\n cueFromId\n extends abstractScrollParser\n example\n  chat\n   Hi\n   👋\n javascript\n  compile() {\n   return this.map((line, index) => line.asString ? `<div style=\"text-align: ${index % 2 ? \"right\" : \"left\"};\" class=\"scrollChat ${index % 2 ? \"scrollChatRight\" : \"scrollChatLeft\"}\"><span>${line.asString}</span></div>` : \"\").join(\"\")\n  }\n  compileTxt() {\n    return this.subparticlesToString()\n  }\nabstractDatatableProviderParser\n description A datatable.\n extends abstractScrollParser\n inScope scrollTableDataParser scrollTableDelimiterParser abstractTableVisualizationParser abstractTableTransformParser h1Parser h2Parser scrollQuestionParser scrollLoopParser htmlInlineParser scrollBrParser\n javascript\n  get visualizations() {\n    return this.topDownArray.filter(particle => particle.isTableVisualization || particle.isHeader || particle.isHtml)\n  }\n  compile(compileSettings) {\n   return this.visualizations.map(particle => particle.compile(compileSettings))\n     .join(\"\\n\")\n     .trim()\n  }\n  compileTxt() {\n    return this.visualizations.map(particle => particle.compileTxt())\n     .join(\"\\n\")\n     .trim()\n  }\n  _coreTable\n  get coreTable() {\n    if (this._coreTable) return this._coreTable\n    const {delimiter, delimitedData} = this\n    return []\n  }\n  get columnNames() {\n    return []\n  }\nscrollTableParser\n extends abstractDatatableProviderParser\n popularity 0.002133\n cue table\n example\n  table\n   printTable\n   data\n    year,count\n    1900,10\n    2000,122\n    2020,23\n catchAllAtomType filePathAtom\n int atomIndex 1\n javascript\n  get delimiter() {\n     const {filename} = this\n     let delimiter = \"\"\n     if (filename) {\n       const extension = filename.split(\".\").pop()\n       if (extension === \"json\") delimiter = \"json\"\n       if (extension === \"particles\") delimiter = \"particles\"\n       if (extension === \"csv\") delimiter = \",\"\n       if (extension === \"tsv\") delimiter = \"\\t\"\n       if (extension === \"ssv\") delimiter = \" \"\n       if (extension === \"psv\") delimiter = \"|\"\n     }\n     if (this.get(\"delimiter\"))\n       delimiter = this.get(\"delimiter\")\n     else if (!delimiter) {\n       const header = this.delimitedData.split(\"\\n\")[0]\n       if (header.includes(\"\\t\"))\n         delimiter = \"\\t\"\n       else if (header.includes(\",\"))\n        delimiter = \",\"\n       else\n        delimiter = \" \"\n     }\n     return delimiter\n   }\n   get filename() {\n     return this.getAtom(this.atomIndex)\n   }\n   get coreTable() {\n    if (this._coreTable) return this._coreTable\n    const {delimiter, delimitedData} = this\n    if (delimiter === \"json\") {\n       const rows = JSON.parse(delimitedData)\n       this._columnNames = rows.length ? Object.keys(rows[0]) : []\n       this._coreTable = rows\n       return rows\n    }\n    else if (delimiter === \"particles\") {\n       const d3lib = typeof d3 === \"undefined\" ? require('d3') : d3\n       this._coreTable = d3lib.dsvFormat(\",\").parse(new Particle(delimitedData).asCsv, d3lib.autoType)\n    } else {\n      const d3lib = typeof d3 === \"undefined\" ? require('d3') : d3\n      this._coreTable = d3lib.dsvFormat(delimiter).parse(delimitedData, d3lib.autoType)\n    }\n    this._columnNames = this._coreTable.columns\n    delete this._coreTable.columns\n    return this._coreTable\n  }\n  get columnNames() {\n    // init coreTable to set columns\n    const coreTable = this.coreTable\n    return this._columnNames\n  }\n  async build() {\n    if (this.filename)\n      await this.root.fetch(this.filename)\n  }\n  get fileContent() {\n    return this.root.readSyncFromFileOrUrl(this.filename)\n  }\n   get delimitedData() {\n     // json csv tsv\n     if (this.filename)\n       return this.fileContent\n     const dataParticle = this.getParticle(\"data\")\n     if (dataParticle)\n       return dataParticle.subparticlesToString()\n     // if not dataparticle and no filename, check [permalink].csv\n     if (this.isNodeJs())\n       return this.root.readFile(this.root.permalink.replace(\".html\", \"\") + \".csv\")\n     return  \"\"\n   }\nclocParser\n extends scrollTableParser\n description Output results of cloc as table.\n cue cloc\n string copyFromExternal clocLangs.txt\n javascript\n  delimiter = \",\"\n  get delimitedData() {\n   const { execSync } = require(\"child_process\")\n   const results = execSync(this.command).toString().trim()\n   const csv = results.split(\"\\n\\n\").pop().replace(/,\\\"github\\.com\\/AlDanial.+/, \"\") // cleanup output\n   return csv\n  }\n  get command(){\n   return `cloc --vcs git . --csv --read-lang-def=clocLangs.txt ${this.content || \"\"}`\n  }\nscrollDiskParser\n extends scrollTableParser\n description Output file into as table.\n cue disk\n javascript\n  delimiter = \"json\"\n  get delimitedData() {\n   return this.isNodeJs() ? this.delimitedDataNodeJs : \"\"\n  }\n  get delimitedDataNodeJs() {\n   const fs = require('fs');\n   const path = require('path');\n   const {folderPath} = this.parent.file\n   const folder = this.content ? path.join(folderPath, this.content) : folderPath\n   function getDirectoryContents(dirPath) {\n     const directoryContents = [];\n     const items = fs.readdirSync(dirPath);\n     items.forEach((item) => {\n       const itemPath = path.join(dirPath, item);\n       const stats = fs.statSync(itemPath);\n       directoryContents.push({\n         name: item,\n         type: stats.isDirectory() ? 'directory' : 'file',\n         size: stats.size,\n         lastModified: stats.mtime\n       });\n     });\n     return directoryContents;\n   }\n   return JSON.stringify(getDirectoryContents(folder))\n  }\nquickTableParser\n popularity 0.000024\n extends scrollTableParser\n atoms urlAtom\n pattern ^[^\\s]+\\.(tsv|csv|ssv|psv|json)\n int atomIndex 0\ncodeParser\n popularity 0.001929\n description A code block.\n catchAllParser lineOfCodeParser\n extends abstractScrollParser\n boolean isPopular true\n example\n  code\n   two = 1 + 1\n javascript\n  compile() {\n   return `<code class=\"scrollCodeBlock\">${this.subparticlesToString().replace(/\\</g, \"&lt;\")}</code>`\n  }\n  compileTxt() {\n    return this.subparticlesToString()\n  }\n cueFromId\ncodeWithHeaderParser\n popularity 0.000169\n cueFromId\n catchAllAtomType stringAtom\n extends codeParser\n example\n  codeWithHeader math.py\n   two = 1 + 1\n javascript\n  compile() {\n   return `<div class=\"codeWithHeader\"><div class=\"codeHeader\">${this.content}</div>${super.compile()}</div>`\n  }\ncodeWithLanguageParser\n popularity 0.000458\n description Use this to specify the language of the code block, such as csvCode or rustCode.\n extends codeParser\n pattern ^[a-zA-Z0-9_]+Code$\nabstractScrollWithRequirementsParser\n extends abstractScrollParser\n cueFromId\n javascript\n  compile(compileSettings) {\n    return this.getHtmlRequirements(compileSettings) + this.compileInstance()\n  }\ncopyButtonsParser\n popularity 0.001471\n extends abstractScrollWithRequirementsParser\n description Copy code widget.\n javascript\n  compileInstance() {\n   return \"\"\n  }\n string requireOnce\n  <script>\n  document.addEventListener(\"DOMContentLoaded\", () => document.querySelectorAll(\".scrollCodeBlock\").forEach(block =>\n   {\n    if (!navigator.clipboard) return\n    const button = document.createElement(\"span\")\n    button.classList.add(\"scrollCopyButton\")\n    block.appendChild(button)\n    button.addEventListener(\"click\", async () => {\n      await navigator.clipboard.writeText(block.innerText)\n      button.classList.add(\"scrollCopiedButton\")\n    })\n   }\n  ))\n  </script>\nabstractTableVisualizationParser\n extends abstractScrollWithRequirementsParser\n boolean isTableVisualization true\n javascript\n  get columnNames() {\n    return this.parent.columnNames\n  }\nheatrixParser\n cueFromId\n example\n  heatrix\n   '2007 '2008 '2009 '2010 '2011 '2012 '2013 '2014 '2015 '2016 '2017 '2018 '2019 '2020 '2021 '2022 '2023 '2024\n   4 11 23 37 3 14 12 0 0 0 5 1 2 11 15 10 12 56\n description A heatmap matrix data visualization.\n catchAllParser heatrixCatchAllParser\n extends abstractTableVisualizationParser\n javascript\n  compile() {\n   // A hacky but simple way to do this for now.\n   const advanced = new Particle(\"heatrixAdvanced\")\n   advanced.appendLineAndSubparticles(\"table\", \"\\n \" + this.tableData.replace(/\\n/g, \"\\n \"))\n   const particle = this.appendSibling(\"heatrixAdvanced\", advanced.subparticlesToString())\n   const html = particle.compile()\n   particle.destroy()\n   return html\n  }\n  get tableData() {\n    const {coreTable} = this.parent\n    if (!coreTable)\n      return this.subparticlesToString()\n    let table = new Particle(coreTable).asSsv\n    if (this.parent.cue === \"transpose\") {\n      // drop first line after transpose\n      const lines = table.split(\"\\n\")\n      lines.shift()\n      table = lines.join(\"\\n\")\n    }\n    // detect years and make strings\n    const lines = table.split(\"\\n\")\n    const yearLine = / \\d{4}(\\s+\\d{4})+$/\n    if (yearLine.test(lines[0])) {\n      lines[0] = lines[0].replace(/ /g, \" '\")\n      table = lines.join(\"\\n\")\n    }\n    return table\n  }\nheatrixAdvancedParser\n popularity 0.000048\n cueFromId\n catchAllParser heatrixCatchAllParser\n extends abstractTableVisualizationParser\n description Advanced heatrix.\n example\n  heatrix\n   table\n     \n    %h10; '2007 '2008 '2009\n     12 4 323\n   scale\n    #ebedf0 0\n    #c7e9c0 100\n    #a1d99b 400\n    #74c476 1600\n javascript\n  compile() {\n  class Heatrix {\n    static HeatrixId = 0\n    uid = Heatrix.HeatrixId++\n    constructor(program) {\n      const isDirective = atom => /^(f|l|w|h)\\d+$/.test(atom) || atom === \"right\" || atom === \"left\" || atom.startsWith(\"http://\") || atom.startsWith(\"https://\") || atom.endsWith(\".html\")\n      const particle = new Particle(program)\n      this.program = particle\n      const generateColorBinningString = (data, colors) => {\n       const sortedData = [...data].sort((a, b) => a - b);\n       const n = sortedData.length;\n       const numBins = colors.length;\n       // Calculate the indices for each quantile\n       const indices = [];\n       for (let i = 1; i < numBins; i++) {\n         indices.push(Math.floor((i / numBins) * n));\n       }\n       // Get the quantile values and round them\n       const thresholds = indices.map(index => Math.round(sortedData[index]));\n       // Generate the string\n       let result = '';\n       colors.forEach((color, index) => {\n         const threshold = index === colors.length - 1 ? thresholds[index - 1] * 2 : thresholds[index];\n         result += `${color} ${threshold}\\n`;\n       });\n       return result.trim();\n      }\n      const buildScale = (table) => {\n        const numbers = table.split(\"\\n\").map(line => line.split(\" \")).flat().filter(atom => !isDirective(atom)).map(atom => parseFloat(atom)).filter(number => !isNaN(number))\n        const colors = ['#ebedf0', '#c7e9c0', '#a1d99b', '#74c476', '#41ab5d', '#238b45', '#005a32'];\n        numbers.unshift(0)\n        return generateColorBinningString(numbers, colors);\n      }\n      const table = particle.getParticle(\"table\").subparticlesToString()\n      const scale = particle.getParticle(\"scale\")?.subparticlesToString() || buildScale(table)\n      const thresholds = []\n      const colors = []\n      scale.split(\"\\n\").map((line) => {\n        const parts = line.split(\" \")\n        thresholds.push(parseFloat(parts[1]))\n        colors.push(parts[0])\n      })\n      const colorCount = colors.length\n      const colorFunction = (value) => {\n        if (isNaN(value)) return \"\" // #ebedf0\n        for (let index = 0; index < colorCount; index++) {\n          const threshold = thresholds[index]\n          if (value <= threshold) return colors[index]\n        }\n        return colors[colorCount - 1]\n      }\n      const directiveDelimiter = \";\"\n      const getSize = (directives, letter) =>\n        directives\n          .filter((directive) => directive.startsWith(letter))\n          .map((dir) => dir.replace(letter, \"\") + \"px\")[0] ?? \"\"\n      this.table = table.split(\"\\n\").map((line) =>\n        line\n          .trimEnd()\n          .split(\" \")\n          .map((atom) => {\n            const atoms = atom.split(directiveDelimiter).filter((atom) => !isDirective(atom)).join(\"\")\n            const directivesInThisAtom = atom\n              .split(directiveDelimiter)\n              .filter(isDirective)\n            const value = parseFloat(atoms)\n            const label = atoms.includes(\"'\") ? atoms.split(\"'\")[1] : atoms\n            const alignment = directivesInThisAtom.includes(\"right\")\n              ? \"right\"\n              : directivesInThisAtom.includes(\"left\")\n              ? \"left\"\n              : \"\"\n            const color = colorFunction(value)\n            const width = getSize(directivesInThisAtom, \"w\")\n            const height = getSize(directivesInThisAtom, \"h\")\n            const fontSize = getSize(directivesInThisAtom, \"f\")\n            const lineHeight = getSize(directivesInThisAtom, \"l\") || height\n            const link = directivesInThisAtom.filter(i => i.startsWith(\"http\") || i.endsWith(\".html\"))[0]\n            const style = {\n              \"background-color\": color,\n              width,\n              height,\n              \"font-size\": fontSize,\n              \"line-height\": lineHeight,\n              \"text-align\": alignment,\n            }\n            Object.keys(style).filter(key => !style[key]).forEach((key) => delete style[key])\n            return {\n              value,\n              label,\n              style,\n              link,\n            }\n          })\n      )\n    }\n    get html() {\n      const { program } = this\n      const cssId = `#heatrix${this.uid}`\n      const defaultWidth = \"40px\"\n      const defaultHeight = \"40px\"\n      const fontSize = \"10px\"\n      const lineHeight = defaultHeight\n      const style = `<style>\n      .heatrixContainer {\n        margin: auto;\n      }.heatrixRow {white-space: nowrap;}\n  ${cssId} .heatrixAtom {\n    font-family: arial;\n    border-radius: 2px;\n    border: 1px solid transparent;\n    display: inline-block;\n    margin: 1px;\n    text-align: center;\n    vertical-align: middle;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n  .heatrixAtom a {\n    color: black;\n  }\n  ${cssId} .heatrixAtom{\n   width: ${defaultWidth};\n   height: ${defaultHeight};\n   font-size: ${fontSize};\n   line-height: ${lineHeight};\n  }\n  </style>`\n      const firstRow = this.table[0]\n      return (\n        `<div class=\"heatrixContainer\" id=\"heatrix${this.uid}\">${style}` +\n        this.table\n          .map((row, rowIndex) => {\n            if (!rowIndex) return \"\"\n            const rowStyle = row[0].style\n            return `<div class=\"heatrixRow heatrixRow${rowIndex}\">${row\n              .map((atom, columnIndex) => {\n                if (!columnIndex) return \"\"\n                const columnStyle = firstRow[columnIndex]?.style || {}\n                let { value, label, style, link } = atom\n                const extendedStyle = Object.assign(\n                  {},\n                  rowStyle,\n                  columnStyle,\n                  style\n                )\n                const inlineStyle = Object.keys(extendedStyle)\n                  .map((key) => `${key}:${extendedStyle[key]};`)\n                  .join(\"\")\n                let valueClass = value ? \" valueAtom\" : \"\"\n                const href = link ? ` href=\"${link}\"` : \"\"\n                return `<div class=\"heatrixAtom heatrixColumn${columnIndex}${valueClass}\" style=\"${inlineStyle}\"><a title=\"${label}\" ${href}>${label}</a></div>`\n              })\n              .join(\"\")}</div>`\n          })\n          .join(\"\\n\") +\n        \"</div>\"\n      ).replace(/\\n/g, \"\")\n    }\n  }\n    return new Heatrix(this.subparticlesToString().trim()).html\n  }\nmapParser\n latParser\n  atoms cueAtom floatAtom\n  cueFromId\n  single\n longParser\n  atoms cueAtom floatAtom\n  cueFromId\n  single\n tilesParser\n  atoms cueAtom tileOptionAtom\n  cueFromId\n  single\n zoomParser\n  atoms cueAtom integerAtom\n  cueFromId\n  single\n geolocateParser\n  description Geolocate user.\n  atoms cueAtom\n  cueFromId\n  single\n radiusParser\n  atoms cueAtom floatAtom\n  cueFromId\n  single\n fillOpacityParser\n  atoms cueAtom floatAtom\n  cueFromId\n  single\n fillColorParser\n  atoms cueAtom anyAtom\n  cueFromId\n  single\n colorParser\n  atoms cueAtom anyAtom\n  cueFromId\n  single\n heightParser\n  atoms cueAtom floatAtom\n  cueFromId\n  single\n hoverParser\n  atoms cueAtom\n  catchAllAtomType anyAtom\n  cueFromId\n  single\n extends abstractTableVisualizationParser\n description Map widget.\n string copyFromExternal leaflet.css leaflet.js scrollLibs.js\n string requireOnce\n  <link rel=\"stylesheet\" href=\"leaflet.css\">\n  <script src=\"leaflet.js\"></script>\n  <script src=\"scrollLibs.js\"></script>\n javascript\n  compileInstance() {\n   const height = this.get(\"height\") || 500\n   const id = this._getUid()\n   const obj = this.toObject()\n   const template = {}\n   const style = height !== \"full\" ? `height: ${height}px;` : `height: 100%; position: fixed; z-index: -1; left: 0; top: 0; width: 100%;`\n   const strs = [\"color\", \"fillColor\"]\n   const nums = [\"radius\", \"fillOpacity\"]\n    strs.filter(i => obj[i]).forEach(i => template[i] = obj[i])\n    nums.filter(i => obj[i]).forEach(i => template[i] = parseFloat(obj[i]))\n    const mapId = `map${id}`\n   return `<div id=\"${mapId}\" style=\"${style}\"></div>\n  <script>\n   {\n      if (!window.maps) window.maps = {}\n       const moveToMyLocation = () => {\n        if (!navigator.geolocation) return\n        navigator.geolocation.getCurrentPosition((position) => {\n            const { latitude, longitude } = position.coords\n            window.maps.${mapId}.setView([latitude, longitude])\n        }, () => {})\n      }\n    const lat = ${this.get(\"lat\") ?? 37.8}\n    const long = ${this.get(\"long\") ?? 4}\n    if (${this.has(\"geolocate\")})\n        moveToMyLocation()\n    const zoomLevel = ${this.get(\"zoom\") ?? 4}\n    const hover = '${this.get(\"hover\") || \"<b>{title}</b><br>{description}\"}'\n    const template = ${JSON.stringify(template)}\n    const points = ${JSON.stringify((this.parent.coreTable || []).filter(point => point.lat && point.long), undefined, 2)}\n    window.maps.${mapId} = L.map(\"map${id}\").setView([lat, long], zoomLevel)\n    const map = window.maps.${mapId}\n    const tileOptions = {\n    \"default\": {\n        baseLayer: 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png',\n        attribution: '<a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a> contributors'\n    },\n    light: {\n        baseLayer: 'https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png',\n        attribution: '<a href=\"https://www.openstreetmap.org/\">OpenStreetMap</a> contributors <a href=\"https://carto.com/    attributions\">CARTO</a>'\n    },\n    }\n    const {baseLayer, attribution} = tileOptions.${this.get(\"tiles\") || \"default\"}\n    L.tileLayer(baseLayer, {\n    attribution,\n    maxZoom: 19\n    }).addTo(map);\n    points.forEach(point => {\n     L.circleMarker([point.lat, point.long], {...template, ...Object.fromEntries(\n            Object.entries(point).filter(([key, value]) => value !== null)\n        )})\n      .addTo(map)\n      .bindPopup(new Particle(point).evalTemplateString(hover))\n    })\n   }\n  </script>`\n  }\nabstractPlotParser\n // Observablehq\n extends abstractTableVisualizationParser\n string copyFromExternal d3.js plot.js\n string requireOnce\n  <script src=\"d3.js\"></script>\n  <script src=\"plot.js\"></script>\n example\n  plot\n inScope abstractColumnNameParser\n javascript\n  compileInstance() {\n   const id = \"plot\" + this._getUid()\n   return `<div id=\"${id}\"></div><script>\n   {\n    let loadChart = async () => {\n    const data = ${this.dataCode}\n    const get = (col, index ) => col !== \"undefined\" ? col : (index === undefined ? undefined : Object.keys(data[0])[index])\n    document.querySelector(\"#${id}\").append(Plot.plot(${this.plotOptions}))\n    }\n    loadChart()\n    }\n    </script>`\n  }\n  get marks() {\n    // just for testing purposes\n    return `Plot.rectY({length: 10000}, Plot.binX({y: \"count\"}, {x: d3.randomNormal()}))`\n  }\n  get dataCode() {\n    const {coreTable} = this.parent\n    return `d3.csvParse(\\`${new Particle(coreTable).asCsv}\\`, d3.autoType)`\n  }\n  get plotOptions() {\n    return `{\n      title: \"${this.get(\"title\") || \"\"}\",\n      subtitle: \"${this.get(\"subtitle\") || \"\"}\",\n      caption: \"${this.get(\"caption\") || \"\"}\",\n      symbol: {legend: ${this.has(\"symbol\")}},\n      color: {legend: ${this.has(\"fill\")}},\n      grid: ${this.get(\"grid\") !== \"false\"},\n      marks: [${this.marks}],\n    }`\n  }\nscatterplotParser\n extends abstractPlotParser\n description Scatterplot Widget.\n // todo: make copyFromExternal work with inheritance\n string copyFromExternal d3.js plot.js\n javascript\n  get marks() {\n    const x = this.get(\"x\")\n    const y = this.get(\"y\")\n    const text = this.get(\"label\")\n    return `Plot.dot(data, {\n      x: get(\"${x}\", 0),\n      y: get(\"${y}\", 1),\n      r: get(\"${this.get(\"radius\")}\"),\n      fill: get(\"${this.get(\"fill\")}\"),\n      tip: true,\n      symbol: get(\"${this.get(\"symbol\")}\")} ), Plot.text(data, {x: get(\"${x}\",0), y: get(\"${y}\", 1), text: \"${text}\", dy: -6, lineAnchor: \"bottom\"})`\n  }\nsparklineParser\n popularity 0.000024\n description Sparkline widget.\n extends abstractTableVisualizationParser\n example\n  sparkline 1 2 3 4 5\n string copyFromExternal sparkline.js\n string requireOnce <script src=\"sparkline.js\"></script>\n catchAllAtomType numberAtom\n // we need pattern matching\n inScope scrollYParser\n javascript\n  compileInstance() {\n   const id = \"spark\" + this._getUid()\n   const {columnValues} = this\n   const start = this.has(\"start\") ? parseInt(this.get(\"start\")) : 0\n   const width = this.get(\"width\") || 100\n   const height = this.get(\"height\") || 30\n   const lineColor = this.get(\"color\") || \"black\"\n   return `<span id=\"${id}\"></span><script>new Sparkline(document.getElementById(\"${id}\"), {dotRadius: 0, width: ${width}, height: ${height}, lineColor: \"${lineColor}\", tooltip: (value,index) => ${start} + index + \": \" + value}).draw(${JSON.stringify(columnValues)})</script>`\n  }\n  get columnValues() {\n    if (this.content)\n      return this.content.split(\" \").map(str => parseFloat(str))\n    const {coreTable} = this.parent\n    if (coreTable) {\n      const columnName = this.get(\"y\") || Object.keys(coreTable[0]).find(key => typeof coreTable[0][key] === 'number')\n      return coreTable.map(row => row[columnName])\n    }\n  }\nprintColumnParser\n popularity 0.000024\n description Print one column\n extends abstractTableVisualizationParser\n example\n  printColumn tags\n catchAllAtomType columnNameAtom\n javascript\n  compile() {\n   return this.columnValues.join(\"\\n\")\n  }\n  compileTxt() {\n    return this.columnValues.join(\"\\n\")\n  }\n  get columnName() {\n    return this.atoms[1]\n  }\n  get columnValues() {\n    return this.parent.coreTable.map(row => row[this.columnName])\n  }\nprintTableParser\n popularity 0.001085\n cueFromId\n description Print table.\n extends abstractTableVisualizationParser\n javascript\n  get tableHeader() {\n   return this.columns.filter(col => !col.isLink).map(column => `<th>${column.name}</th>\\n`)\n  }\n  get columnNames() {\n   return this.parent.columnNames\n  }\n  get columns() {\n   const {columnNames} = this\n   return columnNames.map((name, index) => {\n    const isLink = name.endsWith(\"Link\")\n    const linkIndex = columnNames.indexOf(name + \"Link\")\n    return {\n     name,\n     isLink,\n     linkIndex\n    }\n   })\n  }\n  toRow(row) {\n    const {columns} = this\n    const atoms = columns.map(col => row[col.name])\n   let str = \"\"\n   let column = 0\n   const columnCount = columns.length\n   while (column < columnCount) {\n    const col = columns[column]\n    column++\n    const content = ((columnCount === column ? atoms.slice(columnCount - 1).join(\" \") : atoms[column - 1]) ?? \"\").toString()\n    if (col.isLink) continue\n    const isTimestamp = col.name.toLowerCase().includes(\"time\") && /^\\d{10}(\\d{3})?$/.test(content)\n    const text =  isTimestamp ? new Date(parseInt(content.length === 10 ? content * 1000 : content)).toLocaleString() : content\n    let tagged = text\n    const link = atoms[col.linkIndex]\n    const isUrl = content.match(/^https?\\:[^ ]+$/)\n    if (col.linkIndex > -1 && link) tagged = `<a href=\"${link}\">${text}</a>`\n    else if (col.name.endsWith(\"Url\")) tagged = `<a href=\"${content}\">${col.name.replace(\"Url\", \"\")}</a>`\n    else if (isUrl) tagged = `<a href=\"${content}\">${text}</a>`\n    str += `<td>${tagged}</td>\\n`\n   }\n   return str\n  }\n  get tableBody() {\n   return this.parent.coreTable\n    .map(row => `<tr>${this.toRow(row)}</tr>`)\n    .join(\"\\n\")\n  }\n  compile() {\n   return `<table id=\"table${this._getUid()}\" class=\"scrollTable\">\n   <thead><tr>${this.tableHeader.join(\"\\n\")}</tr></thead>\n   <tbody>${this.tableBody}</tbody>\n   </table>`\n  }\n  compileTxt() {\n    return this.parent.delimitedData || new Particle(this.parent.coreTable).asCsv\n  }\nkatexParser\n popularity 0.001592\n extends abstractScrollWithRequirementsParser\n catchAllAtomType codeAtom\n catchAllParser lineOfCodeParser\n example\n  katex\n   \\text{E} = \\text{T} / \\text{A}!\n description KaTex widget for typeset math.\n string copyFromExternal katex.min.css katex.min.js\n string requireOnce\n  <link rel=\"stylesheet\" href=\"katex.min.css\">\n  <script defer src=\"katex.min.js\"></script>\n  <script>\n  document.addEventListener(\"DOMContentLoaded\", () => document.querySelectorAll(\".scrollKatex\").forEach(el =>\n   {\n    katex.render(el.innerText, el, {\n        throwOnError: false\n    });\n   }\n  ))\n  </script>\n javascript\n  compileInstance() {\n   const id = this._getUid()\n   const content = this.content === undefined ? \"\" : this.content\n   return `<div class=\"scrollKatex\" id=\"${id}\">${content + this.subparticlesToString()}</div>`\n  }\n  compileTxt() {\n    return ( this.content ? this.content : \"\" )+ this.subparticlesToString()\n  }\nhelpfulNotFoundParser\n popularity 0.000048\n extends abstractScrollWithRequirementsParser\n catchAllAtomType filePathAtom\n string copyFromExternal helpfulNotFound.js\n description Helpful not found widget.\n javascript\n  compileInstance() {\n   return `<style>#helpfulNotFound{margin: 100px 0;}</style><h1 id=\"helpfulNotFound\"></h1><script defer src=\"/helpfulNotFound.js\"></script><script>document.addEventListener(\"DOMContentLoaded\", () => new NotFoundApp('${this.content}'))</script>`\n  }\nslideshowParser\n // Left and right arrows navigate.\n description Slideshow widget. *** delimits slides.\n extends abstractScrollWithRequirementsParser\n string copyFromExternal jquery-3.7.1.min.js slideshow.js\n example\n  slideshow\n  Why did the cow cross the road?\n  ***\n  Because it wanted to go to the MOOOO-vies.\n  ***\n  THE END\n  ****\n javascript\n  compile() {\n   return `<style>html {font-size: var(--base-font-size, 28px);} body {margin: auto; width: 500px;}.slideshowNav{text-align: center; margin-bottom:20px; font-size: 24px;color: rgba(204,204,204,.8);} a{text-decoration: none; color: rgba(204,204,204,.8);}</style><script defer src=\"jquery-3.7.1.min.js\"></script><div class=\"slideshowNav\"></div><script defer src=\"slideshow.js\"></script>`\n  }\ntableSearchParser\n popularity 0.000072\n extends abstractScrollWithRequirementsParser\n string copyFromExternal jquery-3.7.1.min.js datatables.css datatables.js tableSearch.js\n string requireOnce\n  <script defer src=\"jquery-3.7.1.min.js\"></script>\n  <style>.dt-search{font-family: \"SF Pro\", \"Helvetica Neue\", \"Segoe UI\", \"Arial\";}</style>\n  <link rel=\"stylesheet\" href=\"datatables.css\">\n  <script defer src=\"datatables.js\"></script>\n  <script defer src=\"tableSearch.js\"></script>\n // adds to all tables on page\n description Table search and sort widget.\n javascript\n  compileInstance() {\n   return \"\"\n  }\nabstractCommentParser\n description Prints nothing.\n catchAllAtomType commentAtom\n atoms commentAtom\n extends abstractScrollParser\n baseParser blobParser\n javascript\n  compile() {\n   return ``\n  }\n catchAllParser commentLineParser\ncommentParser\n popularity 0.000193\n extends abstractCommentParser\n cueFromId\nslashCommentParser\n popularity 0.005643\n extends commentParser\n cue //\n boolean isPopular true\n description A comment. Prints nothing.\ncounterpointParser\n description A counterpoint. Prints nothing.\n extends commentParser\n cue !\nthanksToParser\n description Acknowledge reviewers. Prints nothing.\n extends abstractCommentParser\n cueFromId\nscrollContainerParser\n popularity 0.000096\n cue container\n description A centered HTML div.\n catchAllAtomType cssLengthAtom\n extends abstractScrollParser\n boolean isHtml true\n javascript\n  get maxWidth() {\n    return this.atoms[1] || \"1200px\"\n  }\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n    this.parent.bodyStack.push(\"</div>\")\n   return `<div style=\"width: 100%; box-sizing: border-box; max-width: ${this.maxWidth}; margin: 0 auto;\" class=\"scrollContainerParser\">`\n  }\ncssParser\n popularity 0.007211\n extends abstractScrollParser\n description A style tag.\n cueFromId\n catchAllParser cssLineParser\n catchAllAtomType cssAnyAtom\n javascript\n  compile() {\n   return `<style>${this.css}</style>`\n  }\n  get css() {\n    return this.content ?? this.subparticlesToString()\n  }\n  compileCss() {\n    return this.css\n  }\nabstractQuickIncludeParser\n popularity 0.007524\n extends abstractScrollParser\n atoms urlAtom\n javascript\n  get filename() {\n    return this.getAtom(0)\n  }\nquickCssParser\n popularity 0.007524\n description Make a CSS tag.\n extends abstractQuickIncludeParser\n atoms urlAtom\n pattern ^[^\\s]+\\.(css)$\n javascript\n  compile() {\n   return `<link rel=\"stylesheet\" type=\"text/css\" href=\"${this.filename}\">`\n  }\nquickIncludeHtmlParser\n popularity 0.007524\n description Include an HTML file.\n extends abstractQuickIncludeParser\n atoms urlAtom\n pattern ^[^\\s]+\\.(html|htm)$\n javascript\n  compile() {\n   return this.root.readFile(this.filename)\n  }\nquickScriptParser\n popularity 0.007524\n description Make a Javascript tag.\n extends abstractQuickIncludeParser\n atoms urlAtom\n pattern ^[^\\s]+\\.(js)$\n javascript\n  compile() {\n   return `<script src=\"${this.filename}\"></script>`\n  }\nabstractPostLoopParser\n description Do something with all posts. Takes an optional list of folder/group names.\n extends abstractScrollParser\n cueFromId\n atoms cueAtom\n catchAllAtomType tagWithOptionalFolderAtom\n javascript\n  get files() {\n   return this.root.file.getFilesWithTagsForEmbedding(this.content)\n  }\nprintFeedParser\n popularity 0.000048\n description Print group to RSS.\n extends abstractPostLoopParser\n example\n  printFeed index\n  printFeed cars/index\n  buildRss feed.xml\n javascript\n  compile() {\n   const dayjs = require(\"dayjs\")\n   const file = this.root.file\n   const files = this.files.map(file => file.file)\n   const { title, baseUrl, description } = file\n   return `<?xml version=\"1.0\" encoding=\"ISO-8859-1\" ?>\n  <rss version=\"2.0\">\n  <channel>\n   <title>${title}</title>\n   <link>${baseUrl}</link>\n   <description>${description}</description>\n   <lastBuildDate>${dayjs().format(\"ddd, DD MMM YYYY HH:mm:ss ZZ\")}</lastBuildDate>\n   <language>en-us</language>\n  ${files.map(file => file.toRss()).join(\"\\n\")}\n  </channel>\n  </rss>`\n  }\n  compileTxt() {\n    return this.compile()\n  }\nprintCsvParser\n popularity 0.000024\n description Print group metadata to CSV.\n extends printFeedParser\n example\n  printCsv index\n  buildTxt posts.csv\n javascript\n  compile() {\n   const file = this.root.file\n   const files = file.getFilesWithTagsForEmbedding(this.content).map(file => file.file)\n   const header = file.csvFields\n   return `${header.join(\",\")}\\n${files.map(file => file.toCsv()).join(\"\\n\")}`\n  }\n  compileCsv() {\n    return this.compile()\n  }\nprintSourceParser\n popularity 0.000024\n description Print source for files in group(s).\n extends printFeedParser\n example\n  printSource index\n  buildTxt source.txt\n javascript\n  compile() {\n   const file = this.root.file\n   const files = file.getFilesWithTagsForEmbedding(this.content).map(file => file.file)\n   return `${files.map(file => file.filePath + \"\\n \" + file.codeAtStart.replace(/\\n/g, \"\\n \") ).join(\"\\n\")}`\n  }\nprintSearchTableParser\n popularity 0.000024\n description Prints files to HTML table.\n extends abstractPostLoopParser\n example\n  printSearchTable\n  tableSearch\n javascript\n  compile() {\n   const file = this.root.file\n   const files = this.files\n   const data = files.map(file => file.file.toSearchTsvRow(file.relativePath)).join(\"\\n\")\n   // A hacky but simple way to do this for now.\n     const particle = this.appendSibling(\"table\")\n    particle.appendLine(\"delimiter \t\")\n    particle.appendLine(\"printTable\")\n    const dataParticle = particle.appendLine(\"data\")\n    dataParticle.setSubparticles(\"title titleLink text date wordCount minutes\".replace(/ /g, \"\\t\") + \"\\n\" + data)\n   const html = particle.compile()\n   particle.destroy()\n   return html\n  }\nprintSiteMapParser\n popularity 0.000072\n extends abstractPostLoopParser\n description Print text sitemap.\n example\n  baseUrl http://test.com\n  printSiteMap\n javascript\n  compile() {\n   const file = this.root.file\n   const { baseUrl } = file\n   return this.files.map(file => baseUrl + file.relativePath + file.file.permalink).join(\"\\n\")\n  }\n  compileTxt() {\n    return this.compile()\n  }\nscrollDashboardParser\n popularity 0.000145\n description Key stats in large font.\n catchAllParser lineOfCodeParser\n cue dashboard\n extends abstractScrollParser\n example\n  dashboard\n   #2 Popularity\n   30 Years Old\n   $456 Revenue\n javascript\n  get tableBody() {\n   const items = this.topDownArray\n   let str = \"\"\n   for (let i = 0; i < items.length; i = i + 3) {\n    str += this.makeRow(items.slice(i, i + 3))\n   }\n   return str\n  }\n  makeRow(items) {\n   return `<tr>` + items.map(particle => `<td>${particle.cue}<span>${particle.content}</span></td>`).join(\"\\n\") + `</tr>\\n`\n  }\n  compile() {\n   return `<table class=\"scrollDashboard\">${this.tableBody}</table>`\n  }\n  compileTxt() {\n    return this.subparticlesToString()\n  }\nabstractTopLevelSingleMetaParser\n description Use these parsers once per file.\n extends abstractScrollParser\n inScope slashCommentParser\n cueFromId\n atoms metaCommandAtom\n javascript\n  isTopMatter = true\n  isSetterParser = true\n  compile() {\n   return \"\"\n  }\ndateParser\n popularity 0.006680\n catchAllAtomType dateAtom\n description Set published date.\n extends abstractTopLevelSingleMetaParser\n boolean isPopular true\n example\n  date 1/11/2019\n  printDate\n  Hello world\n   dateline\nsiteOwnerEmailParser\n popularity 0.001302\n description Set email address for site contact.\n extends abstractTopLevelSingleMetaParser\n cue email\n atoms metaCommandAtom emailAddressAtom\nfaviconParser\n popularity 0.001688\n catchAllAtomType stringAtom\n cue favicon\n description Favicon file.\n example\n  favicon logo.png\n  metatags\n  buildHtml\n extends abstractTopLevelSingleMetaParser\nimportOnlyParser\n popularity 0.033569\n // This line will be not be imported into the importing file.\n description Don't build this file.\n cueFromId\n atoms preBuildCommandAtom\n extends abstractTopLevelSingleMetaParser\n javascript\n  compile() {\n   return \"\"\n  }\ninlineMarkupsParser\n popularity 0.000024\n description Set global inline markups.\n extends abstractTopLevelSingleMetaParser\n cueFromId\n example\n  inlineMarkups\n   * \n    // Disable * for bold\n   _ u\n    // Make _ underline\nabstractUrlSettingParser\n extends abstractTopLevelSingleMetaParser\n atoms metaCommandAtom urlAtom\n cueFromId\ncanonicalUrlParser\n description Override canonical URL.\n extends abstractUrlSettingParser\nopenGraphImageParser\n popularity 0.000796\n // https://ogp.me/\n // If not defined, Scroll will try to generate it's own using the first image tag on your page.\n description Override Open Graph Image.\n extends abstractUrlSettingParser\nbaseUrlParser\n popularity 0.009188\n description Required for RSS and OpenGraph.\n extends abstractUrlSettingParser\nrssFeedUrlParser\n popularity 0.008850\n description Set RSS feed URL.\n extends abstractUrlSettingParser\nviewSourceBaseUrlParser\n popularity 0.007838\n description Override source link baseUrl.\n extends abstractUrlSettingParser\nhtmlLangParser\n atoms metaCommandAtom stringAtom\n // for the <html lang=\"\"> tag. If not specified will be \"en\". See https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/lang\n description Override HTML lang attribute.\n extends abstractTopLevelSingleMetaParser\nopenGraphDescriptionParser\n popularity 0.001688\n catchAllAtomType stringAtom\n cue description\n description Meta tag description.\n extends abstractTopLevelSingleMetaParser\npermalinkParser\n popularity 0.000265\n description Override output filename.\n extends abstractTopLevelSingleMetaParser\n atoms metaCommandAtom permalinkAtom\nscrollTagsParser\n popularity 0.006801\n cue tags\n description Set tags.\n example\n  tags All\n extends abstractTopLevelSingleMetaParser\n catchAllAtomType tagAtom\ntestStrictParser\n description Make catchAllParagraphParser = error.\n extends abstractTopLevelSingleMetaParser\npageTitleParser\n popularity 0.007524\n catchAllAtomType personNameAtom\n cue title\n description Set title.\n example\n  title Eureka\n  printTitle\n extends abstractTopLevelSingleMetaParser\n boolean isPopular true\nviewSourceUrlParser\n catchAllAtomType urlAtom\n description Override source link.\n extends abstractTopLevelSingleMetaParser\nbelowAsCodeParser\n popularity 0.000651\n description Print code below.\n extends abstractScrollParser\n catchAllAtomType integerAtom\n cueFromId\n javascript\n  method = \"next\"\n  get code() {\n   const { method } = this\n   let code = \"\"\n   \n   let particles = []\n   let next = this[method]\n   let {howMany} = this\n   while (howMany) {\n    particles.push(next)\n    next = next[method]\n    howMany--\n   }\n   if (this.reverse) particles.reverse()\n   return particles.map(particle => particle.asString).join(\"\\n\")\n  }\n  reverse = false\n  compile() {\n   return `<code class=\"scrollCodeBlock\">${this.code.replace(/\\</g, \"&lt;\")}</code>`\n  }\n  get howMany() {\n    let howMany = parseInt(this.getAtom(1))\n   if (!howMany || isNaN(howMany)) howMany = 1\n   return howMany\n  }\nbelowAsCodeUntilParser\n description Print code above until match.\n extends belowAsCodeParser\n catchAllAtomType anyAtom\n example\n  belowAsCode\n  counter 1 second\n javascript\n  get howMany() {\n    let howMany = 1\n    const query = this.content\n    let particle = this.next\n    while (particle !== this) {\n      if (particle.getLine().startsWith(query))\n        return howMany\n      particle = particle.next\n      howMany++\n    }\n    return howMany\n  }\naboveAsCodeParser\n popularity 0.000482\n description Print code above.\n example\n  counter 1 second\n  aboveAsCode\n extends belowAsCodeParser\n javascript\n  method = \"previous\"\n  reverse = true\nscrollFooterParser\n extends abstractScrollParser\n description Move section to file footer.\n atoms preBuildCommandAtom\n cue footer\n javascript\n  compile() {\n   return \"\"\n  }\nhakonParser\n cueFromId\n extends abstractScrollParser\n description Compile Hakon to CSS.\n catchAllParser hakonContentParser\n javascript\n  compile() {\n   return `<style>${this.css}</style>`\n  }\n  get css() {\n    const {hakonParser} = this.root\n    return new hakonParser(this.subparticlesToString()).compile()\n  }\n  compileCss() {\n    return this.css\n  }\nhamlParser\n popularity 0.007524\n description HTML tag via HAML syntax.\n extends abstractScrollParser\n atoms urlAtom\n catchAllAtomType stringAtom\n pattern ^[\\w\\.]+#[\\w\\.]+ *\n javascript\n  get tag() {\n    return this.atoms[0].split(/[#\\.]/).shift()\n  }\n  get htmlId() {\n    const idMatch = this.atoms[0].match(/#([\\w-]+)/)\n    return idMatch ? idMatch[1] : \"\"\n  }\n  get htmlClasses() {\n    return this.atoms[0].match(/\\.([\\w-]+)/g)?.map(cls => cls.slice(1)) || [];\n  }\n  compile() {\n   const {htmlId, htmlClasses, content, tag} = this\n   this.parent.sectionStack.push(`</${tag}>`)\n   return `<${tag} ${htmlId ? ' id=\"' + htmlId + '\"' : \"\"} ${htmlClasses ? ' class=\"' + htmlClasses.join(\" \") + '\"' : \"\"}>${content || \"\"}`\n  }\n  compileTxt() {\n    return this.content\n  }\nabstractHtmlParser\n extends abstractScrollParser\n catchAllParser htmlLineParser\n catchAllAtomType htmlAnyAtom\n javascript\n  compile() {\n   return `${this.content ?? \"\"}${this.subparticlesToString()}`\n  }\n  compileTxt() {\n    return \"\"\n  }\nhtmlParser\n popularity 0.000048\n extends abstractHtmlParser\n description HTML one liners or blocks.\n cueFromId\nhtmlInlineParser\n popularity 0.005788\n extends abstractHtmlParser\n atoms htmlAnyAtom\n boolean isHtml true\n pattern ^<\n description Inline HTML.\n boolean isPopular true\n javascript\n  compile() {\n   return `${this.getLine() ?? \"\"}${this.subparticlesToString()}`\n  }\nscrollBrParser\n popularity 0.000096\n cue br\n description A break.\n extends abstractScrollParser\n catchAllAtomType integerAtom\n boolean isHtml true\n javascript\n  compile() {\n   return `<br>`.repeat(parseInt(this.getAtom(1) || 1))\n  }\niframesParser\n popularity 0.000121\n cueFromId\n catchAllAtomType urlAtom\n extends abstractScrollParser\n description An iframe(s).\n example\n  iframes frame.html\n javascript\n  compile() {\n   return this.atoms.slice(1).map(url => `<iframe src=\"${url}\" frameborder=\"0\"></iframe>`).join(\"\\n\")\n  }\nabstractCaptionedParser\n extends abstractScrollParser\n atoms cueAtom urlAtom\n inScope captionAftertextParser slashCommentParser\n cueFromId\n javascript\n  compile(compileSettings) {\n   const caption = this.getParticle(\"caption\")\n   const captionFig = caption ? `<figcaption>${caption.compile()}</figcaption>` : \"\"\n   const {figureWidth} = this\n   const widthStyle = figureWidth ? `width:${figureWidth}px; margin: auto;` : \"\"\n   const float = this.has(\"float\") ? `margin: 20px; float: ${this.get(\"float\")};` : \"\"\n   return `<figure class=\"scrollCaptionedFigure\" style=\"${widthStyle + float}\">${this.getFigureContent(compileSettings)}${captionFig}</figure>`\n  }\n  get figureWidth() {\n    return this.get(\"width\")\n  }\nscrollImageParser\n cue image\n popularity 0.005908\n description An img tag.\n boolean isPopular true\n extends abstractCaptionedParser\n int atomIndex 1\n example\n  image screenshot.png\n   caption A caption.\n inScope classMarkupParser aftertextIdParser linkParser linkTargetParser openGraphParser\n javascript\n  get dimensions() {\n    const width = this.get(\"width\")\n    const height = this.get(\"height\")\n    if (width || height)\n      return {width, height}\n    if (!this.isNodeJs())\n      return {}\n    const src = this.filename\n    // If its a local image, get the dimensions and put them in the HTML\n    // to avoid flicker\n   if (src.startsWith(\"http:\") || src.startsWith(\"https:\")) return {}\n   const file = this.root.file\n    if (this._dimensions)\n      return this._dimensions\n    try {\n     const sizeOf = require(\"image-size\")\n     const path = require(\"path\")\n     const fullImagePath = path.join(file.folderPath, src)\n     this._dimensions = sizeOf(fullImagePath)\n     return this._dimensions\n    } catch (err) {\n     console.error(err)\n    }\n    return {}\n  }\n  get figureWidth() {\n    return this.dimensions.width\n  }\n  get filename() {\n    return this.getAtom(this.atomIndex)\n  }\n  getFigureContent(compileSettings) {\n   const file = this.root.file\n   const linkRelativeToCompileTarget = (compileSettings ? (compileSettings.relativePath ?? \"\") : \"\") + this.filename\n   const {width, height} = this.dimensions\n   let dimensionAttributes = width || height  ? `width=\"${width}\" height=\"${height}\" ` : \"\"\n   // Todo: can we reuse more code from aftertext?\n   const className = this.has(\"class\") ? ` class=\"${this.get(\"class\")}\" ` : \"\"\n   const id = this.has(\"id\") ? ` id=\"${this.get(\"id\")}\" ` : \"\"\n   const clickLink = this.find(particle => particle.definition.isOrExtendsAParserInScope([\"linkParser\"])) || linkRelativeToCompileTarget \n   const target = this.has(\"target\") ? this.get(\"target\") : (this.has(\"link\") ? \"\" : \"_blank\")\n   return `<a href=\"${clickLink}\" target=\"${target}\" ${className} ${id}><img src=\"${linkRelativeToCompileTarget}\" ${dimensionAttributes}loading=\"lazy\"></a>`\n  }\n  compileTxt() {\n    const subparticles = this.filter(particle => particle.compileTxt).map(particle => particle.compileTxt()).filter(i => i).join(\"\\n\")\n    return  \"[Image Omitted]\" + (subparticles ? \"\\n \" + subparticles.replace(/\\n/g, \"\\n \") : \"\")\n  }\nquickImageParser\n popularity 0.005788\n extends scrollImageParser\n atoms urlAtom\n pattern ^[^\\s]+\\.(jpg|jpeg|png|gif|webp|svg|bmp)\n int atomIndex 0\nqrcodeParser\n extends abstractCaptionedParser\n description Make a QR code from a link.\n example\n  qrcode https://scroll.pub\n javascript\n  getFigureContent() {\n    const url = this.atoms[1]\n    const isNode = this.isNodeJs()\n    if (isNode) {\n      const {EXTERNALS_PATH} = this.root.file\n      const path = require(\"path\")\n      const {qrcodegen, toSvgString} = require(path.join(EXTERNALS_PATH, \"qrcodegen.js\"))\n      const QRC = qrcodegen.QrCode;\n      const qr0 = QRC.encodeText(url, QRC.Ecc.MEDIUM);\n      const svg = toSvgString(qr0, 4);  // See qrcodegen-input-demo\n      return svg\n    }\n    return `Not yet supported in browser.`\n  }\nyoutubeParser\n popularity 0.000121\n extends abstractCaptionedParser\n // Include the YouTube embed URL such as https://www.youtube.com/embed/CYPYZnVQoLg\n description A YouTube video widget.\n example\n  youtube https://www.youtube.com/watch?v=lO8blNtYYBA\n javascript\n  getFigureContent() {\n   const url = this.getAtom(1).replace(\"youtube.com/watch?v=\", \"youtube.com/embed/\")\n   return `<div class=\"scrollYouTubeHolder\"><iframe class=\"scrollYouTubeEmbed\" src=\"${url}\" frameborder=\"0\" allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe></div>`\n  }\nyouTubeParser\n extends youtubeParser\n tags deprecate\n // Deprecated. You youtube all lowercase.\nimportParser\n description Import a file.\n popularity 0.007524\n cueFromId\n atoms preBuildCommandAtom\n extends abstractScrollParser\n catchAllAtomType filePathAtom\n javascript\n  compile() {\n   return \"\"\n  }\n example\n  import header.scroll\nquickImportParser\n popularity 0.007524\n description Import a Scroll or Parsers file.\n extends abstractScrollParser\n boolean isPopular true\n atoms urlAtom\n pattern ^[^\\s]+\\.(scroll|parsers)$\n javascript\n  compile() {\n   return \"\"\n  }\n example\n  header.scroll\njsonScriptParser\n popularity 0.007524\n cueFromId\n description Include JSON and assign to window.\n extends abstractScrollParser\n atoms cueAtom urlAtom\n javascript\n  compile() {\n   const varName = this.filename.split(\"/\").pop().replace(\".json\", \"\")\n   return `<script>window.${varName} = ${this.root.readFile(this.filename)}</script>`\n  }\n  get filename() {\n     return this.getAtom(1)\n  }\nscrollLeftRightButtonsParser\n popularity 0.006342\n cue leftRightButtons\n description Previous and next nav buttons.\n extends abstractScrollParser\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n    const file = this.parent.file\n    const { linkToPrevious, linkToNext } = file\n    if (!linkToPrevious) return \"\"\n    const style = `a.keyboardNav {display:block;position:absolute;top:0.25rem; color: rgba(204,204,204,.8); font-size: 1.875rem; line-height: 1.7rem;}a.keyboardNav:hover{color: #333;text-decoration: none;}`\n    return `<style>${style}</style><a class=\"keyboardNav doNotPrint\" style=\"left:.5rem;\" href=\"${linkToPrevious}\">&lt;</a><a class=\"keyboardNav doNotPrint\" style=\"right:.5rem;\" href=\"${linkToPrevious}\">&gt;</a>`\n  }\nkeyboardNavParser\n popularity 0.007476\n description Make left and right navigate files.\n extends abstractScrollParser\n cueFromId\n catchAllAtomType urlAtom\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n   const file = this.root.file\n   const linkToPrevious = this.getAtom(1) ?? file.linkToPrevious\n   const linkToNext = this.getAtom(2) ?? file.linkToNext\n   const script = `<script>document.addEventListener('keydown', function(event) {\n    if (document.activeElement !== document.body) return\n    if (event.altKey || event.ctrlKey || event.metaKey || event.shiftKey) return // dont interfere with keyboard back button shortcut\n    const getLinks = () => document.getElementsByClassName(\"scrollKeyboardNav\")[0].getElementsByTagName(\"a\")\n    if (event.key === \"ArrowLeft\")\n      getLinks()[0].click()\n    else if (event.key === \"ArrowRight\")\n      getLinks()[1].click()\n   });</script>`\n   return `<div class=\"scrollKeyboardNav\" style=\"display:none;\"><a href=\"${linkToPrevious}\">${linkToPrevious}</a> · ${file.permalink} · <a href=\"${linkToNext}\">${linkToNext}</a>${script}</div>`\n  }\nprintUsageStatsParser\n popularity 0.000096\n // todo: if we include the atom \"Parser\" in a cue, bad things seem to happen.\n description Parser usage stats for folder.\n extends abstractScrollParser\n cueFromId\n javascript\n  get stats() {\n   const input = this.root.file.allScrollFiles.map(file => file.parserIds.join(\"\\n\")).join(\"\\n\")\n   const result = input.split('\\n').reduce((acc, atom) => (acc[atom] = (acc[atom] || 0) + 1, acc), {})\n   const rows = Object.entries(result).map(([atom, count]) => { return {atom, count}})\n   const sorted = this.lodash.sortBy(rows, \"count\").reverse()\n   return \"parserId uses\\n\" + sorted.map(row => `${row.atom} ${row.count}`).join('\\n')\n  }\n  get lodash() {\n    return this.isNodeJs() ? require(\"lodash\") : lodash\n  }\n  compile() {\n    // A hacky but simple way to do this for now.\n   const particle = this.appendSibling(\"table\")\n   particle.appendLine(\"delimiter  \")\n   particle.appendLine(\"printTable\")\n   const dataParticle = particle.appendLine(\"data\")\n    dataParticle.setSubparticles(this.stats)\n   const html = particle.compile()\n   particle.destroy()\n   return html\n  }\n  compileTxt() {\n    return this.stats\n  }\n  compileCsv() {\n    return this.stats.replace(/ /g, \",\")\n  }\nprintScrollLeetSheetParser\n popularity 0.000024\n description Print Scroll parser leet sheet.\n extends abstractScrollParser\n cueFromId\n javascript\n  get parsersToDocument() {\n    const clone = this.root.clone()\n    clone.setSubparticles(\"\")\n    const atoms = clone.getAutocompleteResultsAt(0,0).matches.map(a => a.text)\n    atoms.push(\"blankline\") // manually add blank line\n    atoms.push(\"Catch All Paragraph.\") // manually add catch all paragraph\n    atoms.push(\"<h></h>\") // manually add html\n    atoms.sort()\n    clone.setSubparticles(atoms.join(\"\\n\").replace(/blankline/, \"\")) // insert blank line in right spot\n    return clone\n  }\n  sortDocs(docs) {\n    return docs.map(particle => {\n      const {definition} = particle\n      const {id, description, isPopular, examples, popularity} = definition\n      const tags = definition.get(\"tags\") || \"\"\n      if (tags.includes(\"deprecate\") || tags.includes(\"experimental\"))\n        return null\n      const category = this.getCategory(tags)\n      const note = this.getNote(category)\n      return {id: definition.cueIfAny || id, description, isPopular, examples, note, popularity: Math.ceil(parseFloat(popularity) * 100000)}\n     }).filter(i => i).sort((a, b) => a.id.localeCompare(b.id))\n  }\n  makeLink(examples, cue) {\n    // if (!examples.length) console.log(cue) // find particles that need docs\n    const example = examples.length ? examples[0].subparticlesToString() : cue\n    const base = `https://try.scroll.pub/`\n    const particle = new Particle()\n    particle.appendLineAndSubparticles(\"scroll\", \"theme gazette\\n\" + example)\n    return base + \"#\" + encodeURIComponent(particle.asString)\n  }\n  docToHtml(doc) {\n   const css = `#scrollLeetSheet {color: grey;} #scrollLeetSheet a {color: #3498db; }`\n   return `<style>${css}</style><div id=\"scrollLeetSheet\">` + doc.map(obj => `<div class=\"${obj.category}\"><a href=\"${this.makeLink(obj.examples, obj.id)}\">${obj.isPopular ? \"<b>\" : \"\"}${obj.id}</a> ${obj.description}${obj.isPopular ? \"</b>\" : \"\"}${obj.note}</div>`).join(\"\\n\") + \"</div>\"\n  }\n  compile() {\n    return this.docToHtml(this.sortDocs(this.parsersToDocument))\n  }\n  compileTxt() {\n   return this.sortDocs(this.parsersToDocument).map(obj => `${obj.id} - ${obj.description}`).join(\"\\n\")\n  }\n  get lodash() {\n    return require(\"lodash\")\n  }\n  getCategory(input) {\n    return \"\"\n  }\n  getNote() {\n    return \"\"\n  }\n  compileCsv() {\n    const rows = this.sortDocs(this.parsersToDocument).map(obj => {\n      const {id, isPopular, description, popularity, category} = obj\n      return {\n        id,\n        isPopular,\n        description,\n        popularity,\n        category\n      }\n    })\n    return new Particle(this.lodash.sortBy(rows, \"isPopular\")).asCsv\n  }\nprintparsersLeetSheetParser\n popularity 0.000024\n // todo: fix parse bug when atom Parser appears in parserId\n extends printScrollLeetSheetParser\n description Parsers leetsheet.\n javascript\n  compile() {\n    return \"<p><b>Parser Definition Parsers</b> define parsers that acquire, analyze and act on code.</p>\" + this.docToHtml(this.sortDocs(this.parsersToDocument)) + \"<p><b>Atom Definition Parsers</b> analyze the atoms in a line.</p>\" + this.docToHtml(this.sortDocs(this.atomParsersToDocument))\n  }\n  makeLink() {\n    return \"\"\n  }\n  categories = \"assemblePhase acquirePhase analyzePhase actPhase\".split(\" \")\n  getCategory(tags) {\n    return tags.split(\" \").filter(w => w.endsWith(\"Phase\"))[0]\n  }\n  getNote(category) {\n    return ` <span class=\"note\">A${category.replace(\"Phase\", \"\").substr(1)}Time.</span>`\n  }\n  get atomParsersToDocument() {\n    const parsersParser = require(\"scrollsdk/products/parsers.nodejs.js\")\n    const clone = new parsersParser(\"anyAtom\\n \").clone()\n    const parserParticle = clone.getParticle(\"anyAtom\")\n    const atoms = clone.getAutocompleteResultsAt(1,1).matches.map(a => a.text)\n    atoms.sort()\n    parserParticle.setSubparticles(atoms.join(\"\\n\"))\n    return parserParticle\n  }\n  get parsersToDocument() {\n    const parsersParser = require(\"scrollsdk/products/parsers.nodejs.js\")\n    const clone = new parsersParser(\"latinParser\\n \").clone()\n    const parserParticle = clone.getParticle(\"latinParser\")\n    const atoms = clone.getAutocompleteResultsAt(1,1).matches.map(a => a.text)\n    atoms.sort()\n    parserParticle.setSubparticles(atoms.join(\"\\n\"))\n    clone.appendLine(\"myParser\")\n    clone.appendLine(\"myAtom\")\n    return parserParticle\n  }\nabstractMeasureParser\n atoms measureNameAtom\n cueFromId\n boolean isMeasure true\n float sortIndex 1.9\n boolean isComputed false\n string typeForWebForms text\n extends abstractScrollParser\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n   return \"\"\n  }\n  get measureValue() {\n    return this.content ?? \"\"\n  }\n  get measureName() {\n    return this.getCuePath().replace(/ /g, \"_\")\n  }\nabstractAtomMeasureParser\n description A measure that contains a single atom.\n atoms measureNameAtom atomAtom\n extends abstractMeasureParser\nabstractEmailMeasureParser\n string typeForWebForms email\n atoms measureNameAtom emailAddressAtom\n extends abstractAtomMeasureParser\nabstractUrlMeasureParser\n string typeForWebForms url\n atoms measureNameAtom urlAtom\n extends abstractAtomMeasureParser\nabstractStringMeasureParser\n catchAllAtomType stringAtom\n extends abstractMeasureParser\nabstractIdParser\n cue id\n description What is the ID of this concept?\n extends abstractStringMeasureParser\n float sortIndex 1\n boolean isMeasureRequired true\n boolean isConceptDelimiter true\n javascript\n  getErrors() {\n    const errors = super.getErrors()\n    let requiredMeasureNames = this.parent.file.measures.filter(measure => measure.isMeasureRequired).map(measure => measure.Name).filter(name => name !== \"id\")\n    if (!requiredMeasureNames.length) return errors\n    let next = this.next\n    while (requiredMeasureNames.length && next.cue !== \"id\" && next.index !== 0) {\n      requiredMeasureNames = requiredMeasureNames.filter(i => i !== next.cue)\n      next = next.next\n    }\n    requiredMeasureNames.forEach(name =>\n      errors.push(this.makeError(`Concept \"${this.content}\" is missing required measure \"${name}\".`))\n    )\n    return errors\n  }\nabstractTextareaMeasureParser\n string typeForWebForms textarea\n extends abstractMeasureParser\n baseParser blobParser\n javascript\n  get measureValue() {\n    return this.subparticlesToString().replace(/\\n/g, \"\\\\n\")\n  }\nabstractNumericMeasureParser\n string typeForWebForms number\n extends abstractMeasureParser\n javascript\n  get measureValue() {\n    const {content} = this\n    return content === undefined ? \"\" : parseFloat(content)\n  }\nabstractIntegerMeasureParser\n atoms measureNameAtom integerAtom\n extends abstractNumericMeasureParser\nabstractFloatMeasureParser\n atoms measureNameAtom floatAtom\n extends abstractNumericMeasureParser\nabstractPercentageMeasureParser\n atoms measureNameAtom percentAtom\n extends abstractNumericMeasureParser\n javascript\n  get measureValue() {\n    const {content} = this\n    return content === undefined ? \"\" : parseFloat(content)\n  }\nabstractEnumMeasureParser\n atoms measureNameAtom enumAtom\n extends abstractMeasureParser\nabstractBooleanMeasureParser\n atoms measureNameAtom booleanAtom\n extends abstractMeasureParser\n javascript\n  get measureValue() {\n    const {content} = this\n    return content === undefined ? \"\" : content == \"true\"\n  }\nmetaTagsParser\n popularity 0.007693\n cueFromId\n extends abstractScrollParser\n description Print meta tags including title.\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\n  compile() {\n   const { title, description, openGraphImage, SCROLL_VERSION, canonicalUrl, gitRepo } = this.parent.file\n   const rssFeedUrl = this.parent.get(\"rssFeedUrl\")\n   const favicon = this.parent.get(\"favicon\")\n   const faviconTag = favicon ? `<link rel=\"icon\" href=\"${favicon}\">` : \"\"\n   const rssTag = rssFeedUrl ? `<link rel=\"alternate\" type=\"application/rss+xml\" title=\"${title}\" href=\"${rssFeedUrl}\">` : \"\"\n   const gitTag = gitRepo ? `<link rel=\"source\" type=\"application/git\" title=\"Source Code Repository\" href=\"${gitRepo}\">` : \"\"\n   return `<head>\n   <meta charset=\"utf-8\">\n   <title>${title}</title>\n   <script>/* This HTML was generated by 📜 Scroll v${SCROLL_VERSION}. https://scroll.pub */</script>\n   <style>@media print {.doNotPrint {display: none !important;}}</style>\n   <link rel=\"canonical\" href=\"${canonicalUrl}\">\n   <meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n   <meta name=\"description\" content=\"${description}\">\n   <meta name=\"generator\" content=\"Scroll v${SCROLL_VERSION}\">\n   <meta property=\"og:title\" content=\"${title}\">\n   <meta property=\"og:description\" content=\"${description}\">\n   <meta property=\"og:image\" content=\"${openGraphImage}\">\n   ${faviconTag}\n   ${gitTag}\n   ${rssTag}\n   <meta name=\"twitter:card\" content=\"summary_large_image\">\n  </head>\n  <body>`\n  }\nscrollParserDefinitionParser\n popularity 0.000096\n extends abstractScrollParser\n // todo Figure out best pattern for merging Scroll and Parsers?\n pattern ^[a-zA-Z0-9_]+Parser$\n description Define your own Parsers.\n baseParser blobParser\n javascript\n  compile() {\n   return \"\"\n  }\nquoteParser\n popularity 0.001471\n cueFromId\n description A quote.\n catchAllParser quoteLineParser\n extends abstractScrollParser\n javascript\n  compile() {\n   return `<blockquote class=\"scrollQuote\">${this.subparticlesToString()}</blockquote>`\n  }\n  compileTxt() {\n    return this.subparticlesToString()\n  }\nredirectToParser\n popularity 0.000072\n description HTML redirect tag.\n extends abstractScrollParser\n atoms cueAtom urlAtom\n cueFromId\n example\n  redirectTo https://scroll.pub/releaseNotes.html\n javascript\n  compile() {\n   return `<meta http-equiv=\"Refresh\" content=\"0; url='${this.getAtom(1)}'\" />`\n  }\nabstractVariableParser\n extends abstractScrollParser\n catchAllAtomType stringAtom\n atoms preBuildCommandAtom\n cueFromId\n javascript\n  isTopMatter = true\n  compile() {\n   return \"\"\n  }\nreplaceParser\n description Replace this with that.\n extends abstractVariableParser\n baseParser blobParser\n example\n  replace YEAR 2022\nreplaceJsParser\n description Replace this with evaled JS.\n extends replaceParser\n catchAllAtomType javascriptAtom\n example\n  replaceJs SUM 1+1\n  * 1+1 = SUM\nreplaceNodejsParser\n description Replace with evaled Node.JS.\n extends abstractVariableParser\n catchAllAtomType javascriptAtom\n baseParser blobParser\n example\n  replaceNodejs\n   module.exports = {SCORE : 1 + 2}\n  * The score is SCORE\nscriptParser\n extends abstractScrollParser\n description Print script tag.\n cueFromId\n catchAllParser scriptLineParser\n catchAllAtomType scriptAnyAtom\n javascript\n  compile() {\n   return `<script>${this.scriptContent}</script>`\n  }\n  get scriptContent() {\n    return this.content ?? this.subparticlesToString()\n  }\n  compileJs() {\n    return this.scriptContent\n  }\nendSnippetParser\n popularity 0.004293\n description Cut for snippet here.\n extends abstractScrollParser\n cueFromId\n javascript\n  compile() {\n   return \"\"\n  }\nstampParser\n description Expand project template to disk.\n extends abstractScrollParser\n inScope stampFolderParser\n catchAllParser stampFileParser\n example\n  stamp\n   .gitignore\n    *.html\n   readme.scroll\n    # Hello world\n    <script src=\"scripts/nested/hello.js\"></script>\n   scripts/\n    nested/\n     hello.js\n      console.log(\"Hello world\")\n cueFromId\n atoms preBuildCommandAtom\n javascript\n  build() {\n    const dir = this.root.file.folderPath\n    this.forEach(particle => particle.build(dir))\n  }\nstumpParser\n cueFromId\n extends abstractScrollParser\n description Compile Stump to HTML.\n catchAllParser stumpContentParser\n javascript\n  compile() {\n   const file = this.parent.file\n   return file.compileStumpCode(this.subparticlesToString())\n  }\nstumpNoSnippetParser\n popularity 0.010177\n // todo: make noSnippets an aftertext directive?\n extends stumpParser\n description Compile Stump unless snippet.\n cueFromId\n javascript\n  compileEmbeddedVersion() {\n   return \"\"\n  }\nassertHtmlEqualsParser\n description Test above particle's output.\n extends abstractScrollParser\n cueFromId\n baseParser blobParser\n javascript\n  compile() {\n   return ``\n  }\n  getErrors() {\n    const actual = this._getClosestOlderSibling().compile()\n    const expected = this.subparticlesToString()\n    if (actual === expected)\n    \treturn []\n    return [this.makeError(`'${actual}' did not match '${expected}'`)]\n  }\n catchAllParser htmlLineParser\nplainTextParser\n description Plain text oneliner or block.\n cueFromId\n extends abstractScrollParser\n catchAllParser plainTextLineParser\n catchAllAtomType stringAtom\n javascript\n  compile() {\n   return this.compileTxt()\n  }\n  compileTxt() {\n    return `${this.content ?? \"\"}${this.subparticlesToString()}`\n  }\nplainTextOnlyParser\n popularity 0.000072\n extends plainTextParser\n description Only print for buildTxt.\n javascript\n  compile() {\n   return \"\"\n  }\nscrollThemeParser\n popularity 0.007524\n boolean isPopular true\n cue theme\n extends abstractScrollParser\n catchAllAtomType scrollThemeAtom\n description A collection of simple themes.\n string copyFromExternal gazette.css\n  // Note this will be replaced at runtime\n javascript\n  get copyFromExternal() {\n   return this.files.join(\" \")\n  }\n  get files() {\n    return this.atoms.slice(1).map(name => `${name}.css`)\n  }\n  compile() {\n   return this.files.map(name => `<link rel=\"stylesheet\" type=\"text/css\" href=\"${name}\">`).join(\"\\n\")\n  }\nabstractAftertextAttributeParser\n atoms cueAtom\n boolean isAttribute true\n javascript\n  get htmlAttributes() {\n   return `${this.cue}=\"${this.content}\"`\n  }\n  compile() {\n   return \"\"\n  }\naftertextIdParser\n popularity 0.000145\n cue id\n description Provide an ID to be output in the generated HTML tag.\n extends abstractAftertextAttributeParser\n atoms cueAtom htmlIdAtom\n single\naftertextStyleParser\n popularity 0.000217\n cue style\n description Provide code for the generated HTML tag's \"style\" attribute.\n extends abstractAftertextAttributeParser\n atoms cueAtom\n catchAllAtomType cssAnyAtom\naftertextHiddenParser\n cue hidden\n atoms cueAtom\n description Do not compile this particle to HTML.\n extends abstractAftertextAttributeParser\n single\naftertextTagParser\n atoms cueAtom htmlTagAtom\n description Override the HTML tag that the compiled particle will use.\n cue tag\n javascript\n  compile() {\n   return \"\"\n  }\nabstractAftertextDirectiveParser\n atoms cueAtom\n catchAllAtomType stringAtom\n javascript\n  isMarkup = true\n  compile() {\n   return \"\"\n  }\n  getErrors() {\n    const errors = super.getErrors()\n    if (!this.isMarkup || this.matchWholeLine) return errors\n    const inserts = this.getInserts(this.parent.originalTextPostLinkify)\n    // todo: make AbstractParticleError class exported by sdk to allow Parsers to define their own error types.\n    // todo: also need to be able to map lines back to their line in source (pre-imports)\n    if (!inserts.length)\n     errors.push(this.makeError(`No match found for \"${this.getLine()}\".`))\n    return errors\n  }\n  get pattern() {\n   return this.getAtomsFrom(1).join(\" \")\n  }\n  get shouldMatchAll() {\n   return this.has(\"matchAll\")\n  }\n  getMatches(text) {\n   const { pattern } = this\n   const escapedPattern = pattern.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\")\n   return [...text.matchAll(new RegExp(escapedPattern, \"g\"))].map(match => {\n    const { index } = match\n    const endIndex = index + pattern.length\n    return [\n     { index, string: `<${this.openTag}${this.allAttributes}>`, endIndex },\n     { index: endIndex, endIndex, string: `</${this.closeTag}>` }\n    ]\n   })\n  }\n  getInserts(text) {\n   const matches = this.getMatches(text)\n   if (!matches.length) return false\n   if (this.shouldMatchAll) return matches.flat()\n   const match = this.getParticle(\"match\")\n   if (match)\n    return match.indexes\n     .map(index => matches[index])\n     .filter(i => i)\n     .flat()\n   return matches[0]\n  }\n  get allAttributes() {\n   const attr = this.attributes.join(\" \")\n   return attr ? \" \" + attr : \"\"\n  }\n  get attributes() {\n   return []\n  }\n  get openTag() {\n   return this.tag\n  }\n  get closeTag() {\n   return this.tag\n  }\nabstractMarkupParser\n extends abstractAftertextDirectiveParser\n inScope abstractMarkupParameterParser\n javascript\n  get matchWholeLine() {\n    return this.getAtomsFrom(this.patternStartsAtAtom).length === 0\n  }\n  get pattern() {\n   return this.matchWholeLine ? this.parent.originalText : this.getAtomsFrom(this.patternStartsAtAtom).join(\" \")\n  }\n  patternStartsAtAtom = 1\nboldParser\n popularity 0.000096\n cueFromId\n description Bold matching text.\n extends abstractMarkupParser\n javascript\n  tag = \"b\"\nitalicsParser\n popularity 0.000241\n cueFromId\n description Italicize matching text.\n extends abstractMarkupParser\n javascript\n  tag = \"i\"\nunderlineParser\n popularity 0.000024\n description Underline matching text.\n cueFromId\n extends abstractMarkupParser\n javascript\n  tag = \"u\"\nafterTextCenterParser\n popularity 0.000193\n description Center paragraph.\n cue center\n extends abstractMarkupParser\n javascript\n  tag = \"center\"\naftertextCodeParser\n popularity 0.000145\n description Wrap matching text in code span.\n cue code\n extends abstractMarkupParser\n javascript\n  tag = \"code\"\naftertextStrikeParser\n popularity 0.000048\n description Wrap matching text in s span.\n cue strike\n extends abstractMarkupParser\n javascript\n  tag = \"s\"\nclassMarkupParser\n popularity 0.000772\n description Add a custom class to the parent element instead. If matching text provided, a span with the class will be added around the matching text.\n extends abstractMarkupParser\n atoms cueAtom classNameAtom\n cue class\n javascript\n  tag = \"span\"\n  get applyToParentElement() {\n   return this.atoms.length === 2\n  }\n  getInserts(text) {\n   // If no select text is added, set the class on the parent element.\n   if (this.applyToParentElement) return []\n   return super.getInserts(text)\n  }\n  get className() {\n   return this.getAtom(1)\n  }\n  get attributes() {\n   return [`class=\"${this.className}\"`]\n  }\n  get matchWholeLine() {\n    return this.applyToParentElement\n  }\n  get pattern() {\n   return this.matchWholeLine ? this.parent.content : this.getAtomsFrom(2).join(\" \")\n  }\nclassesMarkupParser\n extends classMarkupParser\n cue classes\n javascript\n  applyToParentElement = true\n  get className() {\n   return this.content\n  }\nhoverNoteParser\n popularity 0.000265\n description Add a caveat viewable on hover on matching text. When you want to be sure you've thoroughly addressed obvious concerns but ones that don't warrant to distract from the main argument of the text.\n cueFromId\n extends classMarkupParser\n catchAllParser lineOfTextParser\n atoms cueAtom\n javascript\n  get pattern() {\n   return this.getAtomsFrom(1).join(\" \")\n  }\n  get attributes() {\n   return [`class=\"scrollHoverNote\"`, `title=\"${this.hoverNoteText}\"`]\n  }\n  get hoverNoteText() {\n   return this.subparticlesToString().replace(/\\n/g, \" \")\n  }\nlinkParser\n popularity 0.008706\n extends abstractMarkupParser\n description Put the matching text in an <a> tag.\n atoms cueAtom urlAtom\n inScope linkTitleParser linkTargetParser commentParser\n programParser\n  description Anything here will be URI encoded and then appended to the link.\n  cueFromId\n  atoms cueAtom\n  catchAllParser programLinkParser\n  javascript\n   get encoded() {\n    return encodeURIComponent(this.subparticlesToString())\n   }\n cueFromId\n javascript\n  tag = \"a\"\n  compileTxt() {\n    return this.root.file.ensureAbsoluteLink(this.link) + \" \" + this.pattern\n  }\n  get link() {\n   const {baseLink} = this\n   if (this.has(\"program\"))\n     return baseLink + this.getParticle(\"program\").encoded\n   return baseLink\n  }\n  get baseLink() {\n   const link = this.getAtom(1)\n   const isAbsoluteLink = link.includes(\"://\")\n   if (isAbsoluteLink) return link\n   const relativePath = this.parent.compileSettings?.relativePath || \"\"\n   return relativePath + link\n  }\n  get attributes() {\n   const attrs = [`href=\"${this.link}\"`]\n   const options = [\"title\", \"target\"]\n   options.forEach(option => {\n    const particle = this.getParticle(option)\n    if (particle) attrs.push(`${option}=\"${particle.content}\"`)\n   })\n   return attrs\n  }\n  patternStartsAtAtom = 2\nemailLinkParser\n popularity 0.000048\n description A mailto link\n cue email\n extends linkParser\n javascript\n  get attributes() {\n   return [`href=\"mailto:${this.link}\"`]\n  }\nquickLinkParser\n popularity 0.029228\n pattern ^https?\\:\n extends linkParser\n atoms urlAtom\n javascript\n  get link() {\n   return this.cue\n  }\n  patternStartsAtAtom = 1\nquickRelativeLinkParser\n popularity 0.029228\n description Relative links.\n // note: only works if relative link ends in .html\n pattern ^[^\\s]+\\.(html|htm)\n extends linkParser\n atoms urlAtom\n javascript\n  get link() {\n   return this.cue\n  }\n  patternStartsAtAtom = 1\ndatelineParser\n popularity 0.006005\n cueFromId\n description Gives your paragraph a dateline like \"December 15, 2021 — The...\"\n extends abstractAftertextDirectiveParser\n javascript\n  getInserts() {\n   const {day} = this\n   if (!day) return false\n   return [{ index: 0, string: `<span class=\"scrollDateline\">${day} — </span>` }]\n  }\n  matchWholeLine = true\n  get day() {\n   let day = this.content || this.root.get(\"date\") || this.root.file?.date\n   if (!day) return \"\"\n   try {\n    const dayjs = require(\"dayjs\")\n    return dayjs(day).format(`MMMM D, YYYY`)\n   } catch (err) {\n    console.error(err)\n   }\n   return day || \"\"\n  }\ndayjsParser\n description Advanced directive that evals some Javascript code in an environment including \"dayjs\".\n cueFromId\n extends abstractAftertextDirectiveParser\n javascript\n  getInserts() {\n   const dayjs = require(\"dayjs\")\n   const days = eval(this.content)\n   const index = this.parent.originalTextPostLinkify.indexOf(\"days\")\n   return [{ index, string: `${days} ` }]\n  }\ninlineMarkupsOnParser\n popularity 0.000024\n cueFromId\n description Enable these inline markups only.\n example\n  Hello *world*!\n   inlineMarkupsOn bold\n extends abstractAftertextDirectiveParser\n catchAllAtomType inlineMarkupNameAtom\n javascript\n  get shouldMatchAll() {\n   return true\n  }\n  get markups() {\n    const {root} = this\n    let markups = [{delimiter: \"`\", tag: \"code\", exclusive: true, name: \"code\"},{delimiter: \"*\", tag: \"strong\", name: \"bold\"}, {delimiter: \"_\", tag: \"em\", name: \"italics\"}]\n    // only add katex markup if the root doc has katex.\n    if (root.has(\"katex\"))\n      markups.unshift({delimiter: \"$\", tag: \"span\", attributes: ' class=\"scrollKatex\"', exclusive: true, name: \"katex\"})\n    if (this.content)\n      return markups.filter(markup => this.content.includes(markup.name))\n    if (root.has(\"inlineMarkups\")) {\n      root.getParticle(\"inlineMarkups\").forEach(markup => {\n        const delimiter = markup.getAtom(0)\n        const tag = markup.getAtom(1)\n        // todo: add support for providing custom functions for inline markups?\n        // for example, !2+2! could run eval, or :about: could search a link map.\n        const attributes = markup.getAtomsFrom(2).join(\" \")\n        markups = markups.filter(mu => mu.delimiter !== delimiter) // Remove any overridden markups\n        if (tag)\n          markups.push({delimiter, tag, attributes})\n      })\n    }\n    return markups\n  }\n  matchWholeLine = true\n  getMatches(text) {\n   const exclusives = []\n   return this.markups.map(markup => this.applyMarkup(text, markup, exclusives)).filter(i => i).flat()\n  }\n  applyMarkup(text, markup, exclusives = []) {\n   const {delimiter, tag, attributes} = markup\n   const escapedDelimiter = delimiter.replace(/[-\\/\\\\^$*+?.()|[\\]{}]/g, \"\\\\$&\")\n   const pattern = new RegExp(`${escapedDelimiter}[^${escapedDelimiter}]+${escapedDelimiter}`, \"g\")\n   const delimiterLength = delimiter.length\n   return [...text.matchAll(pattern)].map(match => {\n    const { index } = match\n    const endIndex = index + match[0].length\n    // I'm too lazy to clean up sdk to write a proper inline markup parser so doing this for now.\n    // The exclusive idea is to not try and apply bold or italic styles inside a TeX or code inline style.\n    // Note that the way this is currently implemented any TeX in an inline code will get rendered, but code\n    // inline of TeX will not. Seems like an okay tradeoff until a proper refactor and cleanup can be done.\n    if (exclusives.some(exclusive => index >= exclusive[0] && index <= exclusive[1]))\n      return undefined\n    if (markup.exclusive)\n      exclusives.push([index, endIndex])\n    return [\n     { index, string: `<${tag + (attributes ? \" \" + attributes : \"\")}>`, endIndex, consumeStartCharacters: delimiterLength },\n     { index: endIndex, endIndex, string: `</${tag}>`, consumeEndCharacters: delimiterLength }\n    ]\n   }).filter(i => i)\n  }\ninlineMarkupParser\n popularity 0.000169\n cueFromId\n atoms cueAtom delimiterAtom tagOrUrlAtom\n catchAllAtomType htmlAttributesAtom\n extends inlineMarkupsOnParser\n description Custom inline markup. for\n example\n  @This@ will be in italics.\n   inlineMarkup @ em\n javascript\n  getMatches(text) {\n   try {\n    const delimiter = this.getAtom(1)\n    const tag = this.getAtom(2)\n    const attributes = this.getAtomsFrom(3).join(\" \")\n    return this.applyMarkup(text, {delimiter, tag, attributes})\n   } catch (err) {\n    console.error(err)\n    return []\n   }\n   // Note: doubling up doesn't work because of the consumption characters.\n  }\nlinkifyParser\n description Use this to disable linkify on the text.\n extends abstractAftertextDirectiveParser\n cueFromId\n atoms cueAtom booleanAtom\nabstractMarkupParameterParser\n atoms cueAtom\n cueFromId\nmatchAllParser\n popularity 0.000024\n description Use this to match all occurrences of the text.\n extends abstractMarkupParameterParser\nmatchParser\n popularity 0.000048\n catchAllAtomType integerAtom\n description Use this to specify which index(es) to match.\n javascript\n  get indexes() {\n   return this.getAtomsFrom(1).map(num => parseInt(num))\n  }\n example\n  aftertext\n   hello ello ello\n   bold ello\n    match 0 2\n extends abstractMarkupParameterParser\nabstractHtmlAttributeParser\n javascript\n  compile() {\n   return \"\"\n  }\nlinkTargetParser\n popularity 0.000024\n extends abstractHtmlAttributeParser\n description If you want to set the target of the link. To \"_blank\", for example.\n cue target\n atoms cueAtom anyAtom\nblankLineParser\n popularity 0.308149\n description Print nothing. Break section.\n atoms blankAtom\n boolean isPopular true\n javascript\n  compile() {\n   return this.parent.clearSectionStack()\n  }\n pattern ^$\n tags doNotSynthesize\nchatLineParser\n popularity 0.009887\n catchAllAtomType anyAtom\n catchAllParser chatLineParser\nlineOfCodeParser\n popularity 0.018665\n catchAllAtomType codeAtom\n catchAllParser lineOfCodeParser\ncommentLineParser\n catchAllAtomType commentAtom\ncssLineParser\n popularity 0.002870\n catchAllAtomType cssAnyAtom\n catchAllParser cssLineParser\nerrorParser\n baseParser errorParser\nabstractTableTransformParser\n atoms cueAtom\n inScope abstractTableVisualizationParser abstractTableTransformParser h1Parser h2Parser scrollQuestionParser scrollLoopParser htmlInlineParser scrollBrParser\n javascript\n  get coreTable() {\n    return this.parent.coreTable\n  }\n  get columnNames() {\n    return this.parent.columnNames\n  }\n  getRunTimeEnumOptions(atom) {\n   if (atom.atomTypeId === \"columnNameAtom\")\n      return this.parent.columnNames\n   return super.getRunTimeEnumOptions(atom)\n  }\n  getRunTimeEnumOptionsForValidation(atom) {\n    // Note: this will fail if the CSV file hasnt been built yet.\n    if (atom.atomTypeId === \"columnNameAtom\")\n      return this.parent.columnNames.concat(this.parent.columnNames.map(c => \"-\" + c)) // Add reverse names\n   return super.getRunTimeEnumOptions(atom)\n  }\nscrollGroupByParser\n catchAllAtomType columnNameAtom\n extends abstractTableTransformParser\n description Combine rows with matching values into groups.\n example\n  tables posts.csv\n   groupBy year\n    printTable\n cue groupBy\n javascript\n  get coreTable() {\n    if (this._coreTable) return this._coreTable\n   const groupByColNames = this.getAtomsFrom(1)\n   const {coreTable} = this.parent\n   if (!groupByColNames.length) return coreTable\n   const newCols = this.findParticles(\"reduce\").map(reduceParticle => {\n    return {\n     source: reduceParticle.getAtom(1),\n     reduction: reduceParticle.getAtom(2),\n     name: reduceParticle.getAtom(3) || reduceParticle.getAtomsFrom(1).join(\"_\")\n    }\n   })\n   // Pivot is shorthand for group and reduce?\n   const makePivotTable = (rows, groupByColumnNames, inputColumnNames, newCols) => {\n     const colMap = {}\n     inputColumnNames.forEach((col) => (colMap[col] = true))\n     const groupByCols = groupByColumnNames.filter((col) => colMap[col])\n     return new PivotTable(rows, inputColumnNames.map(c => {return {name: c}}), newCols).getNewRows(groupByCols)\n   }\n   class PivotTable {\n     constructor(rows, inputColumns, outputColumns) {\n       this._columns = {}\n       this._rows = rows\n       inputColumns.forEach((col) => (this._columns[col.name] = col))\n       outputColumns.forEach((col) => (this._columns[col.name] = col))\n     }\n     _getGroups(allRows, groupByColNames) {\n       const rowsInGroups = new Map()\n       allRows.forEach((row) => {\n         const groupKey = groupByColNames.map((col) => row[col]?.toString().replace(/ /g, \"\") || \"\").join(\" \")\n         if (!rowsInGroups.has(groupKey)) rowsInGroups.set(groupKey, [])\n         rowsInGroups.get(groupKey).push(row)\n       })\n       return rowsInGroups\n     }\n     getNewRows(groupByCols) {\n       // make new particles\n       const rowsInGroups = this._getGroups(this._rows, groupByCols)\n       // Any column in the group should be reused by the children\n       const columns = [\n         {\n           name: \"count\",\n           type: \"number\",\n           min: 0,\n         },\n       ]\n       groupByCols.forEach((colName) => columns.push(this._columns[colName]))\n       const colsToReduce = Object.values(this._columns).filter((col) => !!col.reduction)\n       colsToReduce.forEach((col) => columns.push(col))\n       // for each group\n       const rows = []\n       const totalGroups = rowsInGroups.size\n       for (let [groupId, group] of rowsInGroups) {\n         const firstRow = group[0]\n         const newRow = {}\n         groupByCols.forEach((col) =>\n           newRow[col] = firstRow ? firstRow[col] : 0\n         )\n         newRow.count = group.length\n         // todo: add more reductions? count, stddev, median, variance.\n         colsToReduce.forEach((col) => {\n           const sourceColName = col.source\n           const reduction = col.reduction\n           if (reduction === \"concat\") {\n              newRow[col.name] = group.map((row) => row[sourceColName]).join(\" \")\n              return \n           }\n           if (reduction === \"first\") {\n              newRow[col.name] = group[0][sourceColName]\n              return \n           }\n           const values = group.map((row) => row[sourceColName]).filter((val) => typeof val === \"number\" && !isNaN(val))\n           let reducedValue = firstRow[sourceColName]\n           if (reduction === \"sum\") reducedValue = values.reduce((prev, current) => prev + current, 0)\n           if (reduction === \"max\") reducedValue = Math.max(...values)\n           if (reduction === \"min\") reducedValue = Math.min(...values)\n           if (reduction === \"mean\") reducedValue = values.reduce((prev, current) => prev + current, 0) / values.length\n           newRow[col.name] = reducedValue\n         })\n         rows.push(newRow)\n       }\n       // todo: add tests. figure out this api better.\n       Object.values(columns).forEach((col) => {\n         // For pivot columns, remove the source and reduction info for now. Treat things as immutable.\n         delete col.source\n         delete col.reduction\n       })\n       return {\n         rows,\n         columns,\n       }\n     }\n   }\n   const pivotTable = makePivotTable(coreTable, groupByColNames, this.parent.columnNames, newCols)\n   this._coreTable = pivotTable.rows\n   this._columnNames = pivotTable.columns.map(col => col.name)\n   return pivotTable.rows\n  }\n  get columnNames() {\n    const {coreTable} = this\n    return this._columnNames || this.parent.columnNames\n  }\nscrollWhereParser\n extends abstractTableTransformParser\n description Filter rows by condition.\n cue where\n atoms cueAtom columnNameAtom comparisonAtom atomAtom\n example\n  table iris.csv\n   where Species = setosa\n javascript\n  get coreTable() {\n   // todo: use atoms here.\n   const columnName = this.getAtom(1)\n   const operator = this.getAtom(2)\n   let untypedScalarValue = this.getAtom(3)\n   const typedValue = isNaN(parseFloat(untypedScalarValue)) ? untypedScalarValue : parseFloat(untypedScalarValue)\n   const coreTable = this.parent.coreTable\n   if (!columnName || !operator || untypedScalarValue === undefined) return coreTable\n    const filterFn = row => {\n      const atom = row[columnName]\n      const typedAtom = atom\n      if (operator === \"=\") return typedValue === typedAtom\n      else if (operator === \"!=\") return typedValue !== typedAtom\n      else if (operator === \"includes\") return typedAtom !== undefined && typedAtom.includes(typedValue)\n      else if (operator === \"doesNotInclude\") return typedAtom === undefined || !typedAtom.includes(typedValue)\n      else if (operator === \">\") return typedAtom > typedValue\n      else if (operator === \"<\") return typedAtom < typedValue\n      else if (operator === \">=\") return typedAtom >= typedValue\n      else if (operator === \"<=\") return typedAtom <= typedValue\n      else if (operator === \"empty\") return atom === \"\" || atom === undefined\n      else if (operator === \"notEmpty\") return !(atom === \"\" || atom === undefined)\n    }\n   return coreTable.filter(filterFn)\n  }\nscrollSelectParser\n catchAllAtomType columnNameAtom\n extends abstractTableTransformParser\n description Drop all columns except these.\n example\n  tables\n   data\n    name,year,count\n    index,2022,2\n    about,2023,4\n   select name year\n    printTable\n cue select\n javascript\n  get coreTable() {\n   const {coreTable} = this.parent\n   const {columnNames} = this\n   if (!columnNames.length) return coreTable\n   return coreTable.map(row => Object.fromEntries(columnNames.map(colName => [colName, row[colName]])))\n  }\n  get columnNames() {\n    return this.getAtomsFrom(1)\n  }\nscrollReverseParser\n extends abstractTableTransformParser\n description Reverse rows.\n cue reverse\n javascript\n  get coreTable() {\n   return this.parent.coreTable.slice().reverse()\n  }\nscrollComposeParser\n extends abstractTableTransformParser\n description Add column using format string.\n catchAllAtomType stringAtom\n cue compose\n example\n  table\n   compose My name is {name}\n    printTable\n javascript\n  get coreTable() {\n   const {newColumnName} = this\n   const formatString = this.getAtomsFrom(2).join(\" \")\n   return this.parent.coreTable.map((row, index) => {\n     const newRow = Object.assign({}, row)\n     newRow[newColumnName] = this.evaluate(new Particle(row).evalTemplateString(formatString), index)\n     return newRow\n   })\n  }\n  evaluate(str) {\n    return str\n  }\n  get newColumnName() {\n    return this.atoms[1]\n  }\n  get columnNames() {\n    return this.parent.columnNames.concat(this.newColumnName)\n  }\nscrollComputeParser\n extends scrollComposeParser\n description Add column by evaling format string.\n catchAllAtomType stringAtom\n cue compute\n javascript\n  evaluate(str) {\n    return parseFloat(eval(str))\n  }\nscrollRankParser\n extends scrollComposeParser\n description Add rank column.\n string newColumnName rank\n cue rank\n javascript\n  evaluate(str, index) { return index + 1 }\nscrollLinksParser\n extends abstractTableTransformParser\n description Add column with links.\n cue links\n catchAllAtomType columnNameAtom\n javascript\n  get coreTable() {\n   const {newColumnName, linkColumns} = this\n   return this.parent.coreTable.map(row => {\n     const newRow = Object.assign({}, row)\n     let newValue = []\n     linkColumns.forEach(name => {\n       const value = newRow[name]\n       delete newRow[name]\n       if (value) newValue.push(`<a href=\"${value.includes(\"@\") ? \"mailto:\" : \"\"}${value}\">${name}</a>`)\n     })\n     newRow[newColumnName] = newValue.join(\" \")\n     return newRow\n   })\n  }\n  get newColumnName() {\n    return \"links\"\n  }\n  get linkColumns() {\n    return this.getAtomsFrom(1)\n  }\n  get columnNames() {\n    const {linkColumns} = this\n    return this.parent.columnNames.filter(name => !linkColumns.includes(name)).concat(this.newColumnName)\n  }\nscrollLimitParser\n extends abstractTableTransformParser\n description Select a subset.\n cue limit\n atoms cueAtom integerAtom integerAtom\n javascript\n  get coreTable() {\n   const start = this.getAtom(1)\n   const end = this.getAtom(2)\n   return this.parent.coreTable.slice(parseInt(start), parseInt(end))\n  }\nscrollTransposeParser\n extends abstractTableTransformParser\n description Tranpose table.\n cue transpose\n javascript\n  get coreTable() {\n   // todo: we need to switch to column based coreTable, instead of row based\n   const transpose = arr => Object.keys(arr[0]).map(key => [key, ...arr.map(row => row[key])]);\n   return transpose(this.parent.coreTable)\n  }\nscrollImputeParser\n extends abstractTableTransformParser\n description Impute missing values of a columm.\n atoms cueAtom columnNameAtom\n cue impute\n javascript\n  get coreTable() {\n   const {lodash, columnName} = this\n   const sorted = lodash.orderBy(this.parent.coreTable.slice(), columnName)\n   // ascending\n   const imputed = []\n   let lastInserted = sorted[0][columnName]\n   sorted.forEach(row => {\n    const measuredTime = row[columnName]\n    while (measuredTime > lastInserted + 1) {\n      lastInserted++\n      // synthesize rows\n      const imputedRow = {}\n      imputedRow[columnName] = lastInserted\n      imputedRow.count = 0\n      imputed.push(imputedRow)\n    }\n    lastInserted = measuredTime\n    imputed.push(row)\n   })\n   return imputed\n  }\n  get columnName() {\n    return this.getAtom(1)\n  }\n  get lodash() {\n    return this.isNodeJs() ? require(\"lodash\") : lodash\n  }\nscrollOrderByParser\n extends abstractTableTransformParser\n description Sort rows by column(s).\n catchAllAtomType columnNameAtom\n cue orderBy\n javascript\n  get coreTable() {\n    const makeLodashOrderByParams = str => {\n    const part1 = str.split(\" \")\n    const part2 = part1.map(col => (col.startsWith(\"-\") ? \"desc\" : \"asc\"))\n    return [part1.map(col => col.replace(/^\\-/, \"\")), part2]\n   }\n   const orderBy = makeLodashOrderByParams(this.content)\n   return this.lodash.orderBy(this.parent.coreTable.slice(), orderBy[0], orderBy[1])\n  }\n  get lodash() {\n    return this.isNodeJs() ? require(\"lodash\") : lodash\n  }\nscrollRenameParser\n // todo: add support in Parsers for tuple catch alls\n  catchAllAtomType columnNameAtom atomAtom\n catchAllAtomType atomAtom\n extends abstractTableTransformParser\n description Rename columns.\n example\n  tables\n   data\n    name,year,count\n    index,2022,2\n   rename name Name year Year\n    printTable\n cue rename\n javascript\n  get coreTable() {\n   const {coreTable} = this.parent\n   const {renameMap} = this\n   if (!Object.keys(renameMap).length) return coreTable\n   return coreTable.map(row => {\n      const newRow = {}\n      Object.keys(row).forEach(key => {\n        const name = renameMap[key] || key\n        newRow[name] = row[key]\n      })\n      return newRow\n   })\n  }\n  get renameMap() {\n    const map = {}\n    const pairs = this.getAtomsFrom(1)\n    let oldName\n    while (oldName = pairs.shift()) {\n      map[oldName] = pairs.shift()\n    }\n    return map\n  }\n  _renamed\n  get columnNames() {\n   if (this._renamed)\n     return this._renamed\n    const {renameMap} = this\n    this._renamed = this.parent.columnNames.map(name => renameMap[name] || name )\n    return this._renamed\n  }\nhakonContentParser\n popularity 0.102322\n catchAllAtomType anyAtom\nheatrixCatchAllParser\n popularity 0.000193\n // todo Fill this out\n catchAllAtomType stringAtom\nlineOfTextParser\n popularity 0.000289\n catchAllAtomType stringAtom\n boolean isTextParser true\nhtmlLineParser\n popularity 0.005209\n catchAllAtomType htmlAnyAtom\n catchAllParser htmlLineParser\nopenGraphParser\n // todo: fix Parsers scope issue so we can move this parser def under scrollImageParser\n description Add this line to make this the open graph image.\n cueFromId\n atoms cueAtom\nlinkTitleParser\n popularity 0.000048\n description If you want to set the title of the link.\n cue title\n atoms cueAtom\n catchAllAtomType anyAtom\n example\n  * This report showed the treatment had a big impact.\n   https://example.com/report This report.\n    title The average growth in the treatment group was 14.2x higher than the control group.\nprogramLinkParser\n popularity 0.000531\n catchAllAtomType codeAtom\nabstractLoopConfigParser\n atoms cueAtom\n cueFromId\n catchAllAtomType stringAtom\nabstractItemsProviderParser\n atoms cueAtom\nloopLinesParser\n cue lines\n extends abstractItemsProviderParser\n description Iterate over the provided lines.\n catchAllParser loopLineParser\n loopLineParser\n  catchAllAtomType stringAtom\n javascript\n  get items() {\n   return this.map(particle => particle.asString)\n  }\nloopAtomsParser\n popularity 0.000024\n cue atoms\n extends abstractItemsProviderParser\n catchAllAtomType stringAtom\n description Iterate over the provided atoms.\n javascript\n  get items() {\n   return this.getAtomsFrom(1)\n  }\nloopTagsParser\n cue tags\n extends abstractItemsProviderParser\n catchAllAtomType tagWithOptionalFolderAtom\n description Set this to iterate over scroll files in a folder. Provide both the folder and group name like this: [folder]/[tag]\n javascript\n  get items() {\n   return this.root.file.getFilesWithTagsForEmbedding(this.content)\n  }\nscrollMediaLoopParser\n popularity 0.000048\n cue loop\n atoms cueAtom\nscrollAutoplayParser\n cue autoplay\n atoms cueAtom\nabstractColumnNameParser\n atoms cueAtom columnNameAtom\n javascript\n  getRunTimeEnumOptions(atom) {\n   if (atom.atomTypeId === \"columnNameAtom\")\n      return this.parent.columnNames\n   return super.getRunTimeEnumOptions(atom)\n  }\nscrollRadiusParser\n cue radius\n extends abstractColumnNameParser\nscrollSymbolParser\n cue symbol\n extends abstractColumnNameParser\nscrollFillParser\n cue fill\n extends abstractColumnNameParser\nscrollLabelParser\n cue label\n extends abstractColumnNameParser\nscrollXParser\n cue x\n extends abstractColumnNameParser\nscrollYParser\n cue y\n extends abstractColumnNameParser\nquoteLineParser\n popularity 0.004172\n catchAllAtomType anyAtom\n catchAllParser quoteLineParser\nscrollParser\n extensions scroll\n description Scroll is a language for scientists of all ages. Refine, share and collaborate on ideas.\n root\n inScope abstractScrollParser blankLineParser\n catchAllParser catchAllParagraphParser\n compilesTo html\n javascript\n  setFile(file) {\n   this.file = file\n   return this\n  }\n  compile(compileSettings) {\n    this.sectionStack = []\n    return this.map(subparticle => subparticle.compile(compileSettings)).filter(i => i).join(\"\\n\") + this.clearSectionStack()\n  }\n  sectionStack = []\n  clearSectionStack() {\n   const result = this.sectionStack.join(\"\")\n   this.sectionStack = []\n   return result\n  }\n  bodyStack = []\n  clearBodyStack() {\n   const result = this.bodyStack.join(\"\")\n   this.bodyStack = []\n   return result\n  }\n  get hakonParser() {\n    if (this.isNodeJs())\n      return require(\"scrollsdk/products/hakon.nodejs.js\")\n    return hakonParser\n  }\n  readSyncFromFileOrUrl(fileOrUrl) {\n    if (!this.isNodeJs()) return localStorage.getItem(fileOrUrl) || \"\"\n    const isUrl = fileOrUrl.match(/^https?\\:[^ ]+$/)\n    if (!isUrl) return this.root.readFile(fileOrUrl)\n    return this.readFile(this.makeFullPath(new URL(fileOrUrl).pathname.split('/').pop()))\n  }\n  async fetch(url, filename) {\n    const isUrl = url.match(/^https?\\:[^ ]+$/)\n    if (!isUrl) return\n    return this.isNodeJs() ? this.fetchNode(url, filename) : this.fetchBrowser(url)\n  }\n  makeFullPath(filename) {\n    return require(\"path\").join(this.file.folderPath, filename)\n  }\n  async fetchNode(url, filename) {\n    filename = filename || new URL(url).pathname.split('/').pop()\n    const fullpath = this.makeFullPath(filename)\n    if (require(\"fs\").existsSync(fullpath)) return this.readFile(fullpath)\n    this.log(`🛜 fetching ${url} to ${fullpath} `)\n    await this.downloadToDisk(url, fullpath)\n    return this.readFile(fullpath)\n  }\n  log(message) {\n    console.log(message)\n  }\n  async fetchBrowser(url) {\n    const content = localStorage.getItem(url)\n    if (content) return content\n    return this.downloadToLocalStorage(url)\n  }\n  async downloadToDisk(url, destination) {\n    const { writeFile } = require('fs').promises\n    const response = await fetch(url)\n    const fileBuffer = await response.arrayBuffer()\n    await writeFile(destination, Buffer.from(fileBuffer))\n    return this.readFile(destination)\n  }\n  async downloadToLocalStorage(url) {\n    const response = await fetch(url)\n    const blob = await response.blob()\n    localStorage.setItem(url, await blob.text())\n    return localStorage.getItem(url)\n  }\n  readFile(filename) {\n    const path = require(\"path\")\n    const fs = require(\"fs\")\n    const fullPath = path.join(this.file.folderPath, filename.replace(this.file.folderPath, \"\"))\n    if (fs.existsSync(fullPath))\n      return fs.readFileSync(fullPath, \"utf8\")\n    console.error(`File '${filename}' not found`)\n    return \"\"\n  }\n  alreadyRequired = new Set()\n  compileEmbeddedVersion(compileSettings) {\n   this.sectionStack = []\n   return this.map(subparticle => (subparticle.compileEmbeddedVersion ? subparticle.compileEmbeddedVersion(compileSettings) : subparticle.compile(compileSettings)))\n     .filter(i => i)\n     .join(\"\\n\")\n     .trim() + this.clearSectionStack()\n  }\n  get footnotes() {\n   if (this._footnotes === undefined) this._footnotes = this.filter(particle => particle.isFootnote)\n   return this._footnotes\n  }\n  async build() {\n    await Promise.all(this.filter(particle => particle.build).map(async particle => particle.build()))\n  }\n  file = {}\n  get title() {\n    return this.file.title || this.get(\"title\")\n  }\n  get permalink() {\n   return this.get(\"permalink\") || this.file.permalink || \"\"\n  }\n example\n  # Hello world\n  ## This is Scroll\n  * It compiles to HTML.\n  \n  code\n   // You can add code as well.\n   print(\"Hello world\")\nscriptLineParser\n catchAllAtomType scriptAnyAtom\n catchAllParser scriptLineParser\nstampFileParser\n catchAllAtomType stringAtom\n description Create a file.\n javascript\n  build(parentDir) {\n   const fs = require(\"fs\")\n   const path = require(\"path\")\n   const fullPath = path.join(parentDir, this.getLine())\n   this.root.file.log(`Creating file ${fullPath}`)\n   fs.mkdirSync(path.dirname(fullPath), {recursive: true})\n   const content = this.subparticlesToString()\n   fs.writeFileSync(fullPath, content, \"utf8\")\n   const isExecutable = content.startsWith(\"#!\")\n   if (isExecutable) fs.chmodSync(fullPath, \"755\")\n  }\nstampFolderParser\n catchAllAtomType stringAtom\n description Create a folder.\n inScope stampFolderParser\n catchAllParser stampFileParser\n pattern \\/$\n javascript\n  build(parentDir) {\n   const fs = require(\"fs\")\n   const path = require(\"path\")\n   const newPath = path.join(parentDir, this.getLine())\n   this.root.file.log(`Creating folder ${newPath}`)\n   fs.mkdirSync(newPath, {recursive: true})\n   this.forEach(particle => particle.build(newPath))\n  }\nstumpContentParser\n popularity 0.102322\n catchAllAtomType anyAtom\nscrollTableDataParser\n popularity 0.001061\n cue data\n description Table from inline delimited data.\n catchAllAtomType anyAtom\n baseParser blobParser\nscrollTableDelimiterParser\n popularity 0.001037\n description Set the delimiter.\n cue delimiter\n atoms cueAtom stringAtom\n javascript\n  compile() {\n    return \"\"\n  }\nplainTextLineParser\n popularity 0.000121\n catchAllAtomType stringAtom\n catchAllParser plainTextLineParser"}