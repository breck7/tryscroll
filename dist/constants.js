const AppConstants = {"grammar":"tooling A function generates this Scrolldown grammar by combining all files in the grammars folder.\ndateCell\n highlightScope string\nintegerCell\n highlightScope constant.numeric\npermalinkCell\n highlightScope string\nanyCell\nurlCell\n highlightScope constant.language\nkeywordCell\n highlightScope keyword\ntextCell\n highlightScope string\nblankCell\ncodeCell\n highlightScope comment\ncommentCell\n highlightScope comment\nbulletPointCell\n highlightScope keyword\naftertextTextNode\n catchAllCellType textCell\nabstractScrollNode\n abstract\n cells keywordCell\naftertextNode\n description Text followed by markup commands.\n extends abstractScrollNode\n catchAllNodeType aftertextTextNode\n inScope abstractMarkupNode\n crux aftertext\n example\n  aftertext\n   Hello brave new world\n   link home.com new\n   bold brave new\n   underline new world\n   strikethrough wor\n javascript\n  get markupInserts() {\n   const { originalText } = this\n   return this.filter(node => node.isMarkupNode)\n    .map(node => node.getInserts(originalText))\n    .filter(i => i)\n    .flat()\n  }\n  get originalText() {\n   return this.filter(node => !node.isMarkupNode)\n    .map(node => node.toString())\n    .join(\"\\n\")\n  }\n  get text() {\n   const { originalText, markupInserts } = this\n   let adjustment = 0\n   let newText = originalText\n   markupInserts.sort((a, b) => a.index - b.index)\n   markupInserts.forEach(insertion => {\n    insertion.index += adjustment\n    newText = newText.slice(0, insertion.index) + insertion.string + newText.slice(insertion.index)\n    adjustment += insertion.string.length\n   })\n   return newText\n  }\n  compile() {\n   return `<p class=\"scrollParagraphComponent\">${this.text}</p>`\n  }\nabstractTopLevelSingleMetaNode\n abstract\n description Use these keywords once per file.\n extends abstractScrollNode\n cells keywordCell\n compiler\n  stringTemplate \npermalinkNode\n description When compiling, Scroll will save this article to {permalink}.html\n crux permalink\n extends abstractTopLevelSingleMetaNode\n cells keywordCell permalinkCell\nskipIndexPageNode\n description Add this tag if you want to build a page but not include it in the index page.\n crux skipIndexPage\n extends abstractTopLevelSingleMetaNode\ntitleNode\n catchAllCellType textCell\n description Title of the article.\n extends abstractTopLevelSingleMetaNode\n crux title\n javascript\n  compile() {\n   return `<h1 class=\"scrollShowcaseComponent\"><a href=\"${this.getRootNode().permalink}.html\">${this.getContent()}</a></h1>`\n  }\ndateNode\n catchAllCellType dateCell\n description Date the article was first published.\n extends abstractTopLevelSingleMetaNode\n crux date\nmaxColumnsNode\n catchAllCellType integerCell\n description Set your own max column count for the generated HTML.\n extends abstractTopLevelSingleMetaNode\n crux maxColumns\ncolumnWidthNode\n catchAllCellType integerCell\n description Set your own column width, in ch units, for the generated HTML.\n extends abstractTopLevelSingleMetaNode\n crux columnWidth\nchatNode\n description A dialogue between two people.\n catchAllNodeType chatLineNode\n crux chat\n extends abstractScrollNode\n javascript\n  compile() {\n   return this.map((line, index) => `<div class=\"scrollDialogueComponent ${index % 2 ? \"scrollDialogueComponentRight\" : \"scrollDialogueComponentLeft\"}\"><span>${line.toString()}</span></div>`).join(\"\")\n  }\ncodeNode\n description A code block.\n catchAllNodeType lineOfCodeNode\n extends abstractScrollNode\n javascript\n  compile() {\n   return `<code class=\"scrollCodeBlockComponent\">${this.childrenToString().replace(/\\</g, \"&lt;\")}</code>`\n  }\n crux code\ncodeWithLanguageNode\n description Use this to specify the language of the code block, such as csvCode or rustCode.\n extends codeNode\n pattern ^[a-zA-Z0-9_]+Code$\nbelowAsCodeNode\n description Print the Scroll code of the next node.\n extends abstractScrollNode\n crux belowAsCode\n javascript\n  get target() {\n   return this.getNext()\n  }\n  compile() {\n   return `<code class=\"scrollCodeBlockComponent\">${this.target.toString().replace(/\\</g, \"&lt;\")}</code>`\n  }\naboveAsCodeNode\n description Print the Scroll code for the previous node.\n extends belowAsCodeNode\n crux aboveAsCode\n javascript\n  get target() {\n   return this.getPrevious()\n  }\ncommentNode\n description Will not appear in the compiled HTML.\n catchAllCellType commentCell\n extends abstractScrollNode\n crux comment\n javascript\n  compile() {\n   return ``\n  }\n catchAllNodeType commentLineNode\nabstractHeaderNode\n catchAllCellType textCell\n extends abstractScrollNode\n catchAllNodeType multilineTitleNode\n javascript\n  compile() {\n   const children = this.childrenToString() ? \" \" + this.childrenToString() : \"\"\n   return `<${this.tag} class=\"${this.className}\">${this.getContent() + children}</${this.tag}>`\n  }\nsectionNode\n description Compiles to an h3 tag.\n extends abstractHeaderNode\n crux section\n javascript\n  tag = \"h3\"\n  className = \"scrollSectionComponent\"\nsubsectionNode\n description Compiles to an h4 tag.\n extends abstractHeaderNode\n crux subsection\n javascript\n  tag = \"h4\"\n  className = \"scrollSubsectionComponent\"\nquestionNode\n description Use for pages like FAQs.\n extends abstractHeaderNode\n crux question\n javascript\n  tag = \"h4\"\n  className = \"scrollQuestionComponent\"\nhtmlNode\n description A catch all block to drop in any loose html.\n crux html\n extends abstractScrollNode\n catchAllNodeType htmlLineNode\n javascript\n  compile() {\n   return `${this.childrenToString()}`\n  }\nimageNode\n description An img tag.\n cells keywordCell urlCell\n extends abstractScrollNode\n crux image\n inScope imageCaptionNode\n javascript\n  compile() {\n   const src = this.getWord(1)\n   let imgTag = \"\"\n   try {\n    const sizeOf = require(\"image-size\")\n    const dimensions = sizeOf(src)\n    const width = dimensions.width\n    const height = dimensions.height\n    imgTag = `<img src=\"${src}\" width=\"${width}\" height=\"${height}\" loading=\"lazy\"/>`\n   } catch (err) {\n    console.error(err)\n    imgTag = `<img src=\"${src}\">`\n   }\n   const caption = this.get(\"caption\")\n   const captionFig = caption ? `<figcaption>${caption}</figcaption>` : \"\"\n   return `<figure class=\"scrollImageComponent\"><a href=\"${src}\" target=\"_blank\">${imgTag}</a>${captionFig}</figure>`\n  }\ncustomHeaderNode\n extends abstractScrollNode\n description Define a header for a certain page. Setting to blank will also remove the header on a page.\n crux header\n catchAllNodeType stumpNode\n javascript\n  compile() {\n   return \"\"\n  }\ncustomFooterNode\n extends abstractScrollNode\n description Define a footer for a certain page. Setting to blank will also remove the footer on a page.\n crux footer\n catchAllNodeType stumpNode\n javascript\n  compile() {\n   return \"\"\n  }\nlistNode\n description An unordered list.\n catchAllNodeType listItemNode\n crux list\n extends abstractScrollNode\n compiler\n  stringTemplate \n  openChildren <ul class=\"scrollUnorderedListComponent\">\n  closeChildren </ul>\norderedListNode\n description An ordered list.\n extends listNode\n crux orderedList\n compiler\n  stringTemplate \n  openChildren <ol class=\"scrollOrderedListComponent\">\n  closeChildren </ol>\nparagraphNode\n description Prose content.\n catchAllNodeType paragraphContentNode\n extends abstractScrollNode\n crux paragraph\n javascript\n  get dateHtml() {\n   const rootNode = this.getParent()\n   const isFirst = rootNode.indexOf(\"paragraph\") === this.getIndex()\n   if (!isFirst) return \"\"\n   const day = rootNode.get(\"date\")\n   if (!day) return \"\"\n   try {\n    const dayjs = require(\"dayjs\")\n    return `<span class=\"scrollArticleDateComponent\">${dayjs(day).format(`MMMM D, YYYY`)} â€” </span>`\n   } catch (err) {\n    console.error(err)\n    return \"\"\n   }\n  }\n  get paragraphContent() {\n   return this.childrenToString()\n  }\n  compile() {\n   return `<p class=\"scrollParagraphComponent\">${this.dateHtml}${this.getRootNode().compileATags(this.paragraphContent)}</p>`\n  }\nquoteNode\n description A blockquote.\n catchAllNodeType quoteLineNode\n extends abstractScrollNode\n javascript\n  compile() {\n   return `<blockquote class=\"scrollQuoteComponent\">${this.childrenToString()}</blockquote>`\n  }\n crux quote\nabstractTableNode\n catchAllNodeType rowNode\n extends abstractScrollNode\n javascript\n  _delimiter = \" \"\n  get tableHeader() {\n   const header = this.nodeAt(0)\n   return header\n    ? header\n      .getLine()\n      .split(this._delimiter)\n      .map(word => `<th>${word}</th>\\n`)\n    : []\n  }\n  getTableBody(columnCount) {\n   const delimiter = this._delimiter\n   return this.getTopDownArray()\n    .slice(1)\n    .map(node => `<tr>${node.toRow(columnCount, delimiter)}</tr>`)\n    .join(\"\\n\")\n  }\n  compile() {\n   const tableHeader = this.tableHeader\n   return `<table class=\"scrollTableComponent\"><thead><tr>${tableHeader.join(\"\\n\")}</tr></thead>\\n<tbody>${this.getTableBody(tableHeader.length)}</tbody></table>`\n  }\ncommaTableNode\n crux commaTable\n description Comma separated values table.\n extends abstractTableNode\n javascript\n  _delimiter = \",\"\npipeTableNode\n crux pipeTable\n description Pipie separated values table.\n extends abstractTableNode\n javascript\n  _delimiter = \"|\"\ntabTableNode\n crux tabTable\n description Tab separated values table.\n extends abstractTableNode\n javascript\n  _delimiter = \"\\t\"\nspaceTableNode\n description Space separated values table. Last column is a catch all.\n extends abstractTableNode\n crux spaceTable\nabstractMarkupNode\n cells keywordCell\n catchAllCellType textCell\n javascript\n  isMarkupNode = true\n  get pattern() {\n   return this.getWordsFrom(1).join(\" \")\n  }\n  getInserts(text) {\n   const { pattern } = this\n   const start = text.indexOf(pattern)\n   if (start === -1) return false\n   return [\n    { index: start, string: `<${this.openTag}>` },\n    { index: start + pattern.length, string: `</${this.closeTag}>` }\n   ]\n  }\n  get openTag() {\n   return this.tag\n  }\n  get closeTag() {\n   return this.tag\n  }\nboldNode\n crux bold\n extends abstractMarkupNode\n javascript\n  tag = \"b\"\nitalicsNode\n crux italics\n extends abstractMarkupNode\n javascript\n  tag = \"i\"\nunderlineNode\n crux underline\n extends abstractMarkupNode\n javascript\n  tag = \"u\"\naftertextCodeNode\n crux code\n extends abstractMarkupNode\n javascript\n  tag = \"code\"\nlinkNode\n extends abstractMarkupNode\n cells keywordCell urlCell\n crux link\n javascript\n  tag = \"a\"\n  get link() {\n   return this.getWord(1)\n  }\n  get openTag() {\n   return `a href=\"${this.link}\"`\n  }\n  get pattern() {\n   return this.getWordsFrom(2).join(\" \")\n  }\nemailLinkNode\n description A mailto link\n crux email\n extends linkNode\n javascript\n  get openTag() {\n   return `a href=\"mailto:${this.link}\"`\n  }\nquickLinkNode\n pattern ^https\\:\n extends linkNode\n cells urlCell\n javascript\n  get link() {\n   return this.getWord(0)\n  }\n  get pattern() {\n   return this.getWordsFrom(1).join(\" \")\n  }\nstrikethroughNode\n crux strikethrough\n extends abstractMarkupNode\n javascript\n  tag = \"s\"\nerrorNode\n baseNodeType errorNode\nscrolldownNode\n extensions scroll\n description A simple language for structurable thought. An extensible alternative to Markdown. Compiles to HTML.\n root\n inScope abstractScrollNode blankLineNode\n catchAllNodeType quickParagraphNode\n compilesTo html\n javascript\n  get permalink() {\n   return this.get(\"permalink\") || this._permalink || \"\"\n  }\n  setPermalink(permalink) {\n   this._permalink = permalink\n   return this\n  }\n  compileATags(text) {\n   // todo: a better place for these util functions? I stick them in here so the\n   // grammar is all in one file for ease of use in TreeLanguageDesigner\n   const linkReplacer = (match, p1, p2, p3, offset, str) => {\n    let suffix = \"\"\n    if (p3.endsWith(\",\")) suffix = \",\" + suffix\n    if (p3.endsWith(\".\")) suffix = \".\" + suffix\n    p3 = p3.replace(/(,|\\.)$/, \"\")\n    let prefix = \"https://\"\n    const isRelativeLink = p3.startsWith(\"./\")\n    if (isRelativeLink) {\n     prefix = \"\"\n     p3 = p3.substr(2)\n    }\n    if (p3.startsWith(\"https://\") || p3.startsWith(\"http://\")) prefix = \"\"\n    return `${p1}<a href=\"${prefix}${p3}\">${p2}</a>${suffix}`\n   }\n   return text.replace(/(^|\\s)(\\S+)ðŸ”—(\\S+)(?=(\\s|$))/g, linkReplacer)\n  }\n example\n  title Hello world\n  section This is Scrolldown\n  \n  paragraph\n   It compiles to HTML. Blank lines get turned into brs.\n  \n  code\n   // You can add code as well.\n   print(\"Hello world\")\nblankLineNode\n description Blank lines compile to nothing in the HTML.\n cells blankCell\n compiler\n  stringTemplate \n pattern ^$\n tags doNotSynthesize\nquickParagraphNode\n description A catch all block. This may be removed in future versions.\n catchAllCellType textCell\n baseNodeType errorNode\n compiler\n  stringTemplate <p class=\"scrollParagraphComponent\">{textCell}</p>\nchatLineNode\n catchAllCellType anyCell\n catchAllNodeType chatLineNode\nlineOfCodeNode\n catchAllCellType codeCell\n catchAllNodeType lineOfCodeNode\ncommentLineNode\n catchAllCellType commentCell\nmultilineTitleNode\n catchAllCellType textCell\nhtmlLineNode\n catchAllCellType anyCell\n catchAllNodeType htmlLineNode\nimageCaptionNode\n description An optional caption to accompany the image.\n crux caption\n cells keywordCell\n catchAllCellType textCell\nstumpNode\n description Stump is a Tree Language that compiles to HTML.\n catchAllCellType anyCell\n catchAllNodeType stumpNode\nlistItemNode\n cells bulletPointCell\n catchAllCellType textCell\n javascript\n  compile() {\n   return `<li>${this.getRootNode().compileATags(this.getContent() || \"\")}</li>`\n  }\nparagraphContentNode\n catchAllCellType textCell\nquoteLineNode\n catchAllCellType anyCell\n catchAllNodeType quoteLineNode\nrowNode\n catchAllCellType textCell\n javascript\n  toRow(columnCount, delimiter) {\n   const words = this.getLine().split(delimiter)\n   let str = \"\"\n   let column = 0\n   while (column < columnCount) {\n    column++\n    const content = columnCount === column ? words.slice(columnCount - 1).join(\" \") : words[column - 1]\n    str += `<td>${this.getRootNode().compileATags(content ?? \"\")}</td>\\n`\n   }\n   return str\n  }"}